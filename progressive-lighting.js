!function (n, t) { if ("object" == typeof exports && "object" == typeof module) module.exports = t(require("gloperate")); else if ("function" == typeof define && define.amd) define(["gloperate"], t); else { var e = "object" == typeof exports ? t(require("gloperate")) : t(n.gloperate); for (var r in e) ("object" == typeof exports ? exports : n)[r] = e[r] } }(window, (function (n) { return function (n) { var t = {}; function e(r) { if (t[r]) return t[r].exports; var i = t[r] = { i: r, l: !1, exports: {} }; return n[r].call(i.exports, i, i.exports, e), i.l = !0, i.exports } return e.m = n, e.c = t, e.d = function (n, t, r) { e.o(n, t) || Object.defineProperty(n, t, { enumerable: !0, get: r }) }, e.r = function (n) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(n, "__esModule", { value: !0 }) }, e.t = function (n, t) { if (1 & t && (n = e(n)), 8 & t) return n; if (4 & t && "object" == typeof n && n && n.__esModule) return n; var r = Object.create(null); if (e.r(r), Object.defineProperty(r, "default", { enumerable: !0, value: n }), 2 & t && "string" != typeof n) for (var i in n) e.d(r, i, function (t) { return n[t] }.bind(null, i)); return r }, e.n = function (n) { var t = n && n.__esModule ? function () { return n.default } : function () { return n }; return e.d(t, "a", t), t }, e.o = function (n, t) { return Object.prototype.hasOwnProperty.call(n, t) }, e.p = "", e(e.s = 3) }([function (t, e) { t.exports = n }, function (n, t) { n.exports = "precision highp float;\n\n// Adapted from https://github.com/KhronosGroup/glTF-WebGL-PBR\n\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else\n    #define varying out\n#endif\n\n\nvoid ndcOffset(inout vec4 vertex, in vec2 offset) {\n    vertex.xy = offset * vec2(vertex.w) + vertex.xy;\n}\n\n\nconst int HAS_NORMALS           = 1;\nconst int HAS_TANGENTS          = 1 << 1;\nconst int HAS_UV                = 1 << 2;\nconst int HAS_COLORS            = 1 << 3;\n\n#if __VERSION__ == 100\n    attribute vec4 a_position;\n    attribute vec4 a_normal;\n    attribute vec4 a_tangent;\n    attribute vec2 a_texcoord_0;\n    attribute vec2 a_texcoord_1;\n    attribute vec2 a_texcoord_2;\n    attribute vec4 a_joints;\n    attribute vec4 a_weights;\n    attribute vec4 a_color;\n#else\n    layout (location = 0) in vec4 a_position;\n    layout (location = 1) in vec3 a_normal;\n    layout (location = 2) in vec4 a_tangent;\n    layout (location = 3) in vec2 a_texcoord_0;\n    layout (location = 4) in vec2 a_texcoord_1;\n    layout (location = 5) in vec2 a_texcoord_2;\n    layout (location = 6) in vec4 a_joints;\n    layout (location = 7) in vec4 a_weights;\n    layout (location = 8) in vec4 a_color;\n#endif\n\nuniform mat4 u_model;\nuniform mat4 u_projection;\nuniform mat4 u_view;\nuniform mat3 u_normalMatrix;\n\nuniform mediump int u_geometryFlags;\n\nuniform vec2 u_ndcOffset;\nuniform vec2 u_cocPoint;\n\nvarying vec2 v_uv[3];\nvarying vec4 v_color;\nvarying vec3 v_position;\n\nvarying mat3 v_TBN;\nvarying vec3 v_normal;\n\nbool checkFlag(int flag) {\n    return (u_geometryFlags & flag) == flag;\n}\n\nvec4 depthOfField(mat4 modelView, vec4 worldPos, vec2 cocPoint, float focalDist)\n{\n    vec4 viewVertex = modelView * worldPos;\n    viewVertex.xy += cocPoint * (viewVertex.z + focalDist);\n    return viewVertex;\n}\n\nvoid main(void)\n{\n    vec4 pos = u_model * a_position;\n    v_position = vec3(pos.xyz) / pos.w;\n\n    if (checkFlag(HAS_NORMALS)) {\n        if (checkFlag(HAS_TANGENTS)) {\n            vec3 normalW = normalize(vec3(u_normalMatrix * a_normal));\n            vec3 tangentW = normalize(vec3(u_model * vec4(a_tangent.xyz, 0.0)));\n            vec3 bitangentW = cross(normalW, tangentW) * a_tangent.w;\n            v_TBN = mat3(tangentW, bitangentW, normalW);\n        } else { // HAS_TANGENTS != 1\n            v_normal = normalize(vec3(u_model * vec4(a_normal.xyz, 0.0)));\n        }\n    }\n\n    if (checkFlag(HAS_UV)) {\n        v_uv[0] = a_texcoord_0;\n        v_uv[1] = a_texcoord_1;\n        v_uv[2] = a_texcoord_2;\n    } else {\n        v_uv[0] = vec2(0., 0.);\n        v_uv[1] = vec2(0., 0.);\n        v_uv[2] = vec2(0., 0.);\n    }\n\n    if (checkFlag(HAS_COLORS)) {\n        v_color = a_color;\n    } else {\n        v_color = vec4(1.0);\n    }\n\n    vec4 viewVertex = depthOfField(u_view * u_model, a_position, u_cocPoint, 8.0);\n    gl_Position = u_projection * viewVertex;\n    ndcOffset(gl_Position, u_ndcOffset);\n}\n" }, function (n, t, e) { "use strict"; e.r(t), e.d(t, "glMatrix", (function () { return r })), e.d(t, "mat2", (function () { return i })), e.d(t, "mat2d", (function () { return o })), e.d(t, "mat3", (function () { return a })), e.d(t, "mat4", (function () { return u })), e.d(t, "quat", (function () { return l })), e.d(t, "quat2", (function () { return f })), e.d(t, "vec2", (function () { return h })), e.d(t, "vec3", (function () { return s })), e.d(t, "vec4", (function () { return c })); var r = {}; e.r(r), e.d(r, "EPSILON", (function () { return d })), e.d(r, "ARRAY_TYPE", (function () { return m })), e.d(r, "RANDOM", (function () { return p })), e.d(r, "setMatrixArrayType", (function () { return v })), e.d(r, "toRadian", (function () { return g })), e.d(r, "equals", (function () { return b })); var i = {}; e.r(i), e.d(i, "create", (function () { return M })), e.d(i, "clone", (function () { return x })), e.d(i, "copy", (function () { return S })), e.d(i, "identity", (function () { return w })), e.d(i, "fromValues", (function () { return y })), e.d(i, "set", (function () { return P })), e.d(i, "transpose", (function () { return L })), e.d(i, "invert", (function () { return T })), e.d(i, "adjoint", (function () { return R })), e.d(i, "determinant", (function () { return E })), e.d(i, "multiply", (function () { return F })), e.d(i, "rotate", (function () { return N })), e.d(i, "scale", (function () { return A })), e.d(i, "fromRotation", (function () { return D })), e.d(i, "fromScaling", (function () { return C })), e.d(i, "str", (function () { return O })), e.d(i, "frob", (function () { return V })), e.d(i, "LDU", (function () { return B })), e.d(i, "add", (function () { return I })), e.d(i, "subtract", (function () { return z })), e.d(i, "exactEquals", (function () { return k })), e.d(i, "equals", (function () { return G })), e.d(i, "multiplyScalar", (function () { return U })), e.d(i, "multiplyScalarAndAdd", (function () { return q })), e.d(i, "mul", (function () { return H })), e.d(i, "sub", (function () { return j })); var o = {}; e.r(o), e.d(o, "create", (function () { return X })), e.d(o, "clone", (function () { return W })), e.d(o, "copy", (function () { return K })), e.d(o, "identity", (function () { return Q })), e.d(o, "fromValues", (function () { return Y })), e.d(o, "set", (function () { return Z })), e.d(o, "invert", (function () { return J })), e.d(o, "determinant", (function () { return $ })), e.d(o, "multiply", (function () { return nn })), e.d(o, "rotate", (function () { return tn })), e.d(o, "scale", (function () { return en })), e.d(o, "translate", (function () { return rn })), e.d(o, "fromRotation", (function () { return on })), e.d(o, "fromScaling", (function () { return an })), e.d(o, "fromTranslation", (function () { return un })), e.d(o, "str", (function () { return sn })), e.d(o, "frob", (function () { return cn })), e.d(o, "add", (function () { return ln })), e.d(o, "subtract", (function () { return fn })), e.d(o, "multiplyScalar", (function () { return hn })), e.d(o, "multiplyScalarAndAdd", (function () { return dn })), e.d(o, "exactEquals", (function () { return mn })), e.d(o, "equals", (function () { return pn })), e.d(o, "mul", (function () { return vn })), e.d(o, "sub", (function () { return _n })); var a = {}; e.r(a), e.d(a, "create", (function () { return gn })), e.d(a, "fromMat4", (function () { return bn })), e.d(a, "clone", (function () { return Mn })), e.d(a, "copy", (function () { return xn })), e.d(a, "fromValues", (function () { return Sn })), e.d(a, "set", (function () { return wn })), e.d(a, "identity", (function () { return yn })), e.d(a, "transpose", (function () { return Pn })), e.d(a, "invert", (function () { return Ln })), e.d(a, "adjoint", (function () { return Tn })), e.d(a, "determinant", (function () { return Rn })), e.d(a, "multiply", (function () { return En })), e.d(a, "translate", (function () { return Fn })), e.d(a, "rotate", (function () { return Nn })), e.d(a, "scale", (function () { return An })), e.d(a, "fromTranslation", (function () { return Dn })), e.d(a, "fromRotation", (function () { return Cn })), e.d(a, "fromScaling", (function () { return On })), e.d(a, "fromMat2d", (function () { return Vn })), e.d(a, "fromQuat", (function () { return Bn })), e.d(a, "normalFromMat4", (function () { return In })), e.d(a, "projection", (function () { return zn })), e.d(a, "str", (function () { return kn })), e.d(a, "frob", (function () { return Gn })), e.d(a, "add", (function () { return Un })), e.d(a, "subtract", (function () { return qn })), e.d(a, "multiplyScalar", (function () { return Hn })), e.d(a, "multiplyScalarAndAdd", (function () { return jn })), e.d(a, "exactEquals", (function () { return Xn })), e.d(a, "equals", (function () { return Wn })), e.d(a, "mul", (function () { return Kn })), e.d(a, "sub", (function () { return Qn })); var u = {}; e.r(u), e.d(u, "create", (function () { return Yn })), e.d(u, "clone", (function () { return Zn })), e.d(u, "copy", (function () { return Jn })), e.d(u, "fromValues", (function () { return $n })), e.d(u, "set", (function () { return nt })), e.d(u, "identity", (function () { return tt })), e.d(u, "transpose", (function () { return et })), e.d(u, "invert", (function () { return rt })), e.d(u, "adjoint", (function () { return it })), e.d(u, "determinant", (function () { return ot })), e.d(u, "multiply", (function () { return at })), e.d(u, "translate", (function () { return ut })), e.d(u, "scale", (function () { return st })), e.d(u, "rotate", (function () { return ct })), e.d(u, "rotateX", (function () { return lt })), e.d(u, "rotateY", (function () { return ft })), e.d(u, "rotateZ", (function () { return ht })), e.d(u, "fromTranslation", (function () { return dt })), e.d(u, "fromScaling", (function () { return mt })), e.d(u, "fromRotation", (function () { return pt })), e.d(u, "fromXRotation", (function () { return vt })), e.d(u, "fromYRotation", (function () { return _t })), e.d(u, "fromZRotation", (function () { return gt })), e.d(u, "fromRotationTranslation", (function () { return bt })), e.d(u, "fromQuat2", (function () { return Mt })), e.d(u, "getTranslation", (function () { return xt })), e.d(u, "getScaling", (function () { return St })), e.d(u, "getRotation", (function () { return wt })), e.d(u, "fromRotationTranslationScale", (function () { return yt })), e.d(u, "fromRotationTranslationScaleOrigin", (function () { return Pt })), e.d(u, "fromQuat", (function () { return Lt })), e.d(u, "frustum", (function () { return Tt })), e.d(u, "perspective", (function () { return Rt })), e.d(u, "perspectiveFromFieldOfView", (function () { return Et })), e.d(u, "ortho", (function () { return Ft })), e.d(u, "lookAt", (function () { return Nt })), e.d(u, "targetTo", (function () { return At })), e.d(u, "str", (function () { return Dt })), e.d(u, "frob", (function () { return Ct })), e.d(u, "add", (function () { return Ot })), e.d(u, "subtract", (function () { return Vt })), e.d(u, "multiplyScalar", (function () { return Bt })), e.d(u, "multiplyScalarAndAdd", (function () { return It })), e.d(u, "exactEquals", (function () { return zt })), e.d(u, "equals", (function () { return kt })), e.d(u, "mul", (function () { return Gt })), e.d(u, "sub", (function () { return Ut })); var s = {}; e.r(s), e.d(s, "create", (function () { return qt })), e.d(s, "clone", (function () { return Ht })), e.d(s, "length", (function () { return jt })), e.d(s, "fromValues", (function () { return Xt })), e.d(s, "copy", (function () { return Wt })), e.d(s, "set", (function () { return Kt })), e.d(s, "add", (function () { return Qt })), e.d(s, "subtract", (function () { return Yt })), e.d(s, "multiply", (function () { return Zt })), e.d(s, "divide", (function () { return Jt })), e.d(s, "ceil", (function () { return $t })), e.d(s, "floor", (function () { return ne })), e.d(s, "min", (function () { return te })), e.d(s, "max", (function () { return ee })), e.d(s, "round", (function () { return re })), e.d(s, "scale", (function () { return ie })), e.d(s, "scaleAndAdd", (function () { return oe })), e.d(s, "distance", (function () { return ae })), e.d(s, "squaredDistance", (function () { return ue })), e.d(s, "squaredLength", (function () { return se })), e.d(s, "negate", (function () { return ce })), e.d(s, "inverse", (function () { return le })), e.d(s, "normalize", (function () { return fe })), e.d(s, "dot", (function () { return he })), e.d(s, "cross", (function () { return de })), e.d(s, "lerp", (function () { return me })), e.d(s, "hermite", (function () { return pe })), e.d(s, "bezier", (function () { return ve })), e.d(s, "random", (function () { return _e })), e.d(s, "transformMat4", (function () { return ge })), e.d(s, "transformMat3", (function () { return be })), e.d(s, "transformQuat", (function () { return Me })), e.d(s, "rotateX", (function () { return xe })), e.d(s, "rotateY", (function () { return Se })), e.d(s, "rotateZ", (function () { return we })), e.d(s, "angle", (function () { return ye })), e.d(s, "zero", (function () { return Pe })), e.d(s, "str", (function () { return Le })), e.d(s, "exactEquals", (function () { return Te })), e.d(s, "equals", (function () { return Re })), e.d(s, "sub", (function () { return Fe })), e.d(s, "mul", (function () { return Ne })), e.d(s, "div", (function () { return Ae })), e.d(s, "dist", (function () { return De })), e.d(s, "sqrDist", (function () { return Ce })), e.d(s, "len", (function () { return Oe })), e.d(s, "sqrLen", (function () { return Ve })), e.d(s, "forEach", (function () { return Be })); var c = {}; e.r(c), e.d(c, "create", (function () { return Ie })), e.d(c, "clone", (function () { return ze })), e.d(c, "fromValues", (function () { return ke })), e.d(c, "copy", (function () { return Ge })), e.d(c, "set", (function () { return Ue })), e.d(c, "add", (function () { return qe })), e.d(c, "subtract", (function () { return He })), e.d(c, "multiply", (function () { return je })), e.d(c, "divide", (function () { return Xe })), e.d(c, "ceil", (function () { return We })), e.d(c, "floor", (function () { return Ke })), e.d(c, "min", (function () { return Qe })), e.d(c, "max", (function () { return Ye })), e.d(c, "round", (function () { return Ze })), e.d(c, "scale", (function () { return Je })), e.d(c, "scaleAndAdd", (function () { return $e })), e.d(c, "distance", (function () { return nr })), e.d(c, "squaredDistance", (function () { return tr })), e.d(c, "length", (function () { return er })), e.d(c, "squaredLength", (function () { return rr })), e.d(c, "negate", (function () { return ir })), e.d(c, "inverse", (function () { return or })), e.d(c, "normalize", (function () { return ar })), e.d(c, "dot", (function () { return ur })), e.d(c, "cross", (function () { return sr })), e.d(c, "lerp", (function () { return cr })), e.d(c, "random", (function () { return lr })), e.d(c, "transformMat4", (function () { return fr })), e.d(c, "transformQuat", (function () { return hr })), e.d(c, "zero", (function () { return dr })), e.d(c, "str", (function () { return mr })), e.d(c, "exactEquals", (function () { return pr })), e.d(c, "equals", (function () { return vr })), e.d(c, "sub", (function () { return _r })), e.d(c, "mul", (function () { return gr })), e.d(c, "div", (function () { return br })), e.d(c, "dist", (function () { return Mr })), e.d(c, "sqrDist", (function () { return xr })), e.d(c, "len", (function () { return Sr })), e.d(c, "sqrLen", (function () { return wr })), e.d(c, "forEach", (function () { return yr })); var l = {}; e.r(l), e.d(l, "create", (function () { return Pr })), e.d(l, "identity", (function () { return Lr })), e.d(l, "setAxisAngle", (function () { return Tr })), e.d(l, "getAxisAngle", (function () { return Rr })), e.d(l, "getAngle", (function () { return Er })), e.d(l, "multiply", (function () { return Fr })), e.d(l, "rotateX", (function () { return Nr })), e.d(l, "rotateY", (function () { return Ar })), e.d(l, "rotateZ", (function () { return Dr })), e.d(l, "calculateW", (function () { return Cr })), e.d(l, "exp", (function () { return Or })), e.d(l, "ln", (function () { return Vr })), e.d(l, "pow", (function () { return Br })), e.d(l, "slerp", (function () { return Ir })), e.d(l, "random", (function () { return zr })), e.d(l, "invert", (function () { return kr })), e.d(l, "conjugate", (function () { return Gr })), e.d(l, "fromMat3", (function () { return Ur })), e.d(l, "fromEuler", (function () { return qr })), e.d(l, "str", (function () { return Hr })), e.d(l, "clone", (function () { return Zr })), e.d(l, "fromValues", (function () { return Jr })), e.d(l, "copy", (function () { return $r })), e.d(l, "set", (function () { return ni })), e.d(l, "add", (function () { return ti })), e.d(l, "mul", (function () { return ei })), e.d(l, "scale", (function () { return ri })), e.d(l, "dot", (function () { return ii })), e.d(l, "lerp", (function () { return oi })), e.d(l, "length", (function () { return ai })), e.d(l, "len", (function () { return ui })), e.d(l, "squaredLength", (function () { return si })), e.d(l, "sqrLen", (function () { return ci })), e.d(l, "normalize", (function () { return li })), e.d(l, "exactEquals", (function () { return fi })), e.d(l, "equals", (function () { return hi })), e.d(l, "rotationTo", (function () { return di })), e.d(l, "sqlerp", (function () { return mi })), e.d(l, "setAxes", (function () { return pi })); var f = {}; e.r(f), e.d(f, "create", (function () { return vi })), e.d(f, "clone", (function () { return _i })), e.d(f, "fromValues", (function () { return gi })), e.d(f, "fromRotationTranslationValues", (function () { return bi })), e.d(f, "fromRotationTranslation", (function () { return Mi })), e.d(f, "fromTranslation", (function () { return xi })), e.d(f, "fromRotation", (function () { return Si })), e.d(f, "fromMat4", (function () { return wi })), e.d(f, "copy", (function () { return yi })), e.d(f, "identity", (function () { return Pi })), e.d(f, "set", (function () { return Li })), e.d(f, "getReal", (function () { return Ti })), e.d(f, "getDual", (function () { return Ri })), e.d(f, "setReal", (function () { return Ei })), e.d(f, "setDual", (function () { return Fi })), e.d(f, "getTranslation", (function () { return Ni })), e.d(f, "translate", (function () { return Ai })), e.d(f, "rotateX", (function () { return Di })), e.d(f, "rotateY", (function () { return Ci })), e.d(f, "rotateZ", (function () { return Oi })), e.d(f, "rotateByQuatAppend", (function () { return Vi })), e.d(f, "rotateByQuatPrepend", (function () { return Bi })), e.d(f, "rotateAroundAxis", (function () { return Ii })), e.d(f, "add", (function () { return zi })), e.d(f, "multiply", (function () { return ki })), e.d(f, "mul", (function () { return Gi })), e.d(f, "scale", (function () { return Ui })), e.d(f, "dot", (function () { return qi })), e.d(f, "lerp", (function () { return Hi })), e.d(f, "invert", (function () { return ji })), e.d(f, "conjugate", (function () { return Xi })), e.d(f, "length", (function () { return Wi })), e.d(f, "len", (function () { return Ki })), e.d(f, "squaredLength", (function () { return Qi })), e.d(f, "sqrLen", (function () { return Yi })), e.d(f, "normalize", (function () { return Zi })), e.d(f, "str", (function () { return Ji })), e.d(f, "exactEquals", (function () { return $i })), e.d(f, "equals", (function () { return no })); var h = {}; e.r(h), e.d(h, "create", (function () { return to })), e.d(h, "clone", (function () { return eo })), e.d(h, "fromValues", (function () { return ro })), e.d(h, "copy", (function () { return io })), e.d(h, "set", (function () { return oo })), e.d(h, "add", (function () { return ao })), e.d(h, "subtract", (function () { return uo })), e.d(h, "multiply", (function () { return so })), e.d(h, "divide", (function () { return co })), e.d(h, "ceil", (function () { return lo })), e.d(h, "floor", (function () { return fo })), e.d(h, "min", (function () { return ho })), e.d(h, "max", (function () { return mo })), e.d(h, "round", (function () { return po })), e.d(h, "scale", (function () { return vo })), e.d(h, "scaleAndAdd", (function () { return _o })), e.d(h, "distance", (function () { return go })), e.d(h, "squaredDistance", (function () { return bo })), e.d(h, "length", (function () { return Mo })), e.d(h, "squaredLength", (function () { return xo })), e.d(h, "negate", (function () { return So })), e.d(h, "inverse", (function () { return wo })), e.d(h, "normalize", (function () { return yo })), e.d(h, "dot", (function () { return Po })), e.d(h, "cross", (function () { return Lo })), e.d(h, "lerp", (function () { return To })), e.d(h, "random", (function () { return Ro })), e.d(h, "transformMat2", (function () { return Eo })), e.d(h, "transformMat2d", (function () { return Fo })), e.d(h, "transformMat3", (function () { return No })), e.d(h, "transformMat4", (function () { return Ao })), e.d(h, "rotate", (function () { return Do })), e.d(h, "angle", (function () { return Co })), e.d(h, "zero", (function () { return Oo })), e.d(h, "str", (function () { return Vo })), e.d(h, "exactEquals", (function () { return Bo })), e.d(h, "equals", (function () { return Io })), e.d(h, "len", (function () { return zo })), e.d(h, "sub", (function () { return ko })), e.d(h, "mul", (function () { return Go })), e.d(h, "div", (function () { return Uo })), e.d(h, "dist", (function () { return qo })), e.d(h, "sqrDist", (function () { return Ho })), e.d(h, "sqrLen", (function () { return jo })), e.d(h, "forEach", (function () { return Xo })); var d = 1e-6, m = "undefined" != typeof Float32Array ? Float32Array : Array, p = Math.random; function v(n) { m = n } var _ = Math.PI / 180; function g(n) { return n * _ } function b(n, t) { return Math.abs(n - t) <= d * Math.max(1, Math.abs(n), Math.abs(t)) } function M() { var n = new m(4); return m != Float32Array && (n[1] = 0, n[2] = 0), n[0] = 1, n[3] = 1, n } function x(n) { var t = new m(4); return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t } function S(n, t) { return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n } function w(n) { return n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 1, n } function y(n, t, e, r) { var i = new m(4); return i[0] = n, i[1] = t, i[2] = e, i[3] = r, i } function P(n, t, e, r, i) { return n[0] = t, n[1] = e, n[2] = r, n[3] = i, n } function L(n, t) { if (n === t) { var e = t[1]; n[1] = t[2], n[2] = e } else n[0] = t[0], n[1] = t[2], n[2] = t[1], n[3] = t[3]; return n } function T(n, t) { var e = t[0], r = t[1], i = t[2], o = t[3], a = e * o - i * r; return a ? (a = 1 / a, n[0] = o * a, n[1] = -r * a, n[2] = -i * a, n[3] = e * a, n) : null } function R(n, t) { var e = t[0]; return n[0] = t[3], n[1] = -t[1], n[2] = -t[2], n[3] = e, n } function E(n) { return n[0] * n[3] - n[2] * n[1] } function F(n, t, e) { var r = t[0], i = t[1], o = t[2], a = t[3], u = e[0], s = e[1], c = e[2], l = e[3]; return n[0] = r * u + o * s, n[1] = i * u + a * s, n[2] = r * c + o * l, n[3] = i * c + a * l, n } function N(n, t, e) { var r = t[0], i = t[1], o = t[2], a = t[3], u = Math.sin(e), s = Math.cos(e); return n[0] = r * s + o * u, n[1] = i * s + a * u, n[2] = r * -u + o * s, n[3] = i * -u + a * s, n } function A(n, t, e) { var r = t[0], i = t[1], o = t[2], a = t[3], u = e[0], s = e[1]; return n[0] = r * u, n[1] = i * u, n[2] = o * s, n[3] = a * s, n } function D(n, t) { var e = Math.sin(t), r = Math.cos(t); return n[0] = r, n[1] = e, n[2] = -e, n[3] = r, n } function C(n, t) { return n[0] = t[0], n[1] = 0, n[2] = 0, n[3] = t[1], n } function O(n) { return "mat2(" + n[0] + ", " + n[1] + ", " + n[2] + ", " + n[3] + ")" } function V(n) { return Math.hypot(n[0], n[1], n[2], n[3]) } function B(n, t, e, r) { return n[2] = r[2] / r[0], e[0] = r[0], e[1] = r[1], e[3] = r[3] - n[2] * e[1], [n, t, e] } function I(n, t, e) { return n[0] = t[0] + e[0], n[1] = t[1] + e[1], n[2] = t[2] + e[2], n[3] = t[3] + e[3], n } function z(n, t, e) { return n[0] = t[0] - e[0], n[1] = t[1] - e[1], n[2] = t[2] - e[2], n[3] = t[3] - e[3], n } function k(n, t) { return n[0] === t[0] && n[1] === t[1] && n[2] === t[2] && n[3] === t[3] } function G(n, t) { var e = n[0], r = n[1], i = n[2], o = n[3], a = t[0], u = t[1], s = t[2], c = t[3]; return Math.abs(e - a) <= d * Math.max(1, Math.abs(e), Math.abs(a)) && Math.abs(r - u) <= d * Math.max(1, Math.abs(r), Math.abs(u)) && Math.abs(i - s) <= d * Math.max(1, Math.abs(i), Math.abs(s)) && Math.abs(o - c) <= d * Math.max(1, Math.abs(o), Math.abs(c)) } function U(n, t, e) { return n[0] = t[0] * e, n[1] = t[1] * e, n[2] = t[2] * e, n[3] = t[3] * e, n } function q(n, t, e, r) { return n[0] = t[0] + e[0] * r, n[1] = t[1] + e[1] * r, n[2] = t[2] + e[2] * r, n[3] = t[3] + e[3] * r, n } Math.hypot || (Math.hypot = function () { for (var n = 0, t = arguments.length; t--;)n += arguments[t] * arguments[t]; return Math.sqrt(n) }); var H = F, j = z; function X() { var n = new m(6); return m != Float32Array && (n[1] = 0, n[2] = 0, n[4] = 0, n[5] = 0), n[0] = 1, n[3] = 1, n } function W(n) { var t = new m(6); return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t } function K(n, t) { return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[4] = t[4], n[5] = t[5], n } function Q(n) { return n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 1, n[4] = 0, n[5] = 0, n } function Y(n, t, e, r, i, o) { var a = new m(6); return a[0] = n, a[1] = t, a[2] = e, a[3] = r, a[4] = i, a[5] = o, a } function Z(n, t, e, r, i, o, a) { return n[0] = t, n[1] = e, n[2] = r, n[3] = i, n[4] = o, n[5] = a, n } function J(n, t) { var e = t[0], r = t[1], i = t[2], o = t[3], a = t[4], u = t[5], s = e * o - r * i; return s ? (s = 1 / s, n[0] = o * s, n[1] = -r * s, n[2] = -i * s, n[3] = e * s, n[4] = (i * u - o * a) * s, n[5] = (r * a - e * u) * s, n) : null } function $(n) { return n[0] * n[3] - n[1] * n[2] } function nn(n, t, e) { var r = t[0], i = t[1], o = t[2], a = t[3], u = t[4], s = t[5], c = e[0], l = e[1], f = e[2], h = e[3], d = e[4], m = e[5]; return n[0] = r * c + o * l, n[1] = i * c + a * l, n[2] = r * f + o * h, n[3] = i * f + a * h, n[4] = r * d + o * m + u, n[5] = i * d + a * m + s, n } function tn(n, t, e) { var r = t[0], i = t[1], o = t[2], a = t[3], u = t[4], s = t[5], c = Math.sin(e), l = Math.cos(e); return n[0] = r * l + o * c, n[1] = i * l + a * c, n[2] = r * -c + o * l, n[3] = i * -c + a * l, n[4] = u, n[5] = s, n } function en(n, t, e) { var r = t[0], i = t[1], o = t[2], a = t[3], u = t[4], s = t[5], c = e[0], l = e[1]; return n[0] = r * c, n[1] = i * c, n[2] = o * l, n[3] = a * l, n[4] = u, n[5] = s, n } function rn(n, t, e) { var r = t[0], i = t[1], o = t[2], a = t[3], u = t[4], s = t[5], c = e[0], l = e[1]; return n[0] = r, n[1] = i, n[2] = o, n[3] = a, n[4] = r * c + o * l + u, n[5] = i * c + a * l + s, n } function on(n, t) { var e = Math.sin(t), r = Math.cos(t); return n[0] = r, n[1] = e, n[2] = -e, n[3] = r, n[4] = 0, n[5] = 0, n } function an(n, t) { return n[0] = t[0], n[1] = 0, n[2] = 0, n[3] = t[1], n[4] = 0, n[5] = 0, n } function un(n, t) { return n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 1, n[4] = t[0], n[5] = t[1], n } function sn(n) { return "mat2d(" + n[0] + ", " + n[1] + ", " + n[2] + ", " + n[3] + ", " + n[4] + ", " + n[5] + ")" } function cn(n) { return Math.hypot(n[0], n[1], n[2], n[3], n[4], n[5], 1) } function ln(n, t, e) { return n[0] = t[0] + e[0], n[1] = t[1] + e[1], n[2] = t[2] + e[2], n[3] = t[3] + e[3], n[4] = t[4] + e[4], n[5] = t[5] + e[5], n } function fn(n, t, e) { return n[0] = t[0] - e[0], n[1] = t[1] - e[1], n[2] = t[2] - e[2], n[3] = t[3] - e[3], n[4] = t[4] - e[4], n[5] = t[5] - e[5], n } function hn(n, t, e) { return n[0] = t[0] * e, n[1] = t[1] * e, n[2] = t[2] * e, n[3] = t[3] * e, n[4] = t[4] * e, n[5] = t[5] * e, n } function dn(n, t, e, r) { return n[0] = t[0] + e[0] * r, n[1] = t[1] + e[1] * r, n[2] = t[2] + e[2] * r, n[3] = t[3] + e[3] * r, n[4] = t[4] + e[4] * r, n[5] = t[5] + e[5] * r, n } function mn(n, t) { return n[0] === t[0] && n[1] === t[1] && n[2] === t[2] && n[3] === t[3] && n[4] === t[4] && n[5] === t[5] } function pn(n, t) { var e = n[0], r = n[1], i = n[2], o = n[3], a = n[4], u = n[5], s = t[0], c = t[1], l = t[2], f = t[3], h = t[4], m = t[5]; return Math.abs(e - s) <= d * Math.max(1, Math.abs(e), Math.abs(s)) && Math.abs(r - c) <= d * Math.max(1, Math.abs(r), Math.abs(c)) && Math.abs(i - l) <= d * Math.max(1, Math.abs(i), Math.abs(l)) && Math.abs(o - f) <= d * Math.max(1, Math.abs(o), Math.abs(f)) && Math.abs(a - h) <= d * Math.max(1, Math.abs(a), Math.abs(h)) && Math.abs(u - m) <= d * Math.max(1, Math.abs(u), Math.abs(m)) } var vn = nn, _n = fn; function gn() { var n = new m(9); return m != Float32Array && (n[1] = 0, n[2] = 0, n[3] = 0, n[5] = 0, n[6] = 0, n[7] = 0), n[0] = 1, n[4] = 1, n[8] = 1, n } function bn(n, t) { return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[4], n[4] = t[5], n[5] = t[6], n[6] = t[8], n[7] = t[9], n[8] = t[10], n } function Mn(n) { var t = new m(9); return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t } function xn(n, t) { return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[4] = t[4], n[5] = t[5], n[6] = t[6], n[7] = t[7], n[8] = t[8], n } function Sn(n, t, e, r, i, o, a, u, s) { var c = new m(9); return c[0] = n, c[1] = t, c[2] = e, c[3] = r, c[4] = i, c[5] = o, c[6] = a, c[7] = u, c[8] = s, c } function wn(n, t, e, r, i, o, a, u, s, c) { return n[0] = t, n[1] = e, n[2] = r, n[3] = i, n[4] = o, n[5] = a, n[6] = u, n[7] = s, n[8] = c, n } function yn(n) { return n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 1, n[5] = 0, n[6] = 0, n[7] = 0, n[8] = 1, n } function Pn(n, t) { if (n === t) { var e = t[1], r = t[2], i = t[5]; n[1] = t[3], n[2] = t[6], n[3] = e, n[5] = t[7], n[6] = r, n[7] = i } else n[0] = t[0], n[1] = t[3], n[2] = t[6], n[3] = t[1], n[4] = t[4], n[5] = t[7], n[6] = t[2], n[7] = t[5], n[8] = t[8]; return n } function Ln(n, t) { var e = t[0], r = t[1], i = t[2], o = t[3], a = t[4], u = t[5], s = t[6], c = t[7], l = t[8], f = l * a - u * c, h = -l * o + u * s, d = c * o - a * s, m = e * f + r * h + i * d; return m ? (m = 1 / m, n[0] = f * m, n[1] = (-l * r + i * c) * m, n[2] = (u * r - i * a) * m, n[3] = h * m, n[4] = (l * e - i * s) * m, n[5] = (-u * e + i * o) * m, n[6] = d * m, n[7] = (-c * e + r * s) * m, n[8] = (a * e - r * o) * m, n) : null } function Tn(n, t) { var e = t[0], r = t[1], i = t[2], o = t[3], a = t[4], u = t[5], s = t[6], c = t[7], l = t[8]; return n[0] = a * l - u * c, n[1] = i * c - r * l, n[2] = r * u - i * a, n[3] = u * s - o * l, n[4] = e * l - i * s, n[5] = i * o - e * u, n[6] = o * c - a * s, n[7] = r * s - e * c, n[8] = e * a - r * o, n } function Rn(n) { var t = n[0], e = n[1], r = n[2], i = n[3], o = n[4], a = n[5], u = n[6], s = n[7], c = n[8]; return t * (c * o - a * s) + e * (-c * i + a * u) + r * (s * i - o * u) } function En(n, t, e) { var r = t[0], i = t[1], o = t[2], a = t[3], u = t[4], s = t[5], c = t[6], l = t[7], f = t[8], h = e[0], d = e[1], m = e[2], p = e[3], v = e[4], _ = e[5], g = e[6], b = e[7], M = e[8]; return n[0] = h * r + d * a + m * c, n[1] = h * i + d * u + m * l, n[2] = h * o + d * s + m * f, n[3] = p * r + v * a + _ * c, n[4] = p * i + v * u + _ * l, n[5] = p * o + v * s + _ * f, n[6] = g * r + b * a + M * c, n[7] = g * i + b * u + M * l, n[8] = g * o + b * s + M * f, n } function Fn(n, t, e) { var r = t[0], i = t[1], o = t[2], a = t[3], u = t[4], s = t[5], c = t[6], l = t[7], f = t[8], h = e[0], d = e[1]; return n[0] = r, n[1] = i, n[2] = o, n[3] = a, n[4] = u, n[5] = s, n[6] = h * r + d * a + c, n[7] = h * i + d * u + l, n[8] = h * o + d * s + f, n } function Nn(n, t, e) { var r = t[0], i = t[1], o = t[2], a = t[3], u = t[4], s = t[5], c = t[6], l = t[7], f = t[8], h = Math.sin(e), d = Math.cos(e); return n[0] = d * r + h * a, n[1] = d * i + h * u, n[2] = d * o + h * s, n[3] = d * a - h * r, n[4] = d * u - h * i, n[5] = d * s - h * o, n[6] = c, n[7] = l, n[8] = f, n } function An(n, t, e) { var r = e[0], i = e[1]; return n[0] = r * t[0], n[1] = r * t[1], n[2] = r * t[2], n[3] = i * t[3], n[4] = i * t[4], n[5] = i * t[5], n[6] = t[6], n[7] = t[7], n[8] = t[8], n } function Dn(n, t) { return n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 1, n[5] = 0, n[6] = t[0], n[7] = t[1], n[8] = 1, n } function Cn(n, t) { var e = Math.sin(t), r = Math.cos(t); return n[0] = r, n[1] = e, n[2] = 0, n[3] = -e, n[4] = r, n[5] = 0, n[6] = 0, n[7] = 0, n[8] = 1, n } function On(n, t) { return n[0] = t[0], n[1] = 0, n[2] = 0, n[3] = 0, n[4] = t[1], n[5] = 0, n[6] = 0, n[7] = 0, n[8] = 1, n } function Vn(n, t) { return n[0] = t[0], n[1] = t[1], n[2] = 0, n[3] = t[2], n[4] = t[3], n[5] = 0, n[6] = t[4], n[7] = t[5], n[8] = 1, n } function Bn(n, t) { var e = t[0], r = t[1], i = t[2], o = t[3], a = e + e, u = r + r, s = i + i, c = e * a, l = r * a, f = r * u, h = i * a, d = i * u, m = i * s, p = o * a, v = o * u, _ = o * s; return n[0] = 1 - f - m, n[3] = l - _, n[6] = h + v, n[1] = l + _, n[4] = 1 - c - m, n[7] = d - p, n[2] = h - v, n[5] = d + p, n[8] = 1 - c - f, n } function In(n, t) { var e = t[0], r = t[1], i = t[2], o = t[3], a = t[4], u = t[5], s = t[6], c = t[7], l = t[8], f = t[9], h = t[10], d = t[11], m = t[12], p = t[13], v = t[14], _ = t[15], g = e * u - r * a, b = e * s - i * a, M = e * c - o * a, x = r * s - i * u, S = r * c - o * u, w = i * c - o * s, y = l * p - f * m, P = l * v - h * m, L = l * _ - d * m, T = f * v - h * p, R = f * _ - d * p, E = h * _ - d * v, F = g * E - b * R + M * T + x * L - S * P + w * y; return F ? (F = 1 / F, n[0] = (u * E - s * R + c * T) * F, n[1] = (s * L - a * E - c * P) * F, n[2] = (a * R - u * L + c * y) * F, n[3] = (i * R - r * E - o * T) * F, n[4] = (e * E - i * L + o * P) * F, n[5] = (r * L - e * R - o * y) * F, n[6] = (p * w - v * S + _ * x) * F, n[7] = (v * M - m * w - _ * b) * F, n[8] = (m * S - p * M + _ * g) * F, n) : null } function zn(n, t, e) { return n[0] = 2 / t, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = -2 / e, n[5] = 0, n[6] = -1, n[7] = 1, n[8] = 1, n } function kn(n) { return "mat3(" + n[0] + ", " + n[1] + ", " + n[2] + ", " + n[3] + ", " + n[4] + ", " + n[5] + ", " + n[6] + ", " + n[7] + ", " + n[8] + ")" } function Gn(n) { return Math.hypot(n[0], n[1], n[2], n[3], n[4], n[5], n[6], n[7], n[8]) } function Un(n, t, e) { return n[0] = t[0] + e[0], n[1] = t[1] + e[1], n[2] = t[2] + e[2], n[3] = t[3] + e[3], n[4] = t[4] + e[4], n[5] = t[5] + e[5], n[6] = t[6] + e[6], n[7] = t[7] + e[7], n[8] = t[8] + e[8], n } function qn(n, t, e) { return n[0] = t[0] - e[0], n[1] = t[1] - e[1], n[2] = t[2] - e[2], n[3] = t[3] - e[3], n[4] = t[4] - e[4], n[5] = t[5] - e[5], n[6] = t[6] - e[6], n[7] = t[7] - e[7], n[8] = t[8] - e[8], n } function Hn(n, t, e) { return n[0] = t[0] * e, n[1] = t[1] * e, n[2] = t[2] * e, n[3] = t[3] * e, n[4] = t[4] * e, n[5] = t[5] * e, n[6] = t[6] * e, n[7] = t[7] * e, n[8] = t[8] * e, n } function jn(n, t, e, r) { return n[0] = t[0] + e[0] * r, n[1] = t[1] + e[1] * r, n[2] = t[2] + e[2] * r, n[3] = t[3] + e[3] * r, n[4] = t[4] + e[4] * r, n[5] = t[5] + e[5] * r, n[6] = t[6] + e[6] * r, n[7] = t[7] + e[7] * r, n[8] = t[8] + e[8] * r, n } function Xn(n, t) { return n[0] === t[0] && n[1] === t[1] && n[2] === t[2] && n[3] === t[3] && n[4] === t[4] && n[5] === t[5] && n[6] === t[6] && n[7] === t[7] && n[8] === t[8] } function Wn(n, t) { var e = n[0], r = n[1], i = n[2], o = n[3], a = n[4], u = n[5], s = n[6], c = n[7], l = n[8], f = t[0], h = t[1], m = t[2], p = t[3], v = t[4], _ = t[5], g = t[6], b = t[7], M = t[8]; return Math.abs(e - f) <= d * Math.max(1, Math.abs(e), Math.abs(f)) && Math.abs(r - h) <= d * Math.max(1, Math.abs(r), Math.abs(h)) && Math.abs(i - m) <= d * Math.max(1, Math.abs(i), Math.abs(m)) && Math.abs(o - p) <= d * Math.max(1, Math.abs(o), Math.abs(p)) && Math.abs(a - v) <= d * Math.max(1, Math.abs(a), Math.abs(v)) && Math.abs(u - _) <= d * Math.max(1, Math.abs(u), Math.abs(_)) && Math.abs(s - g) <= d * Math.max(1, Math.abs(s), Math.abs(g)) && Math.abs(c - b) <= d * Math.max(1, Math.abs(c), Math.abs(b)) && Math.abs(l - M) <= d * Math.max(1, Math.abs(l), Math.abs(M)) } var Kn = En, Qn = qn; function Yn() { var n = new m(16); return m != Float32Array && (n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0), n[0] = 1, n[5] = 1, n[10] = 1, n[15] = 1, n } function Zn(n) { var t = new m(16); return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], t } function Jn(n, t) { return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[4] = t[4], n[5] = t[5], n[6] = t[6], n[7] = t[7], n[8] = t[8], n[9] = t[9], n[10] = t[10], n[11] = t[11], n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15], n } function $n(n, t, e, r, i, o, a, u, s, c, l, f, h, d, p, v) { var _ = new m(16); return _[0] = n, _[1] = t, _[2] = e, _[3] = r, _[4] = i, _[5] = o, _[6] = a, _[7] = u, _[8] = s, _[9] = c, _[10] = l, _[11] = f, _[12] = h, _[13] = d, _[14] = p, _[15] = v, _ } function nt(n, t, e, r, i, o, a, u, s, c, l, f, h, d, m, p, v) { return n[0] = t, n[1] = e, n[2] = r, n[3] = i, n[4] = o, n[5] = a, n[6] = u, n[7] = s, n[8] = c, n[9] = l, n[10] = f, n[11] = h, n[12] = d, n[13] = m, n[14] = p, n[15] = v, n } function tt(n) { return n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = 1, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = 1, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, n } function et(n, t) { if (n === t) { var e = t[1], r = t[2], i = t[3], o = t[6], a = t[7], u = t[11]; n[1] = t[4], n[2] = t[8], n[3] = t[12], n[4] = e, n[6] = t[9], n[7] = t[13], n[8] = r, n[9] = o, n[11] = t[14], n[12] = i, n[13] = a, n[14] = u } else n[0] = t[0], n[1] = t[4], n[2] = t[8], n[3] = t[12], n[4] = t[1], n[5] = t[5], n[6] = t[9], n[7] = t[13], n[8] = t[2], n[9] = t[6], n[10] = t[10], n[11] = t[14], n[12] = t[3], n[13] = t[7], n[14] = t[11], n[15] = t[15]; return n } function rt(n, t) { var e = t[0], r = t[1], i = t[2], o = t[3], a = t[4], u = t[5], s = t[6], c = t[7], l = t[8], f = t[9], h = t[10], d = t[11], m = t[12], p = t[13], v = t[14], _ = t[15], g = e * u - r * a, b = e * s - i * a, M = e * c - o * a, x = r * s - i * u, S = r * c - o * u, w = i * c - o * s, y = l * p - f * m, P = l * v - h * m, L = l * _ - d * m, T = f * v - h * p, R = f * _ - d * p, E = h * _ - d * v, F = g * E - b * R + M * T + x * L - S * P + w * y; return F ? (F = 1 / F, n[0] = (u * E - s * R + c * T) * F, n[1] = (i * R - r * E - o * T) * F, n[2] = (p * w - v * S + _ * x) * F, n[3] = (h * S - f * w - d * x) * F, n[4] = (s * L - a * E - c * P) * F, n[5] = (e * E - i * L + o * P) * F, n[6] = (v * M - m * w - _ * b) * F, n[7] = (l * w - h * M + d * b) * F, n[8] = (a * R - u * L + c * y) * F, n[9] = (r * L - e * R - o * y) * F, n[10] = (m * S - p * M + _ * g) * F, n[11] = (f * M - l * S - d * g) * F, n[12] = (u * P - a * T - s * y) * F, n[13] = (e * T - r * P + i * y) * F, n[14] = (p * b - m * x - v * g) * F, n[15] = (l * x - f * b + h * g) * F, n) : null } function it(n, t) { var e = t[0], r = t[1], i = t[2], o = t[3], a = t[4], u = t[5], s = t[6], c = t[7], l = t[8], f = t[9], h = t[10], d = t[11], m = t[12], p = t[13], v = t[14], _ = t[15]; return n[0] = u * (h * _ - d * v) - f * (s * _ - c * v) + p * (s * d - c * h), n[1] = -(r * (h * _ - d * v) - f * (i * _ - o * v) + p * (i * d - o * h)), n[2] = r * (s * _ - c * v) - u * (i * _ - o * v) + p * (i * c - o * s), n[3] = -(r * (s * d - c * h) - u * (i * d - o * h) + f * (i * c - o * s)), n[4] = -(a * (h * _ - d * v) - l * (s * _ - c * v) + m * (s * d - c * h)), n[5] = e * (h * _ - d * v) - l * (i * _ - o * v) + m * (i * d - o * h), n[6] = -(e * (s * _ - c * v) - a * (i * _ - o * v) + m * (i * c - o * s)), n[7] = e * (s * d - c * h) - a * (i * d - o * h) + l * (i * c - o * s), n[8] = a * (f * _ - d * p) - l * (u * _ - c * p) + m * (u * d - c * f), n[9] = -(e * (f * _ - d * p) - l * (r * _ - o * p) + m * (r * d - o * f)), n[10] = e * (u * _ - c * p) - a * (r * _ - o * p) + m * (r * c - o * u), n[11] = -(e * (u * d - c * f) - a * (r * d - o * f) + l * (r * c - o * u)), n[12] = -(a * (f * v - h * p) - l * (u * v - s * p) + m * (u * h - s * f)), n[13] = e * (f * v - h * p) - l * (r * v - i * p) + m * (r * h - i * f), n[14] = -(e * (u * v - s * p) - a * (r * v - i * p) + m * (r * s - i * u)), n[15] = e * (u * h - s * f) - a * (r * h - i * f) + l * (r * s - i * u), n } function ot(n) { var t = n[0], e = n[1], r = n[2], i = n[3], o = n[4], a = n[5], u = n[6], s = n[7], c = n[8], l = n[9], f = n[10], h = n[11], d = n[12], m = n[13], p = n[14], v = n[15]; return (t * a - e * o) * (f * v - h * p) - (t * u - r * o) * (l * v - h * m) + (t * s - i * o) * (l * p - f * m) + (e * u - r * a) * (c * v - h * d) - (e * s - i * a) * (c * p - f * d) + (r * s - i * u) * (c * m - l * d) } function at(n, t, e) { var r = t[0], i = t[1], o = t[2], a = t[3], u = t[4], s = t[5], c = t[6], l = t[7], f = t[8], h = t[9], d = t[10], m = t[11], p = t[12], v = t[13], _ = t[14], g = t[15], b = e[0], M = e[1], x = e[2], S = e[3]; return n[0] = b * r + M * u + x * f + S * p, n[1] = b * i + M * s + x * h + S * v, n[2] = b * o + M * c + x * d + S * _, n[3] = b * a + M * l + x * m + S * g, b = e[4], M = e[5], x = e[6], S = e[7], n[4] = b * r + M * u + x * f + S * p, n[5] = b * i + M * s + x * h + S * v, n[6] = b * o + M * c + x * d + S * _, n[7] = b * a + M * l + x * m + S * g, b = e[8], M = e[9], x = e[10], S = e[11], n[8] = b * r + M * u + x * f + S * p, n[9] = b * i + M * s + x * h + S * v, n[10] = b * o + M * c + x * d + S * _, n[11] = b * a + M * l + x * m + S * g, b = e[12], M = e[13], x = e[14], S = e[15], n[12] = b * r + M * u + x * f + S * p, n[13] = b * i + M * s + x * h + S * v, n[14] = b * o + M * c + x * d + S * _, n[15] = b * a + M * l + x * m + S * g, n } function ut(n, t, e) { var r, i, o, a, u, s, c, l, f, h, d, m, p = e[0], v = e[1], _ = e[2]; return t === n ? (n[12] = t[0] * p + t[4] * v + t[8] * _ + t[12], n[13] = t[1] * p + t[5] * v + t[9] * _ + t[13], n[14] = t[2] * p + t[6] * v + t[10] * _ + t[14], n[15] = t[3] * p + t[7] * v + t[11] * _ + t[15]) : (r = t[0], i = t[1], o = t[2], a = t[3], u = t[4], s = t[5], c = t[6], l = t[7], f = t[8], h = t[9], d = t[10], m = t[11], n[0] = r, n[1] = i, n[2] = o, n[3] = a, n[4] = u, n[5] = s, n[6] = c, n[7] = l, n[8] = f, n[9] = h, n[10] = d, n[11] = m, n[12] = r * p + u * v + f * _ + t[12], n[13] = i * p + s * v + h * _ + t[13], n[14] = o * p + c * v + d * _ + t[14], n[15] = a * p + l * v + m * _ + t[15]), n } function st(n, t, e) { var r = e[0], i = e[1], o = e[2]; return n[0] = t[0] * r, n[1] = t[1] * r, n[2] = t[2] * r, n[3] = t[3] * r, n[4] = t[4] * i, n[5] = t[5] * i, n[6] = t[6] * i, n[7] = t[7] * i, n[8] = t[8] * o, n[9] = t[9] * o, n[10] = t[10] * o, n[11] = t[11] * o, n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15], n } function ct(n, t, e, r) { var i, o, a, u, s, c, l, f, h, m, p, v, _, g, b, M, x, S, w, y, P, L, T, R, E = r[0], F = r[1], N = r[2], A = Math.hypot(E, F, N); return A < d ? null : (E *= A = 1 / A, F *= A, N *= A, i = Math.sin(e), a = 1 - (o = Math.cos(e)), u = t[0], s = t[1], c = t[2], l = t[3], f = t[4], h = t[5], m = t[6], p = t[7], v = t[8], _ = t[9], g = t[10], b = t[11], M = E * E * a + o, x = F * E * a + N * i, S = N * E * a - F * i, w = E * F * a - N * i, y = F * F * a + o, P = N * F * a + E * i, L = E * N * a + F * i, T = F * N * a - E * i, R = N * N * a + o, n[0] = u * M + f * x + v * S, n[1] = s * M + h * x + _ * S, n[2] = c * M + m * x + g * S, n[3] = l * M + p * x + b * S, n[4] = u * w + f * y + v * P, n[5] = s * w + h * y + _ * P, n[6] = c * w + m * y + g * P, n[7] = l * w + p * y + b * P, n[8] = u * L + f * T + v * R, n[9] = s * L + h * T + _ * R, n[10] = c * L + m * T + g * R, n[11] = l * L + p * T + b * R, t !== n && (n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15]), n) } function lt(n, t, e) { var r = Math.sin(e), i = Math.cos(e), o = t[4], a = t[5], u = t[6], s = t[7], c = t[8], l = t[9], f = t[10], h = t[11]; return t !== n && (n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15]), n[4] = o * i + c * r, n[5] = a * i + l * r, n[6] = u * i + f * r, n[7] = s * i + h * r, n[8] = c * i - o * r, n[9] = l * i - a * r, n[10] = f * i - u * r, n[11] = h * i - s * r, n } function ft(n, t, e) { var r = Math.sin(e), i = Math.cos(e), o = t[0], a = t[1], u = t[2], s = t[3], c = t[8], l = t[9], f = t[10], h = t[11]; return t !== n && (n[4] = t[4], n[5] = t[5], n[6] = t[6], n[7] = t[7], n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15]), n[0] = o * i - c * r, n[1] = a * i - l * r, n[2] = u * i - f * r, n[3] = s * i - h * r, n[8] = o * r + c * i, n[9] = a * r + l * i, n[10] = u * r + f * i, n[11] = s * r + h * i, n } function ht(n, t, e) { var r = Math.sin(e), i = Math.cos(e), o = t[0], a = t[1], u = t[2], s = t[3], c = t[4], l = t[5], f = t[6], h = t[7]; return t !== n && (n[8] = t[8], n[9] = t[9], n[10] = t[10], n[11] = t[11], n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15]), n[0] = o * i + c * r, n[1] = a * i + l * r, n[2] = u * i + f * r, n[3] = s * i + h * r, n[4] = c * i - o * r, n[5] = l * i - a * r, n[6] = f * i - u * r, n[7] = h * i - s * r, n } function dt(n, t) { return n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = 1, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = 1, n[11] = 0, n[12] = t[0], n[13] = t[1], n[14] = t[2], n[15] = 1, n } function mt(n, t) { return n[0] = t[0], n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = t[1], n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = t[2], n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, n } function pt(n, t, e) { var r, i, o, a = e[0], u = e[1], s = e[2], c = Math.hypot(a, u, s); return c < d ? null : (a *= c = 1 / c, u *= c, s *= c, r = Math.sin(t), o = 1 - (i = Math.cos(t)), n[0] = a * a * o + i, n[1] = u * a * o + s * r, n[2] = s * a * o - u * r, n[3] = 0, n[4] = a * u * o - s * r, n[5] = u * u * o + i, n[6] = s * u * o + a * r, n[7] = 0, n[8] = a * s * o + u * r, n[9] = u * s * o - a * r, n[10] = s * s * o + i, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, n) } function vt(n, t) { var e = Math.sin(t), r = Math.cos(t); return n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = r, n[6] = e, n[7] = 0, n[8] = 0, n[9] = -e, n[10] = r, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, n } function _t(n, t) { var e = Math.sin(t), r = Math.cos(t); return n[0] = r, n[1] = 0, n[2] = -e, n[3] = 0, n[4] = 0, n[5] = 1, n[6] = 0, n[7] = 0, n[8] = e, n[9] = 0, n[10] = r, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, n } function gt(n, t) { var e = Math.sin(t), r = Math.cos(t); return n[0] = r, n[1] = e, n[2] = 0, n[3] = 0, n[4] = -e, n[5] = r, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = 1, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, n } function bt(n, t, e) { var r = t[0], i = t[1], o = t[2], a = t[3], u = r + r, s = i + i, c = o + o, l = r * u, f = r * s, h = r * c, d = i * s, m = i * c, p = o * c, v = a * u, _ = a * s, g = a * c; return n[0] = 1 - (d + p), n[1] = f + g, n[2] = h - _, n[3] = 0, n[4] = f - g, n[5] = 1 - (l + p), n[6] = m + v, n[7] = 0, n[8] = h + _, n[9] = m - v, n[10] = 1 - (l + d), n[11] = 0, n[12] = e[0], n[13] = e[1], n[14] = e[2], n[15] = 1, n } function Mt(n, t) { var e = new m(3), r = -t[0], i = -t[1], o = -t[2], a = t[3], u = t[4], s = t[5], c = t[6], l = t[7], f = r * r + i * i + o * o + a * a; return f > 0 ? (e[0] = 2 * (u * a + l * r + s * o - c * i) / f, e[1] = 2 * (s * a + l * i + c * r - u * o) / f, e[2] = 2 * (c * a + l * o + u * i - s * r) / f) : (e[0] = 2 * (u * a + l * r + s * o - c * i), e[1] = 2 * (s * a + l * i + c * r - u * o), e[2] = 2 * (c * a + l * o + u * i - s * r)), bt(n, t, e), n } function xt(n, t) { return n[0] = t[12], n[1] = t[13], n[2] = t[14], n } function St(n, t) { var e = t[0], r = t[1], i = t[2], o = t[4], a = t[5], u = t[6], s = t[8], c = t[9], l = t[10]; return n[0] = Math.hypot(e, r, i), n[1] = Math.hypot(o, a, u), n[2] = Math.hypot(s, c, l), n } function wt(n, t) { var e = new m(3); St(e, t); var r = 1 / e[0], i = 1 / e[1], o = 1 / e[2], a = t[0] * r, u = t[1] * i, s = t[2] * o, c = t[4] * r, l = t[5] * i, f = t[6] * o, h = t[8] * r, d = t[9] * i, p = t[10] * o, v = a + l + p, _ = 0; return v > 0 ? (_ = 2 * Math.sqrt(v + 1), n[3] = .25 * _, n[0] = (f - d) / _, n[1] = (h - s) / _, n[2] = (u - c) / _) : a > l && a > p ? (_ = 2 * Math.sqrt(1 + a - l - p), n[3] = (f - d) / _, n[0] = .25 * _, n[1] = (u + c) / _, n[2] = (h + s) / _) : l > p ? (_ = 2 * Math.sqrt(1 + l - a - p), n[3] = (h - s) / _, n[0] = (u + c) / _, n[1] = .25 * _, n[2] = (f + d) / _) : (_ = 2 * Math.sqrt(1 + p - a - l), n[3] = (u - c) / _, n[0] = (h + s) / _, n[1] = (f + d) / _, n[2] = .25 * _), n } function yt(n, t, e, r) { var i = t[0], o = t[1], a = t[2], u = t[3], s = i + i, c = o + o, l = a + a, f = i * s, h = i * c, d = i * l, m = o * c, p = o * l, v = a * l, _ = u * s, g = u * c, b = u * l, M = r[0], x = r[1], S = r[2]; return n[0] = (1 - (m + v)) * M, n[1] = (h + b) * M, n[2] = (d - g) * M, n[3] = 0, n[4] = (h - b) * x, n[5] = (1 - (f + v)) * x, n[6] = (p + _) * x, n[7] = 0, n[8] = (d + g) * S, n[9] = (p - _) * S, n[10] = (1 - (f + m)) * S, n[11] = 0, n[12] = e[0], n[13] = e[1], n[14] = e[2], n[15] = 1, n } function Pt(n, t, e, r, i) { var o = t[0], a = t[1], u = t[2], s = t[3], c = o + o, l = a + a, f = u + u, h = o * c, d = o * l, m = o * f, p = a * l, v = a * f, _ = u * f, g = s * c, b = s * l, M = s * f, x = r[0], S = r[1], w = r[2], y = i[0], P = i[1], L = i[2], T = (1 - (p + _)) * x, R = (d + M) * x, E = (m - b) * x, F = (d - M) * S, N = (1 - (h + _)) * S, A = (v + g) * S, D = (m + b) * w, C = (v - g) * w, O = (1 - (h + p)) * w; return n[0] = T, n[1] = R, n[2] = E, n[3] = 0, n[4] = F, n[5] = N, n[6] = A, n[7] = 0, n[8] = D, n[9] = C, n[10] = O, n[11] = 0, n[12] = e[0] + y - (T * y + F * P + D * L), n[13] = e[1] + P - (R * y + N * P + C * L), n[14] = e[2] + L - (E * y + A * P + O * L), n[15] = 1, n } function Lt(n, t) { var e = t[0], r = t[1], i = t[2], o = t[3], a = e + e, u = r + r, s = i + i, c = e * a, l = r * a, f = r * u, h = i * a, d = i * u, m = i * s, p = o * a, v = o * u, _ = o * s; return n[0] = 1 - f - m, n[1] = l + _, n[2] = h - v, n[3] = 0, n[4] = l - _, n[5] = 1 - c - m, n[6] = d + p, n[7] = 0, n[8] = h + v, n[9] = d - p, n[10] = 1 - c - f, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, n } function Tt(n, t, e, r, i, o, a) { var u = 1 / (e - t), s = 1 / (i - r), c = 1 / (o - a); return n[0] = 2 * o * u, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = 2 * o * s, n[6] = 0, n[7] = 0, n[8] = (e + t) * u, n[9] = (i + r) * s, n[10] = (a + o) * c, n[11] = -1, n[12] = 0, n[13] = 0, n[14] = a * o * 2 * c, n[15] = 0, n } function Rt(n, t, e, r, i) { var o, a = 1 / Math.tan(t / 2); return n[0] = a / e, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = a, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[11] = -1, n[12] = 0, n[13] = 0, n[15] = 0, null != i && i !== 1 / 0 ? (o = 1 / (r - i), n[10] = (i + r) * o, n[14] = 2 * i * r * o) : (n[10] = -1, n[14] = -2 * r), n } function Et(n, t, e, r) { var i = Math.tan(t.upDegrees * Math.PI / 180), o = Math.tan(t.downDegrees * Math.PI / 180), a = Math.tan(t.leftDegrees * Math.PI / 180), u = Math.tan(t.rightDegrees * Math.PI / 180), s = 2 / (a + u), c = 2 / (i + o); return n[0] = s, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = c, n[6] = 0, n[7] = 0, n[8] = -(a - u) * s * .5, n[9] = (i - o) * c * .5, n[10] = r / (e - r), n[11] = -1, n[12] = 0, n[13] = 0, n[14] = r * e / (e - r), n[15] = 0, n } function Ft(n, t, e, r, i, o, a) { var u = 1 / (t - e), s = 1 / (r - i), c = 1 / (o - a); return n[0] = -2 * u, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = -2 * s, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = 2 * c, n[11] = 0, n[12] = (t + e) * u, n[13] = (i + r) * s, n[14] = (a + o) * c, n[15] = 1, n } function Nt(n, t, e, r) { var i, o, a, u, s, c, l, f, h, m, p = t[0], v = t[1], _ = t[2], g = r[0], b = r[1], M = r[2], x = e[0], S = e[1], w = e[2]; return Math.abs(p - x) < d && Math.abs(v - S) < d && Math.abs(_ - w) < d ? tt(n) : (l = p - x, f = v - S, h = _ - w, i = b * (h *= m = 1 / Math.hypot(l, f, h)) - M * (f *= m), o = M * (l *= m) - g * h, a = g * f - b * l, (m = Math.hypot(i, o, a)) ? (i *= m = 1 / m, o *= m, a *= m) : (i = 0, o = 0, a = 0), u = f * a - h * o, s = h * i - l * a, c = l * o - f * i, (m = Math.hypot(u, s, c)) ? (u *= m = 1 / m, s *= m, c *= m) : (u = 0, s = 0, c = 0), n[0] = i, n[1] = u, n[2] = l, n[3] = 0, n[4] = o, n[5] = s, n[6] = f, n[7] = 0, n[8] = a, n[9] = c, n[10] = h, n[11] = 0, n[12] = -(i * p + o * v + a * _), n[13] = -(u * p + s * v + c * _), n[14] = -(l * p + f * v + h * _), n[15] = 1, n) } function At(n, t, e, r) { var i = t[0], o = t[1], a = t[2], u = r[0], s = r[1], c = r[2], l = i - e[0], f = o - e[1], h = a - e[2], d = l * l + f * f + h * h; d > 0 && (l *= d = 1 / Math.sqrt(d), f *= d, h *= d); var m = s * h - c * f, p = c * l - u * h, v = u * f - s * l; return (d = m * m + p * p + v * v) > 0 && (m *= d = 1 / Math.sqrt(d), p *= d, v *= d), n[0] = m, n[1] = p, n[2] = v, n[3] = 0, n[4] = f * v - h * p, n[5] = h * m - l * v, n[6] = l * p - f * m, n[7] = 0, n[8] = l, n[9] = f, n[10] = h, n[11] = 0, n[12] = i, n[13] = o, n[14] = a, n[15] = 1, n } function Dt(n) { return "mat4(" + n[0] + ", " + n[1] + ", " + n[2] + ", " + n[3] + ", " + n[4] + ", " + n[5] + ", " + n[6] + ", " + n[7] + ", " + n[8] + ", " + n[9] + ", " + n[10] + ", " + n[11] + ", " + n[12] + ", " + n[13] + ", " + n[14] + ", " + n[15] + ")" } function Ct(n) { return Math.hypot(n[0], n[1], n[2], n[3], n[4], n[5], n[6], n[7], n[8], n[9], n[10], n[11], n[12], n[13], n[14], n[15]) } function Ot(n, t, e) { return n[0] = t[0] + e[0], n[1] = t[1] + e[1], n[2] = t[2] + e[2], n[3] = t[3] + e[3], n[4] = t[4] + e[4], n[5] = t[5] + e[5], n[6] = t[6] + e[6], n[7] = t[7] + e[7], n[8] = t[8] + e[8], n[9] = t[9] + e[9], n[10] = t[10] + e[10], n[11] = t[11] + e[11], n[12] = t[12] + e[12], n[13] = t[13] + e[13], n[14] = t[14] + e[14], n[15] = t[15] + e[15], n } function Vt(n, t, e) { return n[0] = t[0] - e[0], n[1] = t[1] - e[1], n[2] = t[2] - e[2], n[3] = t[3] - e[3], n[4] = t[4] - e[4], n[5] = t[5] - e[5], n[6] = t[6] - e[6], n[7] = t[7] - e[7], n[8] = t[8] - e[8], n[9] = t[9] - e[9], n[10] = t[10] - e[10], n[11] = t[11] - e[11], n[12] = t[12] - e[12], n[13] = t[13] - e[13], n[14] = t[14] - e[14], n[15] = t[15] - e[15], n } function Bt(n, t, e) { return n[0] = t[0] * e, n[1] = t[1] * e, n[2] = t[2] * e, n[3] = t[3] * e, n[4] = t[4] * e, n[5] = t[5] * e, n[6] = t[6] * e, n[7] = t[7] * e, n[8] = t[8] * e, n[9] = t[9] * e, n[10] = t[10] * e, n[11] = t[11] * e, n[12] = t[12] * e, n[13] = t[13] * e, n[14] = t[14] * e, n[15] = t[15] * e, n } function It(n, t, e, r) { return n[0] = t[0] + e[0] * r, n[1] = t[1] + e[1] * r, n[2] = t[2] + e[2] * r, n[3] = t[3] + e[3] * r, n[4] = t[4] + e[4] * r, n[5] = t[5] + e[5] * r, n[6] = t[6] + e[6] * r, n[7] = t[7] + e[7] * r, n[8] = t[8] + e[8] * r, n[9] = t[9] + e[9] * r, n[10] = t[10] + e[10] * r, n[11] = t[11] + e[11] * r, n[12] = t[12] + e[12] * r, n[13] = t[13] + e[13] * r, n[14] = t[14] + e[14] * r, n[15] = t[15] + e[15] * r, n } function zt(n, t) { return n[0] === t[0] && n[1] === t[1] && n[2] === t[2] && n[3] === t[3] && n[4] === t[4] && n[5] === t[5] && n[6] === t[6] && n[7] === t[7] && n[8] === t[8] && n[9] === t[9] && n[10] === t[10] && n[11] === t[11] && n[12] === t[12] && n[13] === t[13] && n[14] === t[14] && n[15] === t[15] } function kt(n, t) { var e = n[0], r = n[1], i = n[2], o = n[3], a = n[4], u = n[5], s = n[6], c = n[7], l = n[8], f = n[9], h = n[10], m = n[11], p = n[12], v = n[13], _ = n[14], g = n[15], b = t[0], M = t[1], x = t[2], S = t[3], w = t[4], y = t[5], P = t[6], L = t[7], T = t[8], R = t[9], E = t[10], F = t[11], N = t[12], A = t[13], D = t[14], C = t[15]; return Math.abs(e - b) <= d * Math.max(1, Math.abs(e), Math.abs(b)) && Math.abs(r - M) <= d * Math.max(1, Math.abs(r), Math.abs(M)) && Math.abs(i - x) <= d * Math.max(1, Math.abs(i), Math.abs(x)) && Math.abs(o - S) <= d * Math.max(1, Math.abs(o), Math.abs(S)) && Math.abs(a - w) <= d * Math.max(1, Math.abs(a), Math.abs(w)) && Math.abs(u - y) <= d * Math.max(1, Math.abs(u), Math.abs(y)) && Math.abs(s - P) <= d * Math.max(1, Math.abs(s), Math.abs(P)) && Math.abs(c - L) <= d * Math.max(1, Math.abs(c), Math.abs(L)) && Math.abs(l - T) <= d * Math.max(1, Math.abs(l), Math.abs(T)) && Math.abs(f - R) <= d * Math.max(1, Math.abs(f), Math.abs(R)) && Math.abs(h - E) <= d * Math.max(1, Math.abs(h), Math.abs(E)) && Math.abs(m - F) <= d * Math.max(1, Math.abs(m), Math.abs(F)) && Math.abs(p - N) <= d * Math.max(1, Math.abs(p), Math.abs(N)) && Math.abs(v - A) <= d * Math.max(1, Math.abs(v), Math.abs(A)) && Math.abs(_ - D) <= d * Math.max(1, Math.abs(_), Math.abs(D)) && Math.abs(g - C) <= d * Math.max(1, Math.abs(g), Math.abs(C)) } var Gt = at, Ut = Vt; function qt() { var n = new m(3); return m != Float32Array && (n[0] = 0, n[1] = 0, n[2] = 0), n } function Ht(n) { var t = new m(3); return t[0] = n[0], t[1] = n[1], t[2] = n[2], t } function jt(n) { var t = n[0], e = n[1], r = n[2]; return Math.hypot(t, e, r) } function Xt(n, t, e) { var r = new m(3); return r[0] = n, r[1] = t, r[2] = e, r } function Wt(n, t) { return n[0] = t[0], n[1] = t[1], n[2] = t[2], n } function Kt(n, t, e, r) { return n[0] = t, n[1] = e, n[2] = r, n } function Qt(n, t, e) { return n[0] = t[0] + e[0], n[1] = t[1] + e[1], n[2] = t[2] + e[2], n } function Yt(n, t, e) { return n[0] = t[0] - e[0], n[1] = t[1] - e[1], n[2] = t[2] - e[2], n } function Zt(n, t, e) { return n[0] = t[0] * e[0], n[1] = t[1] * e[1], n[2] = t[2] * e[2], n } function Jt(n, t, e) { return n[0] = t[0] / e[0], n[1] = t[1] / e[1], n[2] = t[2] / e[2], n } function $t(n, t) { return n[0] = Math.ceil(t[0]), n[1] = Math.ceil(t[1]), n[2] = Math.ceil(t[2]), n } function ne(n, t) { return n[0] = Math.floor(t[0]), n[1] = Math.floor(t[1]), n[2] = Math.floor(t[2]), n } function te(n, t, e) { return n[0] = Math.min(t[0], e[0]), n[1] = Math.min(t[1], e[1]), n[2] = Math.min(t[2], e[2]), n } function ee(n, t, e) { return n[0] = Math.max(t[0], e[0]), n[1] = Math.max(t[1], e[1]), n[2] = Math.max(t[2], e[2]), n } function re(n, t) { return n[0] = Math.round(t[0]), n[1] = Math.round(t[1]), n[2] = Math.round(t[2]), n } function ie(n, t, e) { return n[0] = t[0] * e, n[1] = t[1] * e, n[2] = t[2] * e, n } function oe(n, t, e, r) { return n[0] = t[0] + e[0] * r, n[1] = t[1] + e[1] * r, n[2] = t[2] + e[2] * r, n } function ae(n, t) { var e = t[0] - n[0], r = t[1] - n[1], i = t[2] - n[2]; return Math.hypot(e, r, i) } function ue(n, t) { var e = t[0] - n[0], r = t[1] - n[1], i = t[2] - n[2]; return e * e + r * r + i * i } function se(n) { var t = n[0], e = n[1], r = n[2]; return t * t + e * e + r * r } function ce(n, t) { return n[0] = -t[0], n[1] = -t[1], n[2] = -t[2], n } function le(n, t) { return n[0] = 1 / t[0], n[1] = 1 / t[1], n[2] = 1 / t[2], n } function fe(n, t) { var e = t[0], r = t[1], i = t[2], o = e * e + r * r + i * i; return o > 0 && (o = 1 / Math.sqrt(o)), n[0] = t[0] * o, n[1] = t[1] * o, n[2] = t[2] * o, n } function he(n, t) { return n[0] * t[0] + n[1] * t[1] + n[2] * t[2] } function de(n, t, e) { var r = t[0], i = t[1], o = t[2], a = e[0], u = e[1], s = e[2]; return n[0] = i * s - o * u, n[1] = o * a - r * s, n[2] = r * u - i * a, n } function me(n, t, e, r) { var i = t[0], o = t[1], a = t[2]; return n[0] = i + r * (e[0] - i), n[1] = o + r * (e[1] - o), n[2] = a + r * (e[2] - a), n } function pe(n, t, e, r, i, o) { var a = o * o, u = a * (2 * o - 3) + 1, s = a * (o - 2) + o, c = a * (o - 1), l = a * (3 - 2 * o); return n[0] = t[0] * u + e[0] * s + r[0] * c + i[0] * l, n[1] = t[1] * u + e[1] * s + r[1] * c + i[1] * l, n[2] = t[2] * u + e[2] * s + r[2] * c + i[2] * l, n } function ve(n, t, e, r, i, o) { var a = 1 - o, u = a * a, s = o * o, c = u * a, l = 3 * o * u, f = 3 * s * a, h = s * o; return n[0] = t[0] * c + e[0] * l + r[0] * f + i[0] * h, n[1] = t[1] * c + e[1] * l + r[1] * f + i[1] * h, n[2] = t[2] * c + e[2] * l + r[2] * f + i[2] * h, n } function _e(n, t) { t = t || 1; var e = 2 * p() * Math.PI, r = 2 * p() - 1, i = Math.sqrt(1 - r * r) * t; return n[0] = Math.cos(e) * i, n[1] = Math.sin(e) * i, n[2] = r * t, n } function ge(n, t, e) { var r = t[0], i = t[1], o = t[2], a = e[3] * r + e[7] * i + e[11] * o + e[15]; return a = a || 1, n[0] = (e[0] * r + e[4] * i + e[8] * o + e[12]) / a, n[1] = (e[1] * r + e[5] * i + e[9] * o + e[13]) / a, n[2] = (e[2] * r + e[6] * i + e[10] * o + e[14]) / a, n } function be(n, t, e) { var r = t[0], i = t[1], o = t[2]; return n[0] = r * e[0] + i * e[3] + o * e[6], n[1] = r * e[1] + i * e[4] + o * e[7], n[2] = r * e[2] + i * e[5] + o * e[8], n } function Me(n, t, e) { var r = e[0], i = e[1], o = e[2], a = e[3], u = t[0], s = t[1], c = t[2], l = i * c - o * s, f = o * u - r * c, h = r * s - i * u, d = i * h - o * f, m = o * l - r * h, p = r * f - i * l, v = 2 * a; return l *= v, f *= v, h *= v, d *= 2, m *= 2, p *= 2, n[0] = u + l + d, n[1] = s + f + m, n[2] = c + h + p, n } function xe(n, t, e, r) { var i = [], o = []; return i[0] = t[0] - e[0], i[1] = t[1] - e[1], i[2] = t[2] - e[2], o[0] = i[0], o[1] = i[1] * Math.cos(r) - i[2] * Math.sin(r), o[2] = i[1] * Math.sin(r) + i[2] * Math.cos(r), n[0] = o[0] + e[0], n[1] = o[1] + e[1], n[2] = o[2] + e[2], n } function Se(n, t, e, r) { var i = [], o = []; return i[0] = t[0] - e[0], i[1] = t[1] - e[1], i[2] = t[2] - e[2], o[0] = i[2] * Math.sin(r) + i[0] * Math.cos(r), o[1] = i[1], o[2] = i[2] * Math.cos(r) - i[0] * Math.sin(r), n[0] = o[0] + e[0], n[1] = o[1] + e[1], n[2] = o[2] + e[2], n } function we(n, t, e, r) { var i = [], o = []; return i[0] = t[0] - e[0], i[1] = t[1] - e[1], i[2] = t[2] - e[2], o[0] = i[0] * Math.cos(r) - i[1] * Math.sin(r), o[1] = i[0] * Math.sin(r) + i[1] * Math.cos(r), o[2] = i[2], n[0] = o[0] + e[0], n[1] = o[1] + e[1], n[2] = o[2] + e[2], n } function ye(n, t) { var e = n[0], r = n[1], i = n[2], o = t[0], a = t[1], u = t[2], s = Math.sqrt(e * e + r * r + i * i) * Math.sqrt(o * o + a * a + u * u), c = s && he(n, t) / s; return Math.acos(Math.min(Math.max(c, -1), 1)) } function Pe(n) { return n[0] = 0, n[1] = 0, n[2] = 0, n } function Le(n) { return "vec3(" + n[0] + ", " + n[1] + ", " + n[2] + ")" } function Te(n, t) { return n[0] === t[0] && n[1] === t[1] && n[2] === t[2] } function Re(n, t) { var e = n[0], r = n[1], i = n[2], o = t[0], a = t[1], u = t[2]; return Math.abs(e - o) <= d * Math.max(1, Math.abs(e), Math.abs(o)) && Math.abs(r - a) <= d * Math.max(1, Math.abs(r), Math.abs(a)) && Math.abs(i - u) <= d * Math.max(1, Math.abs(i), Math.abs(u)) } var Ee, Fe = Yt, Ne = Zt, Ae = Jt, De = ae, Ce = ue, Oe = jt, Ve = se, Be = (Ee = qt(), function (n, t, e, r, i, o) { var a, u; for (t || (t = 3), e || (e = 0), u = r ? Math.min(r * t + e, n.length) : n.length, a = e; a < u; a += t)Ee[0] = n[a], Ee[1] = n[a + 1], Ee[2] = n[a + 2], i(Ee, Ee, o), n[a] = Ee[0], n[a + 1] = Ee[1], n[a + 2] = Ee[2]; return n }); function Ie() { var n = new m(4); return m != Float32Array && (n[0] = 0, n[1] = 0, n[2] = 0, n[3] = 0), n } function ze(n) { var t = new m(4); return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t } function ke(n, t, e, r) { var i = new m(4); return i[0] = n, i[1] = t, i[2] = e, i[3] = r, i } function Ge(n, t) { return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n } function Ue(n, t, e, r, i) { return n[0] = t, n[1] = e, n[2] = r, n[3] = i, n } function qe(n, t, e) { return n[0] = t[0] + e[0], n[1] = t[1] + e[1], n[2] = t[2] + e[2], n[3] = t[3] + e[3], n } function He(n, t, e) { return n[0] = t[0] - e[0], n[1] = t[1] - e[1], n[2] = t[2] - e[2], n[3] = t[3] - e[3], n } function je(n, t, e) { return n[0] = t[0] * e[0], n[1] = t[1] * e[1], n[2] = t[2] * e[2], n[3] = t[3] * e[3], n } function Xe(n, t, e) { return n[0] = t[0] / e[0], n[1] = t[1] / e[1], n[2] = t[2] / e[2], n[3] = t[3] / e[3], n } function We(n, t) { return n[0] = Math.ceil(t[0]), n[1] = Math.ceil(t[1]), n[2] = Math.ceil(t[2]), n[3] = Math.ceil(t[3]), n } function Ke(n, t) { return n[0] = Math.floor(t[0]), n[1] = Math.floor(t[1]), n[2] = Math.floor(t[2]), n[3] = Math.floor(t[3]), n } function Qe(n, t, e) { return n[0] = Math.min(t[0], e[0]), n[1] = Math.min(t[1], e[1]), n[2] = Math.min(t[2], e[2]), n[3] = Math.min(t[3], e[3]), n } function Ye(n, t, e) { return n[0] = Math.max(t[0], e[0]), n[1] = Math.max(t[1], e[1]), n[2] = Math.max(t[2], e[2]), n[3] = Math.max(t[3], e[3]), n } function Ze(n, t) { return n[0] = Math.round(t[0]), n[1] = Math.round(t[1]), n[2] = Math.round(t[2]), n[3] = Math.round(t[3]), n } function Je(n, t, e) { return n[0] = t[0] * e, n[1] = t[1] * e, n[2] = t[2] * e, n[3] = t[3] * e, n } function $e(n, t, e, r) { return n[0] = t[0] + e[0] * r, n[1] = t[1] + e[1] * r, n[2] = t[2] + e[2] * r, n[3] = t[3] + e[3] * r, n } function nr(n, t) { var e = t[0] - n[0], r = t[1] - n[1], i = t[2] - n[2], o = t[3] - n[3]; return Math.hypot(e, r, i, o) } function tr(n, t) { var e = t[0] - n[0], r = t[1] - n[1], i = t[2] - n[2], o = t[3] - n[3]; return e * e + r * r + i * i + o * o } function er(n) { var t = n[0], e = n[1], r = n[2], i = n[3]; return Math.hypot(t, e, r, i) } function rr(n) { var t = n[0], e = n[1], r = n[2], i = n[3]; return t * t + e * e + r * r + i * i } function ir(n, t) { return n[0] = -t[0], n[1] = -t[1], n[2] = -t[2], n[3] = -t[3], n } function or(n, t) { return n[0] = 1 / t[0], n[1] = 1 / t[1], n[2] = 1 / t[2], n[3] = 1 / t[3], n } function ar(n, t) { var e = t[0], r = t[1], i = t[2], o = t[3], a = e * e + r * r + i * i + o * o; return a > 0 && (a = 1 / Math.sqrt(a)), n[0] = e * a, n[1] = r * a, n[2] = i * a, n[3] = o * a, n } function ur(n, t) { return n[0] * t[0] + n[1] * t[1] + n[2] * t[2] + n[3] * t[3] } function sr(n, t, e, r) { var i = e[0] * r[1] - e[1] * r[0], o = e[0] * r[2] - e[2] * r[0], a = e[0] * r[3] - e[3] * r[0], u = e[1] * r[2] - e[2] * r[1], s = e[1] * r[3] - e[3] * r[1], c = e[2] * r[3] - e[3] * r[2], l = t[0], f = t[1], h = t[2], d = t[3]; return n[0] = f * c - h * s + d * u, n[1] = -l * c + h * a - d * o, n[2] = l * s - f * a + d * i, n[3] = -l * u + f * o - h * i, n } function cr(n, t, e, r) { var i = t[0], o = t[1], a = t[2], u = t[3]; return n[0] = i + r * (e[0] - i), n[1] = o + r * (e[1] - o), n[2] = a + r * (e[2] - a), n[3] = u + r * (e[3] - u), n } function lr(n, t) { var e, r, i, o, a, u; t = t || 1; do { a = (e = 2 * p() - 1) * e + (r = 2 * p() - 1) * r } while (a >= 1); do { u = (i = 2 * p() - 1) * i + (o = 2 * p() - 1) * o } while (u >= 1); var s = Math.sqrt((1 - a) / u); return n[0] = t * e, n[1] = t * r, n[2] = t * i * s, n[3] = t * o * s, n } function fr(n, t, e) { var r = t[0], i = t[1], o = t[2], a = t[3]; return n[0] = e[0] * r + e[4] * i + e[8] * o + e[12] * a, n[1] = e[1] * r + e[5] * i + e[9] * o + e[13] * a, n[2] = e[2] * r + e[6] * i + e[10] * o + e[14] * a, n[3] = e[3] * r + e[7] * i + e[11] * o + e[15] * a, n } function hr(n, t, e) { var r = t[0], i = t[1], o = t[2], a = e[0], u = e[1], s = e[2], c = e[3], l = c * r + u * o - s * i, f = c * i + s * r - a * o, h = c * o + a * i - u * r, d = -a * r - u * i - s * o; return n[0] = l * c + d * -a + f * -s - h * -u, n[1] = f * c + d * -u + h * -a - l * -s, n[2] = h * c + d * -s + l * -u - f * -a, n[3] = t[3], n } function dr(n) { return n[0] = 0, n[1] = 0, n[2] = 0, n[3] = 0, n } function mr(n) { return "vec4(" + n[0] + ", " + n[1] + ", " + n[2] + ", " + n[3] + ")" } function pr(n, t) { return n[0] === t[0] && n[1] === t[1] && n[2] === t[2] && n[3] === t[3] } function vr(n, t) { var e = n[0], r = n[1], i = n[2], o = n[3], a = t[0], u = t[1], s = t[2], c = t[3]; return Math.abs(e - a) <= d * Math.max(1, Math.abs(e), Math.abs(a)) && Math.abs(r - u) <= d * Math.max(1, Math.abs(r), Math.abs(u)) && Math.abs(i - s) <= d * Math.max(1, Math.abs(i), Math.abs(s)) && Math.abs(o - c) <= d * Math.max(1, Math.abs(o), Math.abs(c)) } var _r = He, gr = je, br = Xe, Mr = nr, xr = tr, Sr = er, wr = rr, yr = function () { var n = Ie(); return function (t, e, r, i, o, a) { var u, s; for (e || (e = 4), r || (r = 0), s = i ? Math.min(i * e + r, t.length) : t.length, u = r; u < s; u += e)n[0] = t[u], n[1] = t[u + 1], n[2] = t[u + 2], n[3] = t[u + 3], o(n, n, a), t[u] = n[0], t[u + 1] = n[1], t[u + 2] = n[2], t[u + 3] = n[3]; return t } }(); function Pr() { var n = new m(4); return m != Float32Array && (n[0] = 0, n[1] = 0, n[2] = 0), n[3] = 1, n } function Lr(n) { return n[0] = 0, n[1] = 0, n[2] = 0, n[3] = 1, n } function Tr(n, t, e) { e *= .5; var r = Math.sin(e); return n[0] = r * t[0], n[1] = r * t[1], n[2] = r * t[2], n[3] = Math.cos(e), n } function Rr(n, t) { var e = 2 * Math.acos(t[3]), r = Math.sin(e / 2); return r > d ? (n[0] = t[0] / r, n[1] = t[1] / r, n[2] = t[2] / r) : (n[0] = 1, n[1] = 0, n[2] = 0), e } function Er(n, t) { var e = ii(n, t); return Math.acos(2 * e * e - 1) } function Fr(n, t, e) { var r = t[0], i = t[1], o = t[2], a = t[3], u = e[0], s = e[1], c = e[2], l = e[3]; return n[0] = r * l + a * u + i * c - o * s, n[1] = i * l + a * s + o * u - r * c, n[2] = o * l + a * c + r * s - i * u, n[3] = a * l - r * u - i * s - o * c, n } function Nr(n, t, e) { e *= .5; var r = t[0], i = t[1], o = t[2], a = t[3], u = Math.sin(e), s = Math.cos(e); return n[0] = r * s + a * u, n[1] = i * s + o * u, n[2] = o * s - i * u, n[3] = a * s - r * u, n } function Ar(n, t, e) { e *= .5; var r = t[0], i = t[1], o = t[2], a = t[3], u = Math.sin(e), s = Math.cos(e); return n[0] = r * s - o * u, n[1] = i * s + a * u, n[2] = o * s + r * u, n[3] = a * s - i * u, n } function Dr(n, t, e) { e *= .5; var r = t[0], i = t[1], o = t[2], a = t[3], u = Math.sin(e), s = Math.cos(e); return n[0] = r * s + i * u, n[1] = i * s - r * u, n[2] = o * s + a * u, n[3] = a * s - o * u, n } function Cr(n, t) { var e = t[0], r = t[1], i = t[2]; return n[0] = e, n[1] = r, n[2] = i, n[3] = Math.sqrt(Math.abs(1 - e * e - r * r - i * i)), n } function Or(n, t) { var e = t[0], r = t[1], i = t[2], o = t[3], a = Math.sqrt(e * e + r * r + i * i), u = Math.exp(o), s = a > 0 ? u * Math.sin(a) / a : 0; return n[0] = e * s, n[1] = r * s, n[2] = i * s, n[3] = u * Math.cos(a), n } function Vr(n, t) { var e = t[0], r = t[1], i = t[2], o = t[3], a = Math.sqrt(e * e + r * r + i * i), u = a > 0 ? Math.atan2(a, o) / a : 0; return n[0] = e * u, n[1] = r * u, n[2] = i * u, n[3] = .5 * Math.log(e * e + r * r + i * i + o * o), n } function Br(n, t, e) { return Vr(n, t), ri(n, n, e), Or(n, n), n } function Ir(n, t, e, r) { var i, o, a, u, s, c = t[0], l = t[1], f = t[2], h = t[3], m = e[0], p = e[1], v = e[2], _ = e[3]; return (o = c * m + l * p + f * v + h * _) < 0 && (o = -o, m = -m, p = -p, v = -v, _ = -_), 1 - o > d ? (i = Math.acos(o), a = Math.sin(i), u = Math.sin((1 - r) * i) / a, s = Math.sin(r * i) / a) : (u = 1 - r, s = r), n[0] = u * c + s * m, n[1] = u * l + s * p, n[2] = u * f + s * v, n[3] = u * h + s * _, n } function zr(n) { var t = p(), e = p(), r = p(), i = Math.sqrt(1 - t), o = Math.sqrt(t); return n[0] = i * Math.sin(2 * Math.PI * e), n[1] = i * Math.cos(2 * Math.PI * e), n[2] = o * Math.sin(2 * Math.PI * r), n[3] = o * Math.cos(2 * Math.PI * r), n } function kr(n, t) { var e = t[0], r = t[1], i = t[2], o = t[3], a = e * e + r * r + i * i + o * o, u = a ? 1 / a : 0; return n[0] = -e * u, n[1] = -r * u, n[2] = -i * u, n[3] = o * u, n } function Gr(n, t) { return n[0] = -t[0], n[1] = -t[1], n[2] = -t[2], n[3] = t[3], n } function Ur(n, t) { var e, r = t[0] + t[4] + t[8]; if (r > 0) e = Math.sqrt(r + 1), n[3] = .5 * e, e = .5 / e, n[0] = (t[5] - t[7]) * e, n[1] = (t[6] - t[2]) * e, n[2] = (t[1] - t[3]) * e; else { var i = 0; t[4] > t[0] && (i = 1), t[8] > t[3 * i + i] && (i = 2); var o = (i + 1) % 3, a = (i + 2) % 3; e = Math.sqrt(t[3 * i + i] - t[3 * o + o] - t[3 * a + a] + 1), n[i] = .5 * e, e = .5 / e, n[3] = (t[3 * o + a] - t[3 * a + o]) * e, n[o] = (t[3 * o + i] + t[3 * i + o]) * e, n[a] = (t[3 * a + i] + t[3 * i + a]) * e } return n } function qr(n, t, e, r) { var i = .5 * Math.PI / 180; t *= i, e *= i, r *= i; var o = Math.sin(t), a = Math.cos(t), u = Math.sin(e), s = Math.cos(e), c = Math.sin(r), l = Math.cos(r); return n[0] = o * s * l - a * u * c, n[1] = a * u * l + o * s * c, n[2] = a * s * c - o * u * l, n[3] = a * s * l + o * u * c, n } function Hr(n) { return "quat(" + n[0] + ", " + n[1] + ", " + n[2] + ", " + n[3] + ")" } var jr, Xr, Wr, Kr, Qr, Yr, Zr = ze, Jr = ke, $r = Ge, ni = Ue, ti = qe, ei = Fr, ri = Je, ii = ur, oi = cr, ai = er, ui = ai, si = rr, ci = si, li = ar, fi = pr, hi = vr, di = (jr = qt(), Xr = Xt(1, 0, 0), Wr = Xt(0, 1, 0), function (n, t, e) { var r = he(t, e); return r < -.999999 ? (de(jr, Xr, t), Oe(jr) < 1e-6 && de(jr, Wr, t), fe(jr, jr), Tr(n, jr, Math.PI), n) : r > .999999 ? (n[0] = 0, n[1] = 0, n[2] = 0, n[3] = 1, n) : (de(jr, t, e), n[0] = jr[0], n[1] = jr[1], n[2] = jr[2], n[3] = 1 + r, li(n, n)) }), mi = (Kr = Pr(), Qr = Pr(), function (n, t, e, r, i, o) { return Ir(Kr, t, i, o), Ir(Qr, e, r, o), Ir(n, Kr, Qr, 2 * o * (1 - o)), n }), pi = (Yr = gn(), function (n, t, e, r) { return Yr[0] = e[0], Yr[3] = e[1], Yr[6] = e[2], Yr[1] = r[0], Yr[4] = r[1], Yr[7] = r[2], Yr[2] = -t[0], Yr[5] = -t[1], Yr[8] = -t[2], li(n, Ur(n, Yr)) }); function vi() { var n = new m(8); return m != Float32Array && (n[0] = 0, n[1] = 0, n[2] = 0, n[4] = 0, n[5] = 0, n[6] = 0, n[7] = 0), n[3] = 1, n } function _i(n) { var t = new m(8); return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t } function gi(n, t, e, r, i, o, a, u) { var s = new m(8); return s[0] = n, s[1] = t, s[2] = e, s[3] = r, s[4] = i, s[5] = o, s[6] = a, s[7] = u, s } function bi(n, t, e, r, i, o, a) { var u = new m(8); u[0] = n, u[1] = t, u[2] = e, u[3] = r; var s = .5 * i, c = .5 * o, l = .5 * a; return u[4] = s * r + c * e - l * t, u[5] = c * r + l * n - s * e, u[6] = l * r + s * t - c * n, u[7] = -s * n - c * t - l * e, u } function Mi(n, t, e) { var r = .5 * e[0], i = .5 * e[1], o = .5 * e[2], a = t[0], u = t[1], s = t[2], c = t[3]; return n[0] = a, n[1] = u, n[2] = s, n[3] = c, n[4] = r * c + i * s - o * u, n[5] = i * c + o * a - r * s, n[6] = o * c + r * u - i * a, n[7] = -r * a - i * u - o * s, n } function xi(n, t) { return n[0] = 0, n[1] = 0, n[2] = 0, n[3] = 1, n[4] = .5 * t[0], n[5] = .5 * t[1], n[6] = .5 * t[2], n[7] = 0, n } function Si(n, t) { return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[4] = 0, n[5] = 0, n[6] = 0, n[7] = 0, n } function wi(n, t) { var e = Pr(); wt(e, t); var r = new m(3); return xt(r, t), Mi(n, e, r), n } function yi(n, t) { return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[4] = t[4], n[5] = t[5], n[6] = t[6], n[7] = t[7], n } function Pi(n) { return n[0] = 0, n[1] = 0, n[2] = 0, n[3] = 1, n[4] = 0, n[5] = 0, n[6] = 0, n[7] = 0, n } function Li(n, t, e, r, i, o, a, u, s) { return n[0] = t, n[1] = e, n[2] = r, n[3] = i, n[4] = o, n[5] = a, n[6] = u, n[7] = s, n } var Ti = $r; function Ri(n, t) { return n[0] = t[4], n[1] = t[5], n[2] = t[6], n[3] = t[7], n } var Ei = $r; function Fi(n, t) { return n[4] = t[0], n[5] = t[1], n[6] = t[2], n[7] = t[3], n } function Ni(n, t) { var e = t[4], r = t[5], i = t[6], o = t[7], a = -t[0], u = -t[1], s = -t[2], c = t[3]; return n[0] = 2 * (e * c + o * a + r * s - i * u), n[1] = 2 * (r * c + o * u + i * a - e * s), n[2] = 2 * (i * c + o * s + e * u - r * a), n } function Ai(n, t, e) { var r = t[0], i = t[1], o = t[2], a = t[3], u = .5 * e[0], s = .5 * e[1], c = .5 * e[2], l = t[4], f = t[5], h = t[6], d = t[7]; return n[0] = r, n[1] = i, n[2] = o, n[3] = a, n[4] = a * u + i * c - o * s + l, n[5] = a * s + o * u - r * c + f, n[6] = a * c + r * s - i * u + h, n[7] = -r * u - i * s - o * c + d, n } function Di(n, t, e) { var r = -t[0], i = -t[1], o = -t[2], a = t[3], u = t[4], s = t[5], c = t[6], l = t[7], f = u * a + l * r + s * o - c * i, h = s * a + l * i + c * r - u * o, d = c * a + l * o + u * i - s * r, m = l * a - u * r - s * i - c * o; return Nr(n, t, e), r = n[0], i = n[1], o = n[2], a = n[3], n[4] = f * a + m * r + h * o - d * i, n[5] = h * a + m * i + d * r - f * o, n[6] = d * a + m * o + f * i - h * r, n[7] = m * a - f * r - h * i - d * o, n } function Ci(n, t, e) { var r = -t[0], i = -t[1], o = -t[2], a = t[3], u = t[4], s = t[5], c = t[6], l = t[7], f = u * a + l * r + s * o - c * i, h = s * a + l * i + c * r - u * o, d = c * a + l * o + u * i - s * r, m = l * a - u * r - s * i - c * o; return Ar(n, t, e), r = n[0], i = n[1], o = n[2], a = n[3], n[4] = f * a + m * r + h * o - d * i, n[5] = h * a + m * i + d * r - f * o, n[6] = d * a + m * o + f * i - h * r, n[7] = m * a - f * r - h * i - d * o, n } function Oi(n, t, e) { var r = -t[0], i = -t[1], o = -t[2], a = t[3], u = t[4], s = t[5], c = t[6], l = t[7], f = u * a + l * r + s * o - c * i, h = s * a + l * i + c * r - u * o, d = c * a + l * o + u * i - s * r, m = l * a - u * r - s * i - c * o; return Dr(n, t, e), r = n[0], i = n[1], o = n[2], a = n[3], n[4] = f * a + m * r + h * o - d * i, n[5] = h * a + m * i + d * r - f * o, n[6] = d * a + m * o + f * i - h * r, n[7] = m * a - f * r - h * i - d * o, n } function Vi(n, t, e) { var r = e[0], i = e[1], o = e[2], a = e[3], u = t[0], s = t[1], c = t[2], l = t[3]; return n[0] = u * a + l * r + s * o - c * i, n[1] = s * a + l * i + c * r - u * o, n[2] = c * a + l * o + u * i - s * r, n[3] = l * a - u * r - s * i - c * o, u = t[4], s = t[5], c = t[6], l = t[7], n[4] = u * a + l * r + s * o - c * i, n[5] = s * a + l * i + c * r - u * o, n[6] = c * a + l * o + u * i - s * r, n[7] = l * a - u * r - s * i - c * o, n } function Bi(n, t, e) { var r = t[0], i = t[1], o = t[2], a = t[3], u = e[0], s = e[1], c = e[2], l = e[3]; return n[0] = r * l + a * u + i * c - o * s, n[1] = i * l + a * s + o * u - r * c, n[2] = o * l + a * c + r * s - i * u, n[3] = a * l - r * u - i * s - o * c, u = e[4], s = e[5], c = e[6], l = e[7], n[4] = r * l + a * u + i * c - o * s, n[5] = i * l + a * s + o * u - r * c, n[6] = o * l + a * c + r * s - i * u, n[7] = a * l - r * u - i * s - o * c, n } function Ii(n, t, e, r) { if (Math.abs(r) < d) return yi(n, t); var i = Math.hypot(e[0], e[1], e[2]); r *= .5; var o = Math.sin(r), a = o * e[0] / i, u = o * e[1] / i, s = o * e[2] / i, c = Math.cos(r), l = t[0], f = t[1], h = t[2], m = t[3]; n[0] = l * c + m * a + f * s - h * u, n[1] = f * c + m * u + h * a - l * s, n[2] = h * c + m * s + l * u - f * a, n[3] = m * c - l * a - f * u - h * s; var p = t[4], v = t[5], _ = t[6], g = t[7]; return n[4] = p * c + g * a + v * s - _ * u, n[5] = v * c + g * u + _ * a - p * s, n[6] = _ * c + g * s + p * u - v * a, n[7] = g * c - p * a - v * u - _ * s, n } function zi(n, t, e) { return n[0] = t[0] + e[0], n[1] = t[1] + e[1], n[2] = t[2] + e[2], n[3] = t[3] + e[3], n[4] = t[4] + e[4], n[5] = t[5] + e[5], n[6] = t[6] + e[6], n[7] = t[7] + e[7], n } function ki(n, t, e) { var r = t[0], i = t[1], o = t[2], a = t[3], u = e[4], s = e[5], c = e[6], l = e[7], f = t[4], h = t[5], d = t[6], m = t[7], p = e[0], v = e[1], _ = e[2], g = e[3]; return n[0] = r * g + a * p + i * _ - o * v, n[1] = i * g + a * v + o * p - r * _, n[2] = o * g + a * _ + r * v - i * p, n[3] = a * g - r * p - i * v - o * _, n[4] = r * l + a * u + i * c - o * s + f * g + m * p + h * _ - d * v, n[5] = i * l + a * s + o * u - r * c + h * g + m * v + d * p - f * _, n[6] = o * l + a * c + r * s - i * u + d * g + m * _ + f * v - h * p, n[7] = a * l - r * u - i * s - o * c + m * g - f * p - h * v - d * _, n } var Gi = ki; function Ui(n, t, e) { return n[0] = t[0] * e, n[1] = t[1] * e, n[2] = t[2] * e, n[3] = t[3] * e, n[4] = t[4] * e, n[5] = t[5] * e, n[6] = t[6] * e, n[7] = t[7] * e, n } var qi = ii; function Hi(n, t, e, r) { var i = 1 - r; return qi(t, e) < 0 && (r = -r), n[0] = t[0] * i + e[0] * r, n[1] = t[1] * i + e[1] * r, n[2] = t[2] * i + e[2] * r, n[3] = t[3] * i + e[3] * r, n[4] = t[4] * i + e[4] * r, n[5] = t[5] * i + e[5] * r, n[6] = t[6] * i + e[6] * r, n[7] = t[7] * i + e[7] * r, n } function ji(n, t) { var e = Qi(t); return n[0] = -t[0] / e, n[1] = -t[1] / e, n[2] = -t[2] / e, n[3] = t[3] / e, n[4] = -t[4] / e, n[5] = -t[5] / e, n[6] = -t[6] / e, n[7] = t[7] / e, n } function Xi(n, t) { return n[0] = -t[0], n[1] = -t[1], n[2] = -t[2], n[3] = t[3], n[4] = -t[4], n[5] = -t[5], n[6] = -t[6], n[7] = t[7], n } var Wi = ai, Ki = Wi, Qi = si, Yi = Qi; function Zi(n, t) { var e = Qi(t); if (e > 0) { e = Math.sqrt(e); var r = t[0] / e, i = t[1] / e, o = t[2] / e, a = t[3] / e, u = t[4], s = t[5], c = t[6], l = t[7], f = r * u + i * s + o * c + a * l; n[0] = r, n[1] = i, n[2] = o, n[3] = a, n[4] = (u - r * f) / e, n[5] = (s - i * f) / e, n[6] = (c - o * f) / e, n[7] = (l - a * f) / e } return n } function Ji(n) { return "quat2(" + n[0] + ", " + n[1] + ", " + n[2] + ", " + n[3] + ", " + n[4] + ", " + n[5] + ", " + n[6] + ", " + n[7] + ")" } function $i(n, t) { return n[0] === t[0] && n[1] === t[1] && n[2] === t[2] && n[3] === t[3] && n[4] === t[4] && n[5] === t[5] && n[6] === t[6] && n[7] === t[7] } function no(n, t) { var e = n[0], r = n[1], i = n[2], o = n[3], a = n[4], u = n[5], s = n[6], c = n[7], l = t[0], f = t[1], h = t[2], m = t[3], p = t[4], v = t[5], _ = t[6], g = t[7]; return Math.abs(e - l) <= d * Math.max(1, Math.abs(e), Math.abs(l)) && Math.abs(r - f) <= d * Math.max(1, Math.abs(r), Math.abs(f)) && Math.abs(i - h) <= d * Math.max(1, Math.abs(i), Math.abs(h)) && Math.abs(o - m) <= d * Math.max(1, Math.abs(o), Math.abs(m)) && Math.abs(a - p) <= d * Math.max(1, Math.abs(a), Math.abs(p)) && Math.abs(u - v) <= d * Math.max(1, Math.abs(u), Math.abs(v)) && Math.abs(s - _) <= d * Math.max(1, Math.abs(s), Math.abs(_)) && Math.abs(c - g) <= d * Math.max(1, Math.abs(c), Math.abs(g)) } function to() { var n = new m(2); return m != Float32Array && (n[0] = 0, n[1] = 0), n } function eo(n) { var t = new m(2); return t[0] = n[0], t[1] = n[1], t } function ro(n, t) { var e = new m(2); return e[0] = n, e[1] = t, e } function io(n, t) { return n[0] = t[0], n[1] = t[1], n } function oo(n, t, e) { return n[0] = t, n[1] = e, n } function ao(n, t, e) { return n[0] = t[0] + e[0], n[1] = t[1] + e[1], n } function uo(n, t, e) { return n[0] = t[0] - e[0], n[1] = t[1] - e[1], n } function so(n, t, e) { return n[0] = t[0] * e[0], n[1] = t[1] * e[1], n } function co(n, t, e) { return n[0] = t[0] / e[0], n[1] = t[1] / e[1], n } function lo(n, t) { return n[0] = Math.ceil(t[0]), n[1] = Math.ceil(t[1]), n } function fo(n, t) { return n[0] = Math.floor(t[0]), n[1] = Math.floor(t[1]), n } function ho(n, t, e) { return n[0] = Math.min(t[0], e[0]), n[1] = Math.min(t[1], e[1]), n } function mo(n, t, e) { return n[0] = Math.max(t[0], e[0]), n[1] = Math.max(t[1], e[1]), n } function po(n, t) { return n[0] = Math.round(t[0]), n[1] = Math.round(t[1]), n } function vo(n, t, e) { return n[0] = t[0] * e, n[1] = t[1] * e, n } function _o(n, t, e, r) { return n[0] = t[0] + e[0] * r, n[1] = t[1] + e[1] * r, n } function go(n, t) { var e = t[0] - n[0], r = t[1] - n[1]; return Math.hypot(e, r) } function bo(n, t) { var e = t[0] - n[0], r = t[1] - n[1]; return e * e + r * r } function Mo(n) { var t = n[0], e = n[1]; return Math.hypot(t, e) } function xo(n) { var t = n[0], e = n[1]; return t * t + e * e } function So(n, t) { return n[0] = -t[0], n[1] = -t[1], n } function wo(n, t) { return n[0] = 1 / t[0], n[1] = 1 / t[1], n } function yo(n, t) { var e = t[0], r = t[1], i = e * e + r * r; return i > 0 && (i = 1 / Math.sqrt(i)), n[0] = t[0] * i, n[1] = t[1] * i, n } function Po(n, t) { return n[0] * t[0] + n[1] * t[1] } function Lo(n, t, e) { var r = t[0] * e[1] - t[1] * e[0]; return n[0] = n[1] = 0, n[2] = r, n } function To(n, t, e, r) { var i = t[0], o = t[1]; return n[0] = i + r * (e[0] - i), n[1] = o + r * (e[1] - o), n } function Ro(n, t) { t = t || 1; var e = 2 * p() * Math.PI; return n[0] = Math.cos(e) * t, n[1] = Math.sin(e) * t, n } function Eo(n, t, e) { var r = t[0], i = t[1]; return n[0] = e[0] * r + e[2] * i, n[1] = e[1] * r + e[3] * i, n } function Fo(n, t, e) { var r = t[0], i = t[1]; return n[0] = e[0] * r + e[2] * i + e[4], n[1] = e[1] * r + e[3] * i + e[5], n } function No(n, t, e) { var r = t[0], i = t[1]; return n[0] = e[0] * r + e[3] * i + e[6], n[1] = e[1] * r + e[4] * i + e[7], n } function Ao(n, t, e) { var r = t[0], i = t[1]; return n[0] = e[0] * r + e[4] * i + e[12], n[1] = e[1] * r + e[5] * i + e[13], n } function Do(n, t, e, r) { var i = t[0] - e[0], o = t[1] - e[1], a = Math.sin(r), u = Math.cos(r); return n[0] = i * u - o * a + e[0], n[1] = i * a + o * u + e[1], n } function Co(n, t) { var e = n[0], r = n[1], i = t[0], o = t[1], a = Math.sqrt(e * e + r * r) * Math.sqrt(i * i + o * o), u = a && (e * i + r * o) / a; return Math.acos(Math.min(Math.max(u, -1), 1)) } function Oo(n) { return n[0] = 0, n[1] = 0, n } function Vo(n) { return "vec2(" + n[0] + ", " + n[1] + ")" } function Bo(n, t) { return n[0] === t[0] && n[1] === t[1] } function Io(n, t) { var e = n[0], r = n[1], i = t[0], o = t[1]; return Math.abs(e - i) <= d * Math.max(1, Math.abs(e), Math.abs(i)) && Math.abs(r - o) <= d * Math.max(1, Math.abs(r), Math.abs(o)) } var zo = Mo, ko = uo, Go = so, Uo = co, qo = go, Ho = bo, jo = xo, Xo = function () { var n = to(); return function (t, e, r, i, o, a) { var u, s; for (e || (e = 2), r || (r = 0), s = i ? Math.min(i * e + r, t.length) : t.length, u = r; u < s; u += e)n[0] = t[u], n[1] = t[u + 1], o(n, n, a), t[u] = n[0], t[u + 1] = n[1]; return t } }() }, function (n, t, e) { n.exports = e(4) }, function (n, t, e) { "use strict"; var r, i = this && this.__extends || (r = function (n, t) { return (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (n, t) { n.__proto__ = t } || function (n, t) { for (var e in t) t.hasOwnProperty(e) && (n[e] = t[e]) })(n, t) }, function (n, t) { function e() { this.constructor = n } r(n, t), n.prototype = null === t ? Object.create(t) : (e.prototype = t.prototype, new e) }); Object.defineProperty(t, "__esModule", { value: !0 }); var o = e(2), a = e(0), u = e(0), s = e(5), c = e(8), l = e(9), f = e(10), h = e(11), d = e(12), m = function (n) { function t() { return null !== n && n.apply(this, arguments) || this } return i(t, n), t.prototype.onInitialize = function (n, r, i) { var a = this, l = this._context.gl, h = this._context.gl2facade; n.enable(["OES_standard_derivatives", "WEBGL_color_buffer_float", "OES_texture_float", "OES_texture_float_linear"]), this._loader = new u.GLTFLoader(this._context), this._cornellScene = new c.Scene(t.URL + "/models/cornell.glb", new u.Camera(o.vec3.fromValues(-.255, 3.09, -8), o.vec3.fromValues(.135, 1.192, -.46)), .2, 20), this._cornellScene.addDiskLight(new f.DiskLight(o.vec3.fromValues(.13, 2.32, -.23), .15, o.vec3.fromValues(303, 303, 303), o.vec3.fromValues(0, -1, 0), 90)), this._skylineScene = new c.Scene(t.URL + "/models/skyline.glb", new u.Camera(o.vec3.fromValues(-4.0645, 2.816, 6.2326), o.vec3.fromValues(.342, -.42328, .1032)), .2, 20), this._skylineScene.addDiskLight(new f.DiskLight(o.vec3.fromValues(1.827, 2.5, -1.11), .25, o.vec3.fromValues(501, 501, 501), o.vec3.fromValues(-.5554236173629761, -.7600213289260864, .33744949102401733), 110)), this._skylineScene.addDiskLight(new f.DiskLight(o.vec3.fromValues(-2.03, 2.5, -1.205), .25, o.vec3.fromValues(501, 501, 501), o.vec3.fromValues(.5903826355934143, -.7270721793174744, .3504488170146942), 110)), this._skylineScene.addDiskLight(new f.DiskLight(o.vec3.fromValues(1.418, 2.5, 2.17), .25, o.vec3.fromValues(501, 501, 501), o.vec3.fromValues(-.39374271035194397, -.6941867470741272, -.6025540828704834), 110)), this._skylineScene.addDiskLight(new f.DiskLight(o.vec3.fromValues(-1.642, 2.5, 1.9708), .25, o.vec3.fromValues(501, 501, 501), o.vec3.fromValues(.45841217041015625, -.6979479193687439, -.5502063035964966), 110)), this._datsunScene = new c.Scene(t.URL + "/models/datsun.glb", new u.Camera(o.vec3.fromValues(-1.9631, 1.89, 6.548), o.vec3.fromValues(.292, -.327, -.13)), .2, 30), this._datsunScene.addDiskLight(new f.DiskLight(o.vec3.fromValues(-3.04, 3, -1.4), .15, o.vec3.fromValues(901, 901, 901), o.vec3.fromValues(.67636, -.66746, .31148), 110)), this._datsunScene.addDiskLight(new f.DiskLight(o.vec3.fromValues(2.62, 3, -1.4), .15, o.vec3.fromValues(901, 901, 901), o.vec3.fromValues(-.62057, -.71058, .3316), 110)), this._datsunScene.addDiskLight(new f.DiskLight(o.vec3.fromValues(-2.12, 3, 2.1), .15, o.vec3.fromValues(901, 901, 901), o.vec3.fromValues(.50102, -.70899, -.49629), 110)), this._datsunScene.addDiskLight(new f.DiskLight(o.vec3.fromValues(2.14, 3, 2.1), .15, o.vec3.fromValues(901, 901, 901), o.vec3.fromValues(-.50454, -.70731, -.49511), 110)), this._kitchenScene = new c.Scene(t.URL + "/models/kitchen.glb", new u.Camera(o.vec3.fromValues(-.65597, 2.2284, 6.2853), o.vec3.fromValues(.24971, 1.1144, -.7265)), .1, 10), this._kitchenScene.addDiskLight(new f.DiskLight(o.vec3.fromValues(-.54, 1.6, -1.17), .025, o.vec3.fromValues(5001, 5001, 5001), o.vec3.fromValues(0, -1, 0), 160)), this._kitchenScene.addDiskLight(new f.DiskLight(o.vec3.fromValues(.88, 1.6, -1.17), .025, o.vec3.fromValues(5001, 5001, 5001), o.vec3.fromValues(0, -1, 0), 160)), this._kitchenScene.addDiskLight(new f.DiskLight(o.vec3.fromValues(1.62, 1.6, -1.17), .025, o.vec3.fromValues(5001, 5001, 5001), o.vec3.fromValues(0, -1, 0), 160)), this._kitchenScene.addDiskLight(new f.DiskLight(o.vec3.fromValues(.16, 1.6, -1.17), .025, o.vec3.fromValues(5001, 5001, 5001), o.vec3.fromValues(0, -1, 0), 160)), this._kitchenScene.addDiskLight(new f.DiskLight(o.vec3.fromValues(1.92, 1.6, -.86), .025, o.vec3.fromValues(5001, 5001, 5001), o.vec3.fromValues(0, -1, 0), 160)), this._kitchenScene.addDiskLight(new f.DiskLight(o.vec3.fromValues(1.92, 1.6, -.22), .025, o.vec3.fromValues(5001, 5001, 5001), o.vec3.fromValues(0, -1, 0), 160)), this._emptyTexture = new u.Texture2D(this._context, "EmptyTexture"), this._emptyTexture.initialize(1, 1, l.RGBA, l.RGBA, l.UNSIGNED_BYTE), this._defaultFramebuffer = new u.DefaultFramebuffer(this._context, "DefaultFBO"), this._defaultFramebuffer.initialize(), this._ndcTriangle = new u.NdcFillingTriangle(this._context), this._ndcTriangle.initialize(); var d = new u.Shader(this._context, l.VERTEX_SHADER, "mesh.vert"); d.initialize(e(1)); var m = new u.Shader(this._context, l.FRAGMENT_SHADER, "progressive_lighting.frag"); m.initialize(e(14)), this._program = new u.Program(this._context, "ProgressiveLightingProgram"), this._program.initialize([d, m]), this._uViewProjection = this._program.uniform("u_viewProjection"), this._uView = this._program.uniform("u_view"), this._uProjection = this._program.uniform("u_projection"), this._uModel = this._program.uniform("u_model"), this._uNormalMatrix = this._program.uniform("u_normalMatrix"), this._uViewNormalMatrix = this._program.uniform("u_viewNormalMatrix"), this._uCameraNearFar = this._program.uniform("u_cameraNearFar"), this._uBaseColor = this._program.uniform("u_baseColor"), this._uBaseColorTexCoord = this._program.uniform("u_baseColorTexCoord"), this._uMetallicRoughness = this._program.uniform("u_metallicRoughness"), this._uMetallicRoughnessTexCoord = this._program.uniform("u_metallicRoughnessTexCoord"), this._uNormal = this._program.uniform("u_normal"), this._uNormalTexCoord = this._program.uniform("u_normalTexCoord"), this._uEmissive = this._program.uniform("u_emissive"), this._uEmissiveTexCoord = this._program.uniform("u_emissiveTexCoord"), this._uOcclusion = this._program.uniform("u_occlusion"), this._uOcclusionTexCoord = this._program.uniform("u_occlusionTexCoord"), this._uNdcOffset = this._program.uniform("u_ndcOffset"), this._uFrameNumber = this._program.uniform("u_frameNumber"), this._uCocPoint = this._program.uniform("u_cocPoint"), this._uEye = this._program.uniform("u_eye"), this._uGeometryFlags = this._program.uniform("u_geometryFlags"), this._uPbrFlags = this._program.uniform("u_pbrFlags"), this._uBaseColorFactor = this._program.uniform("u_baseColorFactor"), this._uMetallicFactor = this._program.uniform("u_metallicFactor"), this._uRoughnessFactor = this._program.uniform("u_roughnessFactor"), this._uEmissiveFactor = this._program.uniform("u_emissiveFactor"), this._uNormalScale = this._program.uniform("u_normalScale"), this._uBlendMode = this._program.uniform("u_blendMode"), this._uBlendCutoff = this._program.uniform("u_blendCutoff"), this._uLightSampleIndex = this._program.uniform("u_lightSampleIndex"), this._uLightFactor = this._program.uniform("u_lightFactor"), this._uNumDiffuseEnvironmentSamples = this._program.uniform("u_numDiffuseEnvironmentSamples"), this._uDiffuseEnvironmentFactor = this._program.uniform("u_diffuseEnvironmentFactor"), this._uNumSpecularEnvironmentSamples = this._program.uniform("u_numSpecularEnvironmentSamples"), this._uSpecularEnvironmentFactor = this._program.uniform("u_specularEnvironmentFactor"), this._uDiffuseEnvironment = this._program.uniform("u_diffuseEnvironment"), this._uSpecularEnvironment = this._program.uniform("u_specularEnvironment"), this._uBRDFLookupTable = this._program.uniform("u_brdfLUT"), this._uLastFrame = this._program.uniform("u_lastFrame"), this._uShadowMap = this._program.uniform("u_shadowMap"), this._uNormalDepth = this._program.uniform("u_normalDepth"), this._uLightView = this._program.uniform("u_lightView"), this._uLightProjection = this._program.uniform("u_lightProjection"), this._uLightNearFar = this._program.uniform("u_lightNearFar"), this._uOcclusionRange = this._program.uniform("u_occlusionRange"), this._uIBLStrength = this._program.uniform("u_iblStrength"); var p = new u.Shader(this._context, l.VERTEX_SHADER, "mesh.vert"); p.initialize(e(1)); var v = new u.Shader(this._context, l.FRAGMENT_SHADER, "shadow.frag"); v.initialize(e(15)), this._shadowProgram = new u.Program(this._context, "ShadowProgram"), this._shadowProgram.initialize([p, v]), this._uModelS = this._shadowProgram.uniform("u_model"), this._uViewS = this._shadowProgram.uniform("u_view"), this._uProjectionS = this._shadowProgram.uniform("u_projection"), this._uLightNearFarS = this._shadowProgram.uniform("u_lightNearFar"), this._uLightPositionS = this._shadowProgram.uniform("u_lightPosition"); var _ = new u.Shader(this._context, l.VERTEX_SHADER, "mesh.vert"); _.initialize(e(1)); var g = new u.Shader(this._context, l.FRAGMENT_SHADER, "normal_depth.frag"); g.initialize(e(16)), this._depthProgram = new u.Program(this._context, "NormalDepthProgram"), this._depthProgram.initialize([_, g]), this._uViewD = this._depthProgram.uniform("u_view"), this._uProjectionD = this._depthProgram.uniform("u_projection"), this._uCameraNearFarD = this._depthProgram.uniform("u_cameraNearFar"), this._uModelD = this._depthProgram.uniform("u_model"), this._camera = new u.Camera, this._navigation = new u.Navigation(r, i.mouseEventProvider, i.touchEventProvider), this._navigation.camera = this._camera, this._colorRenderTexture = new u.Texture2D(this._context, "ColorRenderTexture"), this._depthRenderbuffer = new u.Renderbuffer(this._context, "DepthRenderbuffer"), this._intermediateFBO = new u.Framebuffer(this._context, "IntermediateFBO"), this._preDepthFBO = new u.Framebuffer(this._context, "PreDepthFBO"), this._normalDepthTexture = new u.Texture2D(this._context, "NormalDepthTexture"), this._preDepthRenderbuffer = new u.Renderbuffer(this._context, "PreDepthRenderbuffer"), this._forwardPass = new u.ForwardSceneRenderPass(n), this._forwardPass.initialize(), this._forwardPass.camera = this._camera, this._forwardPass.target = this._intermediateFBO, this._forwardPass.program = this._program, this._forwardPass.updateViewProjectionTransform = function (n) { l.uniformMatrix4fv(a._uViewProjection, l.FALSE, n) }, this._accumulatePass = new u.AccumulatePass(n), this._accumulatePass.initialize(this._ndcTriangle), this._accumulatePass.precision = u.Wizard.Precision.float, this._accumulatePass.texture = this._colorRenderTexture, this._postProcessingPass = new s.PostProcessingPass(n), this._postProcessingPass.initialize(this._ndcTriangle), this._shadowPass = new u.ShadowPass(n), this._shadowPass.initialize(u.ShadowPass.ShadowMappingType.HardLinear, [2048, 2048]), this._blitPass = new u.BlitPass(this._context), this._blitPass.initialize(this._ndcTriangle), this._blitPass.framebuffer = this._postProcessingPass.framebuffer, this._blitPass.readBuffer = h.COLOR_ATTACHMENT0, this._blitPass.target = this._defaultFramebuffer, this._blitPass.drawBuffer = l.BACK, this.loadEnvironmentMap(), window.document.getElementById("asset-select").onchange = function (n) { a.loadAsset() }, window.document.getElementById("environment-select").onchange = function (n) { a.loadEnvironmentMap(), a._invalidate(!0) }, window.document.getElementById("debug-select").onchange = function (n) { a.setDebugMode(), a._invalidate(!0) }; var b = window.document.getElementById("exposure-range"); b.onchange = function (n) { a._postProcessingPass.exposure = parseFloat(b.value) / 10, a._invalidate(!0) }; var M = window.document.getElementById("ibl-range"); M.onchange = function (n) { a._program.bind(), l.uniform1f(a._uIBLStrength, parseFloat(M.value) / 20), a._program.unbind(), a._invalidate(!0) }, M.onchange(new Event("")); var x = window.document.getElementById("occlusion-range"); x.onchange = function (n) { a._program.bind(), l.uniform1f(a._uOcclusionRange, parseFloat(x.value) / 300), a._program.unbind(), a._invalidate(!0) }, x.onchange(new Event("")); var S = window.document.getElementById("dof-range"); return S.onchange = function (n) { a._depthOfFieldRange = parseFloat(S.value) / 1e3, a._invalidate(!0) }, S.onchange(new Event("")), !0 }, t.prototype.onUninitialize = function () { n.prototype.uninitialize.call(this) }, t.prototype.onUpdate = function () { return (this._altered.frameSize || this._camera.altered) && (this._camera.viewport = [this._frameSize[0], this._frameSize[1]]), (this._altered.canvasSize || this._camera.altered) && (this._camera.aspect = this._canvasSize[0] / this._canvasSize[1]), this._navigation.update(), this._forwardPass.update(), this._altered.any || this._camera.altered }, t.prototype.onPrepare = function () { var n = this._context.gl, t = this._context.gl2facade; void 0 === this._forwardPass.scene && this.loadAsset(); var e = Math.round(this._multiFrameNumber / this._currentScene.diskLights.length / 4), r = Math.round(this._multiFrameNumber); this._sampleManager = new d.SampleManager(this._currentScene, this._multiFrameNumber, e, r), this._intermediateFBO.initialized || (this._colorRenderTexture.initialize(this._frameSize[0], this._frameSize[1], this._context.isWebGL2 ? n.RGBA32F : n.RGBA, n.RGBA, n.FLOAT), this._depthRenderbuffer.initialize(this._frameSize[0], this._frameSize[1], n.DEPTH_COMPONENT16), this._intermediateFBO.initialize([[t.COLOR_ATTACHMENT0, this._colorRenderTexture], [n.DEPTH_ATTACHMENT, this._depthRenderbuffer]])), this._preDepthFBO.initialized || (this._normalDepthTexture.initialize(this._frameSize[0], this._frameSize[1], this._context.isWebGL2 ? n.RGBA32F : n.RGBA, (this._context.isWebGL2, n.RGBA), n.FLOAT), this._preDepthRenderbuffer.initialize(this._frameSize[0], this._frameSize[1], n.DEPTH_COMPONENT16), this._preDepthFBO.initialize([[t.COLOR_ATTACHMENT0, this._normalDepthTexture], [n.DEPTH_ATTACHMENT, this._preDepthRenderbuffer]])), this._altered.multiFrameNumber && (this._ndcOffsetKernel = new u.AntiAliasingKernel(this._multiFrameNumber), this._depthOfFieldKernel = new h.DepthOfFieldKernel(this._multiFrameNumber)), this._altered.frameSize && (this._intermediateFBO.resize(this._frameSize[0], this._frameSize[1]), this._camera.viewport = [this._frameSize[0], this._frameSize[1]]), this._altered.clearColor && (this._intermediateFBO.clearColor(this._clearColor), this._forwardPass.clearColor = this._clearColor), this._forwardPass.prepare(), this._accumulatePass.update(), this._postProcessingPass.texture = this._accumulatePass.framebuffer.texture(t.COLOR_ATTACHMENT0), this._postProcessingPass.normalDepthTexture = this._normalDepthTexture, this._postProcessingPass.update(), this.bindMultiframeUniforms(), this._altered.reset(), this._camera.altered = !1 }, t.prototype.preDepthPass = function () { var n = this, t = this._context.gl; this._preDepthFBO.clear(t.COLOR_BUFFER_BIT | t.DEPTH_BUFFER_BIT, !0, !1), t.viewport(0, 0, this._preDepthFBO.width, this._preDepthFBO.height), this._depthProgram.bind(), this._forwardPass.program = this._depthProgram, this._forwardPass.target = this._preDepthFBO, this._forwardPass.bindMaterial = function (n) { }, this._forwardPass.bindGeometry = function (n) { }, this._forwardPass.updateModelTransform = function (e) { t.uniformMatrix4fv(n._uModelD, t.FALSE, e) }, this._forwardPass.drawCalls(!1) }, t.prototype.shadowPass = function (n, t) { var e = this, r = this._context.gl, i = this._currentScene.diskLights[n], a = o.vec3.add(o.vec3.create(), t, i.direction), s = new u.Camera; s.eye = t, s.center = a, s.up = o.vec3.fromValues(1, 0, 0), s.near = .1, s.far = 30, s.fovy = i.fovy; var c = o.vec2.fromValues(s.near, s.far); this._shadowPass.frame((function () { e._shadowProgram.bind(), r.uniformMatrix4fv(e._uProjectionS, r.FALSE, s.projection), r.uniformMatrix4fv(e._uViewS, r.FALSE, s.view), r.uniform2fv(e._uLightNearFarS, c), r.uniform3fv(e._uLightPositionS, t), e._forwardPass.bindMaterial = function (n) { }, e._forwardPass.bindGeometry = function (n) { }, e._forwardPass.updateModelTransform = function (n) { r.uniformMatrix4fv(e._uModelS, r.FALSE, n) }, e._forwardPass.drawCalls(!1), e._shadowProgram.unbind() })), this._program.bind(), r.uniformMatrix4fv(this._uLightView, r.FALSE, s.view), r.uniformMatrix4fv(this._uLightProjection, r.FALSE, s.projection), r.uniform2fv(this._uLightNearFar, c), this._program.unbind() }, t.prototype.onFrame = function (n) { var t = this; if (!this.isLoading) { a.auxiliaries.assert(void 0 !== this._forwardPass.scene, "Scene undefined in onFrame."); var e = this._context.gl, r = this._context.gl2facade; this.prepareFrame(n), this._forwardPass.program = this._program, this._forwardPass.target = this._intermediateFBO, this._forwardPass.bindMaterial = function (n) { var r = n; a.auxiliaries.assert(void 0 !== r, "Material " + n.name + " is not a PBR material."), void 0 !== r.baseColorTexture ? (r.baseColorTexture.bind(e.TEXTURE0), e.uniform1i(t._uBaseColorTexCoord, r.baseColorTexCoord)) : t._emptyTexture.bind(e.TEXTURE0), void 0 !== r.metallicRoughnessTexture ? (r.metallicRoughnessTexture.bind(e.TEXTURE1), e.uniform1i(t._uMetallicRoughnessTexCoord, r.metallicRoughnessTexCoord)) : t._emptyTexture.bind(e.TEXTURE1), void 0 !== r.normalTexture ? (r.normalTexture.bind(e.TEXTURE2), e.uniform1i(t._uNormalTexCoord, r.normalTexCoord)) : t._emptyTexture.bind(e.TEXTURE2), void 0 !== r.occlusionTexture ? (r.occlusionTexture.bind(e.TEXTURE3), e.uniform1i(t._uOcclusionTexCoord, r.occlusionTexCoord)) : t._emptyTexture.bind(e.TEXTURE3), void 0 !== r.emissiveTexture ? (r.emissiveTexture.bind(e.TEXTURE4), e.uniform1i(t._uEmissiveTexCoord, r.emissiveTexCoord)) : t._emptyTexture.bind(e.TEXTURE4), e.uniform4fv(t._uBaseColorFactor, r.baseColorFactor), e.uniform3fv(t._uEmissiveFactor, r.emissiveFactor), e.uniform1f(t._uMetallicFactor, r.metallicFactor), e.uniform1f(t._uRoughnessFactor, r.roughnessFactor), e.uniform1f(t._uNormalScale, r.normalScale), e.uniform1i(t._uPbrFlags, r.flags), r.alphaMode === u.GLTFAlphaMode.OPAQUE ? (e.disable(e.BLEND), e.uniform1i(t._uBlendMode, 0)) : r.alphaMode === u.GLTFAlphaMode.MASK ? (e.enable(e.BLEND), e.blendFunc(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA), e.uniform1i(t._uBlendMode, 1), e.uniform1f(t._uBlendCutoff, r.alphaCutoff)) : r.alphaMode === u.GLTFAlphaMode.BLEND ? (e.enable(e.BLEND), e.blendFuncSeparate(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA), e.uniform1i(t._uBlendMode, 2)) : a.auxiliaries.log(a.auxiliaries.LogLevel.Warning, "Unknown blend mode encountered.") }, this._forwardPass.bindGeometry = function (n) { var r = n; e.uniform1i(t._uGeometryFlags, r.flags) }, this._forwardPass.updateModelTransform = function (n) { e.uniformMatrix4fv(t._uModel, e.FALSE, n); var r = o.mat3.create(); o.mat3.normalFromMat4(r, n), e.uniformMatrix3fv(t._uNormalMatrix, e.FALSE, r) }, this._forwardPass.frame(), this._accumulatePass.frame(n), this._postProcessingPass.texture = this._accumulatePass.framebuffer.texture(r.COLOR_ATTACHMENT0), this._postProcessingPass.frame() } }, t.prototype.onSwap = function () { this._blitPass.frame() }, t.prototype.bindMultiframeUniforms = function () { var n = this._context.gl; this._program.bind(), n.uniformMatrix4fv(this._uView, n.FALSE, this._camera.view), n.uniformMatrix4fv(this._uProjection, n.FALSE, this._camera.projection), n.uniform2fv(this._uCameraNearFar, o.vec2.fromValues(this._camera.near, this._camera.far)); var t = o.mat3.create(); o.mat3.normalFromMat4(t, this._camera.view), n.uniformMatrix3fv(this._uViewNormalMatrix, n.FALSE, t), n.uniform3fv(this._uEye, this._camera.eye), n.uniform1i(this._uBaseColor, 0), n.uniform1i(this._uMetallicRoughness, 1), n.uniform1i(this._uNormal, 2), n.uniform1i(this._uOcclusion, 3), n.uniform1i(this._uEmissive, 4), n.uniform1i(this._uDiffuseEnvironment, 10), n.uniform1i(this._uSpecularEnvironment, 5), n.uniform1i(this._uBRDFLookupTable, 6), n.uniform1i(this._uShadowMap, 7), n.uniform1i(this._uNormalDepth, 8), n.uniform1i(this._uLastFrame, 9), this._specularEnvironment.bind(n.TEXTURE5), this._diffuseEnvironment.bind(n.TEXTURE10), this._brdfLUT.bind(n.TEXTURE6), this._shadowPass.shadowMapTexture.bind(n.TEXTURE7), this._normalDepthTexture.bind(n.TEXTURE8), this._depthProgram.bind(), n.uniform2fv(this._uCameraNearFarD, o.vec2.fromValues(this._camera.near, this._camera.far)), n.uniformMatrix4fv(this._uViewD, n.FALSE, this._camera.view), n.uniformMatrix4fv(this._uProjectionD, n.FALSE, this._camera.projection), this._depthProgram.unbind() }, t.prototype.prepareFrame = function (n) { for (var t = this._context.gl, e = this._context.gl2facade, r = this._sampleManager.getNextFrameSamples(), i = 0, a = 1, u = 0, s = 1, c = -1, l = o.vec3.create(), f = 1, h = 0, m = r; h < m.length; h++) { var p = m[h]; p instanceof d.DiffuseEnvironmentSample && (i++, a = p.factor), p instanceof d.SpecularEnvironmentSample && (u++, s = p.factor), p instanceof d.LightSample && (c = p.lightIndex, l = p.eye, f = p.factor) } 1 === n && this.preDepthPass(), c >= 0 && this.shadowPass(c, l), this._program.bind(), t.uniform1i(this._uFrameNumber, n); var v = this._ndcOffsetKernel.get(n); v[0] = 2 * v[0] / this._frameSize[0], v[1] = 2 * v[1] / this._frameSize[1], t.uniform2fv(this._uNdcOffset, v); var _ = this._depthOfFieldKernel.get(n); _[0] *= this._depthOfFieldRange, _[1] *= this._depthOfFieldRange, t.uniform2fv(this._uCocPoint, _), t.uniform1i(this._uLightSampleIndex, c), t.uniform1f(this._uLightFactor, f), t.uniform1i(this._uNumDiffuseEnvironmentSamples, i), t.uniform1f(this._uDiffuseEnvironmentFactor, a), t.uniform1i(this._uNumSpecularEnvironmentSamples, u), t.uniform1f(this._uSpecularEnvironmentFactor, s), this._accumulatePass.framebuffer.texture(e.COLOR_ATTACHMENT0).bind(t.TEXTURE9) }, t.prototype.loadAsset = function () { var n, t = this, e = window.document.getElementById("asset-select"); "Datsun" === e.value ? n = this._datsunScene : "Kitchen" === e.value ? n = this._kitchenScene : "Cornell" === e.value ? n = this._cornellScene : "Skyline" === e.value && (n = this._skylineScene), a.auxiliaries.assert(void 0 !== n, "Unknown scene " + e.value + "."), void 0 !== n ? (this.startLoading(), this._postProcessingPass.clear(), this._currentScene = n, this._camera = n.camera, this.updateCamera(), this.updateLights(n), this._loader.uninitialize(), this._loader.loadAsset(n.uri).then((function () { t._forwardPass.scene = t._loader.defaultScene, t._invalidate(!0), t.finishLoading() }))) : a.auxiliaries.log(a.auxiliaries.LogLevel.Error, "Scene " + e.value + " could not be loaded.") }, t.prototype.setDebugMode = function () { var n = this._context.gl, t = window.document.getElementById("debug-select"), e = 0; "Final" === t.value ? e = 0 : "Flat" === t.value ? e = 1 : "IBL" === t.value ? e = 2 : "Light sources" === t.value ? e = 3 : "Illuminance" === t.value && (e = 4), this._program.bind(), n.uniform1i(this._program.uniform("u_debugMode"), e), this._program.unbind() }, t.prototype.updateLights = function (n) { var t = this._context.gl; this._program.bind(), t.uniform1i(this._program.uniform("u_numDiskLights"), n.diskLights.length); for (var e = 0, r = 0, i = n.diskLights; r < i.length; r++) { var o = i[r]; t.uniform3fv(this._program.uniform("u_diskLights[" + e + "].center"), o.center), t.uniform1f(this._program.uniform("u_diskLights[" + e + "].radius"), o.radius), t.uniform3fv(this._program.uniform("u_diskLights[" + e + "].luminance"), o.luminance), t.uniform3fv(this._program.uniform("u_diskLights[" + e + "].direction"), o.direction), e++ } this._program.unbind() }, t.prototype.updateCamera = function () { this._camera.viewport = [this._frameSize[0], this._frameSize[1]], this._camera.aspect = this._canvasSize[0] / this._canvasSize[1]; var n = 39.6 * a.auxiliaries.DEG2RAD, t = 2 * Math.atan(Math.tan(n / 2) * (1 / this._camera.aspect)); this._camera.fovy = t * a.auxiliaries.RAD2DEG, this._forwardPass.camera = this._camera, this._navigation.camera = this._camera, this._camera.altered = !0 }, t.prototype.loadEnvironmentMap = function () { var n = window.document.getElementById("environment-select").value, e = this._context.gl; this._brdfLUT = new u.Texture2D(this._context, "BRDFLookUpTable"), this._brdfLUT.initialize(1, 1, e.RG16F, e.RG, e.FLOAT), this._brdfLUT.wrap(e.CLAMP_TO_EDGE, e.CLAMP_TO_EDGE), this._brdfLUT.filter(e.LINEAR, e.LINEAR), this._brdfLUT.fetch("../examples/data/imagebasedlighting/brdfLUT.png"); var r = u.Wizard.queryInternalTextureFormat(this._context, e.RGBA, u.Wizard.Precision.byte); this._diffuseEnvironment = new u.TextureCube(this._context, "DiffuseEnvironment"), this._diffuseEnvironment.initialize(64, r[0], e.RGBA, r[1]), this._diffuseEnvironment.fetch({ positiveX: t.URL + "/environments/" + n + "/preprocessed-map-px-diffuse.png", negativeX: t.URL + "/environments/" + n + "/preprocessed-map-nx-diffuse.png", positiveY: t.URL + "/environments/" + n + "/preprocessed-map-py-diffuse.png", negativeY: t.URL + "/environments/" + n + "/preprocessed-map-ny-diffuse.png", positiveZ: t.URL + "/environments/" + n + "/preprocessed-map-pz-diffuse.png", negativeZ: t.URL + "/environments/" + n + "/preprocessed-map-nz-diffuse.png" }), this._specularEnvironment = new u.TextureCube(this._context, "SpecularEnvironment"), this._specularEnvironment.initialize(512, r[0], e.RGBA, r[1]); this._specularEnvironment.filter(e.LINEAR, e.LINEAR_MIPMAP_LINEAR), this._specularEnvironment.levels(0, 8); for (var i = 0; i < 9; ++i)this._specularEnvironment.fetch({ positiveX: t.URL + "/environments/" + n + "/preprocessed-map-px-" + i + ".png", negativeX: t.URL + "/environments/" + n + "/preprocessed-map-nx-" + i + ".png", positiveY: t.URL + "/environments/" + n + "/preprocessed-map-py-" + i + ".png", negativeY: t.URL + "/environments/" + n + "/preprocessed-map-ny-" + i + ".png", positiveZ: t.URL + "/environments/" + n + "/preprocessed-map-pz-" + i + ".png", negativeZ: t.URL + "/environments/" + n + "/preprocessed-map-nz-" + i + ".png" }, i) }, t.URL = "/demos/data", t }(u.Renderer); t.ProgressiveLightingRenderer = m; var p = function (n) { function t() { return null !== n && n.apply(this, arguments) || this } return i(t, n), t.prototype.onInitialize = function (n) { var t = this; this._canvas = new u.Canvas(n), this._canvas.controller.multiFrameNumber = 128, this._canvas.framePrecision = u.Wizard.Precision.float, this._canvas.frameScale = [1, 1], this._renderer = new m, this._canvas.renderer = this._renderer; var e = window.document.getElementById("frame-scale"); e.onchange = function (n) { var r = parseFloat(e.value) / 100; t._canvas.frameScale = [r, r] }; var r = window.document.getElementById("multiframe-count"); return r.onchange = function (n) { t._canvas.controller.multiFrameNumber = parseInt(r.value) }, !0 }, t.prototype.onUninitialize = function () { this._canvas.dispose(), this._renderer.uninitialize() }, Object.defineProperty(t.prototype, "canvas", { get: function () { return this._canvas }, enumerable: !0, configurable: !0 }), Object.defineProperty(t.prototype, "renderer", { get: function () { return this._renderer }, enumerable: !0, configurable: !0 }), t }(l.Demo); t.ProgressiveLightingDemo = p }, function (n, t, e) { "use strict"; var r, i = this && this.__extends || (r = function (n, t) { return (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (n, t) { n.__proto__ = t } || function (n, t) { for (var e in t) t.hasOwnProperty(e) && (n[e] = t[e]) })(n, t) }, function (n, t) { function e() { this.constructor = n } r(n, t), n.prototype = null === t ? Object.create(t) : (e.prototype = t.prototype, new e) }), o = this && this.__decorate || function (n, t, e, r) { var i, o = arguments.length, a = o < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, e) : r; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(n, t, e, r); else for (var u = n.length - 1; u >= 0; u--)(i = n[u]) && (a = (o < 3 ? i(a) : o > 3 ? i(t, e, a) : i(t, e)) || a); return o > 3 && a && Object.defineProperty(t, e, a), a }; Object.defineProperty(t, "__esModule", { value: !0 }); var a = e(0), u = function (n) { function t(t) { var e = n.call(this) || this; return e._context = t, e } return i(t, n), t.prototype.initialize = function (n) { var t = this._context.gl; this._frameBuffer = new a.Framebuffer(this._context, "PostProcessingFBO"), this._targetTexture = new a.Texture2D(this._context, "PostProcessingTexture"), this._ndcTriangle = n; var r = new a.Shader(this._context, t.VERTEX_SHADER, "ndcvertices.vert (postprocessing)"); r.initialize(e(6)); var i = new a.Shader(this._context, t.FRAGMENT_SHADER, "postprocessing.frag"); return i.initialize(e(7)), this._program = new a.Program(this._context, "AccumulateProgram"), this._program.initialize([r, i], !1), this._program.attribute("a_vertex", this._ndcTriangle.vertexLocation), this._program.link(), this._program.bind(), t.uniform1i(this._program.uniform("u_texture"), 0), t.uniform1i(this._program.uniform("u_normalDepthTexture"), 1), this._program.unbind(), this.exposure = 1, !0 }, t.prototype.uninitialize = function () { this._program.uninitialize(), this._frameBuffer.uninitialize() }, t.prototype.update = function () { var n = this._context.gl, t = this._context.gl2facade; if (this._texture && this._texture.valid) { var e = this._texture.size; if (!this._targetTexture.initialized) { var r = a.Wizard.queryInternalTextureFormat(this._context, n.RGBA, a.Wizard.Precision.byte); this._targetTexture.initialize(e[0], e[1], r[0], n.RGBA, r[1]) } (this._targetTexture.width !== this._texture.width || this._targetTexture.height !== this._texture.height) && this._targetTexture.resize(this._texture.width, this._texture.height), this._frameBuffer.initialized || this._frameBuffer.initialize([[t.COLOR_ATTACHMENT0, this._targetTexture]]), a.auxiliaries.assert(this._frameBuffer.valid, "valid framebuffers expected for postprocessing") } else a.auxiliaries.log(a.auxiliaries.LogLevel.Warning, "valid texture for postprocessing update expected, given " + this._texture) }, t.prototype.frame = function () { a.auxiliaries.assert(this._frameBuffer.valid, "valid framebuffer objects for postprocessing expected."), a.auxiliaries.logIf(!this._texture || !this._texture.valid, a.auxiliaries.LogLevel.Warning, "valid texture for postprocessing frame expected, given " + this._texture), a.auxiliaries.logIf(!this._normalDepthTexture || !this._normalDepthTexture.valid, a.auxiliaries.LogLevel.Warning, "valid normal/depth texture for postprocessing frame expected, given " + this._texture); var n = this._context.gl; n.viewport(0, 0, this._targetTexture.width, this._targetTexture.height), this._program.bind(), this._texture.bind(n.TEXTURE0), this._normalDepthTexture.bind(n.TEXTURE1), this._frameBuffer.bind(n.DRAW_FRAMEBUFFER), this._ndcTriangle.bind(), this._ndcTriangle.draw(), this._ndcTriangle.unbind(), this._frameBuffer.unbind(n.DRAW_FRAMEBUFFER) }, t.prototype.clear = function () { var n = this._context.gl; this._frameBuffer.initialized && this._frameBuffer.clear(n.COLOR_BUFFER_BIT) }, Object.defineProperty(t.prototype, "texture", { set: function (n) { this._texture = n }, enumerable: !0, configurable: !0 }), Object.defineProperty(t.prototype, "normalDepthTexture", { set: function (n) { this._normalDepthTexture = n }, enumerable: !0, configurable: !0 }), Object.defineProperty(t.prototype, "exposure", { set: function (n) { var t = this._context.gl; this._program.bind(), t.uniform1f(this._program.uniform("u_exposure"), n), this._program.unbind() }, enumerable: !0, configurable: !0 }), Object.defineProperty(t.prototype, "targetTexture", { get: function () { return this._targetTexture }, enumerable: !0, configurable: !0 }), Object.defineProperty(t.prototype, "framebuffer", { get: function () { return this._frameBuffer }, enumerable: !0, configurable: !0 }), o([a.Initializable.initialize()], t.prototype, "initialize", null), o([a.Initializable.uninitialize()], t.prototype, "uninitialize", null), o([a.Initializable.assert_initialized()], t.prototype, "update", null), o([a.Initializable.assert_initialized()], t.prototype, "frame", null), t }(a.Initializable); t.PostProcessingPass = u }, function (n, t) { n.exports = "\nprecision lowp float;\n\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else\n    #define varying out\n#endif\n\n\n\n#if __VERSION__ == 100\n    attribute vec2 a_vertex;\n#else\n    layout(location = 0) in vec2 a_vertex;\n#endif\n\n\nvarying vec2 v_uv;\n\n\nvoid main(void)\n{\n    v_uv = a_vertex * 0.5 + 0.5;\n\n    gl_Position = vec4(a_vertex, 0.0, 1.0);\n}\n" }, function (n, t) { n.exports = "\nprecision lowp float;\n\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else \n    #define varying in\n#endif\n\n\nconst float GAMMA = 2.2;\nconst float INV_GAMMA = 1.0 / GAMMA;\n\nvec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n    return vec4(pow(srgbIn.xyz, vec3(GAMMA)), srgbIn.w);\n}\n\nvec3 LINEARtoSRGB(vec3 color)\n{\n    return pow(color, vec3(INV_GAMMA));\n}\n\nvec3 toneMapUncharted2Impl(vec3 color)\n{\n    const float A = 0.15;\n    const float B = 0.50;\n    const float C = 0.10;\n    const float D = 0.20;\n    const float E = 0.02;\n    const float F = 0.30;\n    return ((color*(A*color+C*B)+D*E)/(color*(A*color+B)+D*F))-E/F;\n}\n\n// Uncharted 2 tone mapping\n// see: http://filmicworlds.com/blog/filmic-tonemapping-operators/\nvec3 toneMapUncharted(vec3 color)\n{\n    const float W = 11.2;\n    color = toneMapUncharted2Impl(color * 2.0);\n    vec3 whiteScale = 1.0 / toneMapUncharted2Impl(vec3(W));\n    return LINEARtoSRGB(color * whiteScale);\n}\n\n// see: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 toneMapACES(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);\n}\n\n\n#if __VERSION__ == 100\n    #define fragColor gl_FragColor\n#else\n    layout(location = 0) out vec4 fragColor;\n#endif\n\nuniform sampler2D u_texture;\nuniform sampler2D u_normalDepth;\n\nuniform float u_exposure;\n\nvarying vec2 v_uv;\n\n// Edge-Avoiding TrousWavelet Transform for denoising\n// see https://www.shadertoy.com/view/ldKBzG\nvec3 denoise() {\n    const float denoiseStrength = 1.0;\n\n    vec2 offset[25];\n    offset[0] = vec2(-2,-2);\n    offset[1] = vec2(-1,-2);\n    offset[2] = vec2(0,-2);\n    offset[3] = vec2(1,-2);\n    offset[4] = vec2(2,-2);\n\n    offset[5] = vec2(-2,-1);\n    offset[6] = vec2(-1,-1);\n    offset[7] = vec2(0,-1);\n    offset[8] = vec2(1,-1);\n    offset[9] = vec2(2,-1);\n\n    offset[10] = vec2(-2,0);\n    offset[11] = vec2(-1,0);\n    offset[12] = vec2(0,0);\n    offset[13] = vec2(1,0);\n    offset[14] = vec2(2,0);\n\n    offset[15] = vec2(-2,1);\n    offset[16] = vec2(-1,1);\n    offset[17] = vec2(0,1);\n    offset[18] = vec2(1,1);\n    offset[19] = vec2(2,1);\n\n    offset[20] = vec2(-2,2);\n    offset[21] = vec2(-1,2);\n    offset[22] = vec2(0,2);\n    offset[23] = vec2(1,2);\n    offset[24] = vec2(2,2);\n\n    float kernel[25];\n    kernel[0] = 1.0f/256.0f;\n    kernel[1] = 1.0f/64.0f;\n    kernel[2] = 3.0f/128.0f;\n    kernel[3] = 1.0f/64.0f;\n    kernel[4] = 1.0f/256.0f;\n\n    kernel[5] = 1.0f/64.0f;\n    kernel[6] = 1.0f/16.0f;\n    kernel[7] = 3.0f/32.0f;\n    kernel[8] = 1.0f/16.0f;\n    kernel[9] = 1.0f/64.0f;\n\n    kernel[10] = 3.0f/128.0f;\n    kernel[11] = 3.0f/32.0f;\n    kernel[12] = 9.0f/64.0f;\n    kernel[13] = 3.0f/32.0f;\n    kernel[14] = 3.0f/128.0f;\n\n    kernel[15] = 1.0f/64.0f;\n    kernel[16] = 1.0f/16.0f;\n    kernel[17] = 3.0f/32.0f;\n    kernel[18] = 1.0f/16.0f;\n    kernel[19] = 1.0f/64.0f;\n\n    kernel[20] = 1.0f/256.0f;\n    kernel[21] = 1.0f/64.0f;\n    kernel[22] = 3.0f/128.0f;\n    kernel[23] = 1.0f/64.0f;\n    kernel[24] = 1.0f/256.0f;\n\n    vec3 sum = vec3(0.0);\n    float c_phi = 1.0;\n    float n_phi = 0.5;\n\tvec3 cval = texture(u_texture, v_uv).rgb;\n\tvec3 nval = texture(u_normalDepth, v_uv).rgb;\n\n    vec2 texSize = vec2(textureSize(u_texture, 0));\n\n    float cum_w = 0.0;\n    for (int i = 0; i < 25; i++)\n    {\n        vec2 uv = v_uv + (offset[i] / texSize) * denoiseStrength;\n\n        vec3 ctmp = texture(u_texture, uv).rgb;\n        vec3 t = cval - ctmp;\n        float dist2 = dot(t, t);\n        float c_w = min(exp(-(dist2) / c_phi), 1.0);\n\n        vec3 ntmp = texture(u_normalDepth, uv).rgb;\n        t = nval - ntmp;\n        dist2 = max(dot(t,t), 0.0);\n        float n_w = min(exp(-(dist2) / n_phi), 1.0);\n\n        float weight = c_w * n_w;\n        sum += ctmp * weight * kernel[i];\n        cum_w += weight * kernel[i];\n    }\n\n    return sum / cum_w;\n}\n\nvoid main(void)\n{\n    vec3 inputColor = texture(u_texture, v_uv).rgb;\n    // vec3 inputColor = denoise();\n\n    fragColor = vec4(toneMapUncharted(inputColor * u_exposure), 1.0);\n}\n" }, function (n, t, e) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }); var r = function () { function n(n, t, e, r) { this._uri = n, this._camera = t, this._camera.near = e, this._camera.far = r, this._sphereLights = new Array, this._diskLights = new Array } return n.prototype.addSphereLight = function (n) { this._sphereLights.push(n) }, n.prototype.addDiskLight = function (n) { this._diskLights.push(n) }, Object.defineProperty(n.prototype, "uri", { get: function () { return this._uri }, enumerable: !0, configurable: !0 }), Object.defineProperty(n.prototype, "camera", { get: function () { return this._camera }, enumerable: !0, configurable: !0 }), Object.defineProperty(n.prototype, "sphereLights", { get: function () { return this._sphereLights }, enumerable: !0, configurable: !0 }), Object.defineProperty(n.prototype, "diskLights", { get: function () { return this._diskLights }, enumerable: !0, configurable: !0 }), n }(); t.Scene = r }, function (n, t, e) { "use strict"; var r, i = this && this.__extends || (r = function (n, t) { return (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (n, t) { n.__proto__ = t } || function (n, t) { for (var e in t) t.hasOwnProperty(e) && (n[e] = t[e]) })(n, t) }, function (n, t) { function e() { this.constructor = n } r(n, t), n.prototype = null === t ? Object.create(t) : (e.prototype = t.prototype, new e) }); Object.defineProperty(t, "__esModule", { value: !0 }); var o = e(0), a = function (n) { function t() { return null !== n && n.apply(this, arguments) || this } return i(t, n), t.prototype.showSpinner = function () { document.getElementsByClassName("spinner").item(0).style.display = "inline" }, t.prototype.hideSpinner = function () { document.getElementsByClassName("spinner").item(0).style.display = "none" }, t.prototype.initialize = function (n) { var t = this, e = this.onInitialize(n); return this.renderer.loadingStatus$.subscribe((function (n) { n === o.LoadingStatus.Finished ? t.hideSpinner() : n === o.LoadingStatus.Started && t.showSpinner() })), e }, t.prototype.uninitialize = function () { this.onUninitialize() }, t.prototype.enableFullscreenOnCtrlClick = function () { var n = this.canvas.element; n.addEventListener("click", (function (t) { t.ctrlKey && o.viewer.Fullscreen.toggle(n) })) }, t }(o.Initializable); t.Demo = a }, function (n, t, e) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }); var r = function (n, t, e) { this.center = n, this.radius = t, this.luminance = e }; t.SphereLight = r; var i = function (n, t, e, r, i) { this.center = n, this.radius = t, this.luminance = e, this.direction = r, this.fovy = i }; t.DiskLight = i }, function (n, t, e) { "use strict"; var r, i = this && this.__extends || (r = function (n, t) { return (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (n, t) { n.__proto__ = t } || function (n, t) { for (var e in t) t.hasOwnProperty(e) && (n[e] = t[e]) })(n, t) }, function (n, t) { function e() { this.constructor = n } r(n, t), n.prototype = null === t ? Object.create(t) : (e.prototype = t.prototype, new e) }); Object.defineProperty(t, "__esModule", { value: !0 }); var o = e(0), a = e(0), u = function (n) { function t(t) { var e = n.call(this, 2, t) || this; return e.generate(), e } return i(t, n), t.prototype.generate = function () { o.auxiliaries.assert(this.width > 0, "expected every kernel to comprise at least one element"), this.set([0, 0], 0); for (var n = 1; n < this.width; ++n)this.set([o.auxiliaries.rand(-1, 1), o.auxiliaries.rand(-1, 1)], n); this.sort(a.AbstractKernel.SortApproach.BySquaredLength) }, Object.defineProperty(t.prototype, "width", { get: function () { return this._width }, set: function (n) { this._width !== n && (this._width = n, this.resize(), this.generate()) }, enumerable: !0, configurable: !0 }), t }(a.KernelF32); t.DepthOfFieldKernel = u }, function (n, t, e) { "use strict"; var r, i = this && this.__extends || (r = function (n, t) { return (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (n, t) { n.__proto__ = t } || function (n, t) { for (var e in t) t.hasOwnProperty(e) && (n[e] = t[e]) })(n, t) }, function (n, t) { function e() { this.constructor = n } r(n, t), n.prototype = null === t ? Object.create(t) : (e.prototype = t.prototype, new e) }); Object.defineProperty(t, "__esModule", { value: !0 }); var o = e(0), a = e(2), u = e(13), s = function (n) { this.factor = n }; t.Sample = s; var c = function (n) { function t() { return null !== n && n.apply(this, arguments) || this } return i(t, n), t }(s); t.DiffuseEnvironmentSample = c; var l = function (n) { function t() { return null !== n && n.apply(this, arguments) || this } return i(t, n), t }(s); t.SpecularEnvironmentSample = l; var f = function (n) { function t(t, e, r) { var i = n.call(this, t) || this; return i.lightIndex = e, i.eye = r, i } return i(t, n), t }(s); t.LightSample = f; var h = function () { function n(n, t, e, r) { this._currentFrame = 0, this._scene = n, this._multiframeNumber = t, this._lightSampleCount = e, this._environmentSampleCount = r, o.auxiliaries.assert(e * this._scene.diskLights.length <= t, "Total number of light samples can not be higher than multiframe count."), this._lightQueue = new Array, this._environmentQueue = new Array, this.generateSampleQueue() } return n.prototype.allEmpty = function (n) { for (var t = !0, e = 0, r = n; e < r.length; e++) { if (r[e].length > 0) { t = !1; break } } return t }, n.prototype.mergeArrays = function (n) { for (var t = new Array; !this.allEmpty(n);)for (var e = 0, r = n; e < r.length; e++) { var i = r[e]; i.length > 0 && t.push(i.shift()) } return t }, n.prototype.distributeSamples = function (n, t, e, r) { for (var i = (r - e) / n.length, a = e, u = 0, s = n; u < s.length; u++) { var c = s[u], l = Math.floor(a); o.auxiliaries.assert(l < t.length, "Index " + l + " is out of bounds while distributing light samples."), t[l].push(c), a += i } }, n.prototype.generateSampleQueue = function () { for (var n = Math.round(this._environmentSampleCount / 2), t = this._multiframeNumber / n, e = this._environmentSampleCount - n, r = this._multiframeNumber / e, i = this._multiframeNumber / this._lightSampleCount, o = [], s = [], h = 0; h < n; ++h)o.push(new c(t)); for (h = 0; h < e; ++h)s.push(new l(r)); this._environmentQueue = this.mergeArrays([o, s]); for (var d = [], m = 0, p = 0, v = this._scene.diskLights; p < v.length; p++) { var _ = v[p], g = new u.ShadowKernel(this._lightSampleCount, _), b = []; for (h = 0; h < this._lightSampleCount; ++h) { var M = g.get(h); b.push(new f(i, m, a.vec3.fromValues(M[0], M[1], M[2]))) } d.push(b), m++ } this._lightQueue = this.mergeArrays(d), this._perFrameSamples = []; for (h = 0; h < this._multiframeNumber; ++h)this._perFrameSamples.push([]); this.distributeSamples(this._lightQueue, this._perFrameSamples, Math.round(.3 * this._multiframeNumber), this._multiframeNumber - 1), this.distributeSamples(this._environmentQueue, this._perFrameSamples, 0, this._multiframeNumber - 1) }, n.prototype.getNextFrameSamples = function () { o.auxiliaries.assert(this._currentFrame < this._multiframeNumber, "Samples can only be generated during a multiframe."); var n = this._perFrameSamples[this._currentFrame]; return this._currentFrame++, n }, n }(); t.SampleManager = h }, function (n, t, e) { "use strict"; var r, i = this && this.__extends || (r = function (n, t) { return (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (n, t) { n.__proto__ = t } || function (n, t) { for (var e in t) t.hasOwnProperty(e) && (n[e] = t[e]) })(n, t) }, function (n, t) { function e() { this.constructor = n } r(n, t), n.prototype = null === t ? Object.create(t) : (e.prototype = t.prototype, new e) }); Object.defineProperty(t, "__esModule", { value: !0 }); var o = e(0), a = e(2), u = e(0), s = function (n) { function t(t, e) { var r = n.call(this, 3, t) || this; return r._diskLight = e, r.generate(), r } return i(t, n), t.prototype.generate = function () { o.auxiliaries.assert(this.width > 0, "expected every kernel to comprise at least one element"); var n = this._diskLight.center; this.set([n[0], n[1], n[2]], 0); for (var t = 1; t < this.width; ++t) { var e = a.vec3.random(a.vec3.create(), this._diskLight.radius), r = a.vec3.add(a.vec3.create(), n, e); this.set([r[0], r[1], r[2]], t) } this.sort(u.AbstractKernel.SortApproach.BySquaredLength) }, Object.defineProperty(t.prototype, "width", { get: function () { return this._width }, set: function (n) { this._width !== n && (this._width = n, this.resize(), this.generate()) }, enumerable: !0, configurable: !0 }), t }(u.KernelF32); t.ShadowKernel = s }, function (n, t) { n.exports = 'precision highp float;\n\n// Adapted from https://github.com/KhronosGroup/glTF-WebGL-PBR\n// References:\n// [1] Real Shading in Unreal Engine 4\n//     http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n// [2] Physically Based Shading at Disney\n//     http://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf\n// [3] README.md - Environment Maps\n//     https://github.com/KhronosGroup/glTF-WebGL-PBR/#environment-maps\n// [4] "An Inexpensive BRDF Model for Physically based Rendering" by Christophe Schlick\n//     https://www.cs.virginia.edu/~jdl/bib/appearance/analytic%20models/schlick94b.pdf\n\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else \n    #define varying in\n#endif\n\n#line 1\n\n\n#undef M_PI\n#define M_PI 3.14159265359\n\n// Adapted from "Moving Frostbite to PBR"\nvec3 uniformSampleSphere(const in float u1, const in float u2)\n{\n    float phi = 2.0 * M_PI * u2;\n    float cosTheta = 1.0 - 2.0 * u1;\n    float sinTheta = sqrt(max (0.0, 1.0 - cosTheta * cosTheta));\n\n    return vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n}\n\n// Adapted from "Moving Frostbite to PBR"\nvec3 uniformSampleHemisphere(const in float u1, const in float u2)\n{\n    float phi = 2.0 * M_PI * u2;\n    float cosTheta = 1.0 - u1;\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\n    return vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n}\n\n// Adapted from "Moving Frostbite to PBR"\nvec3 cosineSampleHemisphere(const in float u1, const in float u2)\n{\n    float phi = 2.0 * M_PI * u2;\n    float cosTheta = sqrt(1.0 - u1);\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\n    return vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n}\n\n// Adapted from "Real Shading in Unreal Engine 4"\nvec3 importanceSampleGGX(const in vec2 Xi, const in float alphaRoughnessSq)\n{\n    float Phi = 2.0 * M_PI * Xi.x;\n    float CosTheta = sqrt((1.0 - Xi.y) / (1.0 + (alphaRoughnessSq - 1.0) * Xi.y));\n    float SinTheta = sqrt(1.0 - CosTheta * CosTheta);\n\n    return vec3(SinTheta * cos(Phi), SinTheta * sin(Phi), CosTheta);\n}\n\n// Calculate intersection between a ray and a sphere\n// Returns only the closest distance of the two intersections if there are two\n// Adapted from https://gist.github.com/wwwtyro/beecc31d65d1004f5a9d\nfloat raySphereIntersect(const in vec3 r0, const in vec3 rd, const in vec3 s0, const in float sr, out bool hit)\n{\n    // - r0: ray origin\n    // - rd: normalized ray direction\n    // - s0: sphere center\n    // - sr: sphere radius\n    // - Returns distance from r0 to first intersecion with sphere,\n    //   or -1.0 if no intersection.\n    float a = dot(rd, rd);\n    vec3 s0_r0 = r0 - s0;\n    float b = 2.0 * dot(rd, s0_r0);\n    float c = dot(s0_r0, s0_r0) - (sr * sr);\n    if (b * b - 4.0 * a * c < 0.0) {\n        hit = false;\n    }\n\n    hit = true;\n    return (-b - sqrt((b * b) - 4.0 * a * c))/(2.0 * a);\n}\n\n// Returns pseudo-random number within [0,1]\nfloat rand(const in vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Fast calculation of the Van Der Corpus sequence using bitshifting magic\n// See https://learnopengl.com/PBR/IBL/Specular-IBL\nfloat radicalInverse_VdC(in uint bits)\n{\n    bits = (bits << 16u) | (bits >> 16u);\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n\n// Returns 2D points according to the quasirandom Hammersley distribution\nvec2 hammersley(const in uint i, const in uint N)\n{\n    return vec2(float(i)/float(N), radicalInverse_VdC(i));\n}\n\n// Returns 2D points according to the quasirandom Weyl distribution\nvec2 weyl(const in int n) { // borrowed from https://www.shadertoy.com/view/3lsXW2\n    return fract(vec2(n*12664745, n*9560333)/exp2(24.));\n}\n\n#line 1\n\n// PBR implementation adapted from https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/master/src/shaders/metallic-roughness.frag\n// commit 6f1fb2d\n\n// References:\n// [1] Real Shading in Unreal Engine 4\n//     http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n// [2] Physically Based Shading at Disney\n//     http://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf\n// [3] README.md - Environment Maps\n//     https://github.com/KhronosGroup/glTF-WebGL-PBR/#environment-maps\n// [4] "An Inexpensive BRDF Model for Physically based Rendering" by Christophe Schlick\n//     https://www.cs.virginia.edu/~jdl/bib/appearance/analytic%20models/schlick94b.pdf\n\n#undef M_PI\n#define M_PI 3.14159265359\n\nstruct LightingInfo {\n    vec3 incidentPosition;\n    vec3 incidentNormal;\n    vec3 view;\n    vec2 uv;\n\n    vec3 diffuseColor;\n    vec3 specularColor;\n    vec3 reflectance0;\n    vec3 reflectance90;\n    float perceptualRoughness;\n    float alphaRoughness;\n    float alphaRoughnessSq;\n};\n\n// The following equation models the Fresnel reflectance term of the spec equation (aka F())\n// Implementation of fresnel from [4], Equation 15\nvec3 specularReflection(const in vec3 reflectance0, const in vec3 reflectance90, const in float VdotH)\n{\n    return reflectance0 + (reflectance90 - reflectance0) * pow(clamp(1.0 - VdotH, 0.0, 1.0), 5.0);\n}\n\n// Smith Joint GGX\n// Note: Vis = G / (4 * NdotL * NdotV)\n// see Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs. Journal of Computer Graphics Techniques, 3\n// see Real-Time Rendering. Page 331 to 336.\n// see https://google.github.io/filament/Filament.md.html#materialsystem/specularbrdf/geometricshadowing(specularg)\nfloat visibilityOcclusion(const in float alphaRoughnessSq, const in float NdotL, const in float NdotV)\n{\n    float GGXV = NdotL * sqrt(NdotV * NdotV * (1.0 - alphaRoughnessSq) + alphaRoughnessSq);\n    float GGXL = NdotV * sqrt(NdotL * NdotL * (1.0 - alphaRoughnessSq) + alphaRoughnessSq);\n\n    float GGX = GGXV + GGXL;\n    if (GGX > 0.0)\n    {\n        return 0.5 / GGX;\n    }\n    return 0.0;\n}\n\n// The following equation(s) model the distribution of microfacet normals across the area being drawn (aka D())\n// Implementation from "Average Irregularity Representation of a Roughened Surface for Ray Reflection" by T. S. Trowbridge, and K. P. Reitz\n// Follows the distribution function recommended in the SIGGRAPH 2013 course notes from EPIC Games [1], Equation 3.\nfloat microfacetDistribution(const in float alphaRoughnessSq, const in float NdotH)\n{\n    float f = (NdotH * alphaRoughnessSq - NdotH) * NdotH + 1.0;\n    return alphaRoughnessSq / (M_PI * f * f);\n}\n\nvec3 diffuseBrdf(const in LightingInfo info)\n{\n    return info.diffuseColor / M_PI;\n}\n\nvec3 specularBrdfGGX(const in vec3 L, const in LightingInfo info, const in float D_normalization)\n{\n    vec3 H = normalize(info.view + L);\n\n    float VdotH = clamp(dot(info.view, H), 0.0, 1.0);\n    float NdotL = clamp(dot(info.incidentNormal, L), 0.0, 1.0);\n    float NdotV = clamp(dot(info.incidentNormal, info.view), 0.0, 1.0);\n    float NdotH = clamp(dot(info.incidentNormal, H), 0.0, 1.0);\n\n    if (NdotL < 0.0 && NdotV < 0.0) {\n        return vec3(0.0);\n    }\n\n    // Fix numerical issues in the microfacet distribution when alphaRoughnessSq is very close to 0\n    // This still introduces some error but fixes values approching infinity, which mess up the whole calculation\n    float clampedAlphaRoughness = clamp(info.alphaRoughnessSq, 0.0000001, 1.0);\n\n    vec3 F = specularReflection(info.reflectance0, info.reflectance90, VdotH);\n    float Vis = visibilityOcclusion(info.alphaRoughnessSq, NdotL, NdotV);\n    float D = microfacetDistribution(clampedAlphaRoughness, NdotH) * D_normalization;\n\n    return F * Vis * D;\n}\n\n// Importance sampling with GGX introduces the pdf: D * NdotH / (4.0 * VdotH), therefore D cancels out\n// The division by NdotH / (4.0 * VdotH) still has to be applied where this function is used\nvec3 specularBrdfGGXImportanceSampled(const in vec3 L, const in LightingInfo info)\n{\n    vec3 H = normalize(info.view + L);\n\n    float VdotH = clamp(dot(info.view, H), 0.0, 1.0);\n    float NdotL = clamp(dot(info.incidentNormal, L), 0.0, 1.0);\n    float NdotV = clamp(dot(info.incidentNormal, info.view), 0.0, 1.0);\n    float NdotH = clamp(dot(info.incidentNormal, H), 0.0, 1.0);\n\n    if (NdotL < 0.0 && NdotV < 0.0) {\n        return vec3(0.0);\n    }\n\n    vec3 F = specularReflection(info.reflectance0, info.reflectance90, VdotH);\n    float Vis = visibilityOcclusion(info.alphaRoughnessSq, NdotL, NdotV);\n\n    return F * Vis;\n}\n\n\nstruct SphereLight {\n    vec3 center;\n    float radius;\n    vec3 luminance;\n};\n\nstruct DiskLight {\n    vec3 center;\n    vec3 direction;\n    float radius;\n    vec3 luminance;\n};\n\n// This function uses Monte Carlo integration to calculate the lighting of spherical light source.\n// The rays are generated uniformly over the area of the light source.\n// This can be used to generate a ground truth image or as part of a Multiple Importance Sampling (MIS) approach.\nvec3 sphereLightBruteForce(const in SphereLight light, const in LightingInfo info)\n{\n    const int SAMPLE_COUNT = 16;\n\n    vec3 lightAccumulator = vec3(0.0);\n\n    float sphereArea = 4.0 * M_PI * light.radius * light.radius;\n    float pdf = 1.0 / sphereArea;\n\n    for (int i = 0; i < SAMPLE_COUNT; ++i) {\n        vec2 u = weyl(int(info.uv.x * info.uv.y * 4324231.8) + i);\n        // vec2 u = hammersley(uint(i), uint(SAMPLE_COUNT - 1));\n        // vec2 u = vec2(rand(v_uv + vec2(float(i))), rand(v_uv + vec2(float(i * 3))));\n\n        vec3 sphereNormal = uniformSampleSphere(u.x, u.y);\n\n        vec3 spherePosition = sphereNormal * light.radius + light.center;\n        vec3 lightVector = spherePosition - info.incidentPosition;\n        float sqDist = dot(lightVector, lightVector);\n        vec3 L = normalize(lightVector);\n\n        // turn this from an area integral to a solid angle integral\n        float lightPdf = pdf * sqDist / clamp(dot(sphereNormal, -L), 0.0, 1.0);\n        vec3 L_i = light.luminance; // incoming lumincance from light source (unit: cd / m^2)\n        vec3 integralSample = L_i / lightPdf;\n\n        float NdotL = clamp(dot(L, info.incidentNormal), 0.0, 1.0);\n\n        vec3 diffuse = diffuseBrdf(info);\n        vec3 specular = specularBrdfGGX(L, info, 1.0);\n        lightAccumulator += (diffuse + specular) * integralSample * NdotL;\n    }\n\n    return lightAccumulator / float(SAMPLE_COUNT);\n}\n\n// Fast approximation using (radius^2 / distance^2) * NdotL\n// This formula does not have proper horizon handling but is cheap to evaluate\n// See "Moving Frostbite to PBR" p.44\nvec3 diffuseSphereLightApproximated(const in SphereLight light, const in LightingInfo info)\n{\n    vec3 Lunormalized = light.center - info.incidentPosition;\n    vec3 L = normalize(Lunormalized);\n    float sqrDist = dot(Lunormalized, Lunormalized);\n\n    float sqrLightRadius = light.radius * light.radius;\n    float illuminance = M_PI * (sqrLightRadius / (max(sqrLightRadius, sqrDist))) * clamp(dot(info.incidentNormal, L), 0.0, 1.0);\n\n    float NdotL = clamp(dot(L, info.incidentNormal), 0.0, 1.0);\n\n    return diffuseBrdf(info) * light.luminance * illuminance * NdotL;\n}\n\nvec3 diffuseDiskLightApproximated(const in DiskLight light, const in LightingInfo info)\n{\n    vec3 Lunormalized = light.center - info.incidentPosition;\n    vec3 L = normalize(Lunormalized);\n\n    SphereLight sphereLight = SphereLight(light.center, light.radius, light.luminance);\n    float diskFactor = smoothstep(-0.1, 0.1, -dot(L, light.direction));\n    return diffuseSphereLightApproximated(sphereLight, info) * diskFactor;\n}\n\n// This function uses Monte Carlo importance sampling to evaluate a spherical light source.\n// By generating more rays towards the BRDF lobe, shiny materials are rendered with lower variance\n// However, for diffuse materials the variance may increase\n// This can be used alongside sampling a towards light source by using Multiple Importance Sampling (MIS)\n// vec3 specularSphereLightImportanceSampleGGX(SphereLight light, LightingInfo info)\n// {\n//     const int SAMPLE_COUNT = 16;\n\n//     vec3 lightAccumulator = vec3(0.0);\n\n//     float sphereArea = 4.0 * M_PI * light.radius * light.radius;\n\n//     for (int i = 0; i < SAMPLE_COUNT; ++i) {\n//         vec2 u = weyl(int(info.uv.x * info.uv.y * 4324231.8) + i);\n//         // vec2 u = hammersley(uint(i), uint(SAMPLE_COUNT));\n//         // vec2 u = vec2(rand(v_uv + vec2(float(i))), rand(v_uv + vec2(float(i * 3))));\n\n//         vec3 H = importanceSampleGGX(u, info.alphaRoughnessSq, info.incidentNormal);\n\n//         vec3 sampleDir = reflect(info.view, H);\n\n//         bool hit;\n//         float t = raySphereIntersect(info.incidentPosition, sampleDir, light.center, light.radius, hit);\n\n//         if (!hit || t >= 0.0) continue;\n\n//         float NdotH = clamp(dot(info.incidentNormal, H), 0.0, 1.0);\n//         float VdotH = clamp(dot(info.view, H), 0.0, 1.0);\n\n//         // Math behind calculating the pdf: https://schuttejoe.github.io/post/ggximportancesamplingpart1/\n//         // Note that the D term is not included since it cancels out with the BRDF\n//         float pdf = NdotH / (4.0 * VdotH);\n\n//         vec3 spherePosition = info.incidentPosition + t * sampleDir;\n//         vec3 sphereNormal = normalize(spherePosition - light.center);\n\n//         vec3 lightVector = spherePosition - info.incidentPosition;\n//         float sqDist = dot(lightVector, lightVector);\n//         vec3 L = normalize(lightVector);\n\n//         vec3 L_i = light.luminance; // incoming radiance from light source (unit: W / sr*m^2)\n//         vec3 integralSample = L_i / pdf;\n\n//         float NdotL = clamp(dot(L, info.incidentNormal), 0.0, 1.0);\n\n//         lightAccumulator += specularBrdfGGXImportanceSampled(L, info) * integralSample * NdotL;\n//     }\n\n//     return lightAccumulator / float(SAMPLE_COUNT);\n// }\n\n// This function approximates a spherical area light by using a "Most Representative Point", which is treated as a point light.\n// This approach does not have proper energy conservation, however Karis gives an approximate normalization factor for the NDF.\n// See "Real Shading in Unreal Engine 4"\nvec3 specularSphereLightKaris(const in SphereLight light, const in LightingInfo info)\n{\n    float sphereArea = 4.0 * M_PI * light.radius * light.radius;\n\n    vec3 R = reflect(info.view, info.incidentNormal);\n    vec3 L_center = light.center - info.incidentPosition;\n    vec3 centerToRay = dot(L_center, R) * R - L_center;\n    vec3 closestPoint = L_center + centerToRay * clamp(light.radius / length(centerToRay), 0.0, 1.0);\n    vec3 L = normalize(closestPoint);\n    float sqDist = max(dot(closestPoint, closestPoint), 0.1);\n\n    // To approximate the area light source as a point light source, we need to convert from luminance (cd/m^2) to luminous power (lm)\n    // We multiply by PI to get lm / m^2 (since we assume a lambertian light source and the integral of cos over hemisphere sums to PI)\n    // Then we multiply by area to get lm\n    vec3 lightPower = M_PI * sphereArea * light.luminance;\n    // Estimate the irradiance from total light power\n    // Note: this formula is an approximation that assumes the light source is a point light at the newly calculated light position\n    vec3 irradiance = lightPower / (4.0 * M_PI * sqDist);\n\n    // This normalization factor given by Karis should be used to scale the NDF\n    float normalization = info.alphaRoughness / (info.alphaRoughness + light.radius / (2.0 * sqrt(sqDist)));\n    normalization = normalization * normalization;\n\n    float NdotL = clamp(dot(L, info.incidentNormal), 0.0, 1.0);\n\n    return specularBrdfGGX(L, info, normalization) * irradiance * NdotL;\n}\n\nvec3 specularDiskLightKaris(const in DiskLight light, const in LightingInfo info) {\n    vec3 Lunormalized = light.center - info.incidentPosition;\n    vec3 L = normalize(Lunormalized);\n\n    SphereLight sphereLight = SphereLight(light.center, light.radius, light.luminance);\n    float diskFactor = smoothstep(-0.1, 0.1, -dot(L, light.direction));\n    return specularSphereLightKaris(sphereLight, info) * diskFactor;\n}\n\n\nconst float GAMMA = 2.2;\nconst float INV_GAMMA = 1.0 / GAMMA;\n\nvec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n    return vec4(pow(srgbIn.xyz, vec3(GAMMA)), srgbIn.w);\n}\n\nvec3 LINEARtoSRGB(vec3 color)\n{\n    return pow(color, vec3(INV_GAMMA));\n}\n\nvec3 toneMapUncharted2Impl(vec3 color)\n{\n    const float A = 0.15;\n    const float B = 0.50;\n    const float C = 0.10;\n    const float D = 0.20;\n    const float E = 0.02;\n    const float F = 0.30;\n    return ((color*(A*color+C*B)+D*E)/(color*(A*color+B)+D*F))-E/F;\n}\n\n// Uncharted 2 tone mapping\n// see: http://filmicworlds.com/blog/filmic-tonemapping-operators/\nvec3 toneMapUncharted(vec3 color)\n{\n    const float W = 11.2;\n    color = toneMapUncharted2Impl(color * 2.0);\n    vec3 whiteScale = 1.0 / toneMapUncharted2Impl(vec3(W));\n    return LINEARtoSRGB(color * whiteScale);\n}\n\n// see: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 toneMapACES(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);\n}\n\n\nvec2 SMCoordinates(vec4 worldPosition, mat4 shadowViewProjection)\n{\n    vec4 transformed = shadowViewProjection * worldPosition;\n    return transformed.xy / transformed.w * 0.5 + 0.5;\n}\n\nfloat SMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar)\n{\n    return (distance(worldPosition, lightPosition) - lightNearFar.x) / (lightNearFar.y - lightNearFar.x);\n}\n\nfloat SMCompare(sampler2D depths, vec2 uv, float compare, float offset)\n{\n    float depth = texture(depths, uv).r;\n    return step(compare + offset, depth);\n}\n\nvec2 VSMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar)\n{\n    float depth = SMDepth(worldPosition, lightPosition, lightNearFar);\n\n    vec2 df = vec2(dFdx(depth), dFdy(depth));\n    float moment = depth * depth + 0.25 * dot(df, df);\n\n    return vec2(depth, moment);\n}\n\nfloat chebyshevUpperBound(vec2 moments, float compare, float minVariance, float lightBleedingReduction)\n{\n    float p = 0.0;\n\n    // Surface is fully lit, as the current fragment is before the light occluder\n    if (compare <= moments.x)\n        p = 1.0;\n\n    // The fragment is either in shadow or penumbra. We now use chebyshev\'s upperBound to check\n    // How likely this pixel is to be lit (p_max)\n    float variance = moments.y - (moments.x * moments.x);\n    variance = max(variance, minVariance);\n\n    float d = compare - moments.x;\n    float p_max = variance / (variance + d*d);\n\n    // Correct light bleeding\n    p_max = smoothstep(lightBleedingReduction, 1.0, p_max);\n\n    return max(p, p_max);\n}\n\nfloat VSMCompare(sampler2D depths, vec2 uv, float compare, float minVariance, float lightBleedingReduction)\n{\n    vec2 moments = texture(depths, uv).rg;\n    return chebyshevUpperBound(moments, compare, minVariance, lightBleedingReduction);\n}\n\nfloat ESMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar, float exponent)\n{\n    float depth = SMDepth(worldPosition, lightPosition, lightNearFar);\n    return exp(exponent * depth);\n}\n\nfloat ESMCompare(sampler2D depths, vec2 uv, float compare, float exponent)\n{\n    float expDepth = texture(depths, uv).r;\n    return clamp(expDepth * exp(-exponent  * compare), 0.0, 1.0);\n}\n\nvec2 EVSMWarpDepth(float depth, vec2 exponents)\n{\n    depth = depth * 2.0 - 1.0;\n    float pos =  exp( exponents.x * depth);\n    float neg = -exp(-exponents.y * depth);\n    return vec2(pos, neg);\n}\n\nvec4 EVSMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar, vec2 exponents)\n{\n    float depth = SMDepth(worldPosition, lightPosition, lightNearFar);\n    vec2 warpedDepth = EVSMWarpDepth(depth, exponents);\n    return vec4(warpedDepth, warpedDepth * warpedDepth);\n}\n\nfloat EVSMCompare(sampler2D depths, vec2 uv, float compare, vec2 exponents, float lightBleedingReduction)\n{\n    vec4 moments = texture(depths, uv);\n    vec2 warpedCompare = EVSMWarpDepth(compare, exponents);\n    vec2 depthScale = 0.0001 * exponents * warpedCompare;\n    vec2 minVariance = depthScale * depthScale;\n    return min(\n        chebyshevUpperBound(moments.xz, warpedCompare.x, minVariance.x, lightBleedingReduction),\n        chebyshevUpperBound(moments.yw, warpedCompare.y, minVariance.y, lightBleedingReduction)\n    );\n}\n\n// vec4 calculateShadowColor(vec4 objectColor, float visibility, float intensity, vec4 shadowColor, float colorIntensity)\n// {\n//   visibility = min(visibility + (1.0 - intensity) * (1.0 - visibility), 1.0);\n\n//   vec4 finalColor = vec4(visibility * objectColor.rgb, objectColor.a);\n//   if (visibility < 1.0)\n//   {\n//     finalColor = clamp(shadowColor * colorIntensity + finalColor, finalColor, objectColor);\n//   }\n\n//   return finalColor;\n// }\n\n\n#line 17\n\n#if __VERSION__ == 100\n    #define fragColor gl_FragColor\n#else\n    layout(location = 0) out vec4 fragColor;\n#endif\n\nconst int HAS_NORMALS           = 1;\nconst int HAS_TANGENTS          = 1 << 1;\nconst int HAS_UV                = 1 << 2;\nconst int HAS_COLORS            = 1 << 3;\nconst int USE_IBL               = 1 << 4;\nconst int HAS_BASECOLORMAP      = 1 << 5;\nconst int HAS_NORMALMAP         = 1 << 6;\nconst int HAS_EMISSIVEMAP       = 1 << 7;\nconst int HAS_METALROUGHNESSMAP = 1 << 8;\nconst int HAS_OCCLUSIONMAP      = 1 << 9;\nconst int USE_TEX_LOD           = 1 << 10;\n\nconst float c_MinRoughness = 0.04;\n\nuniform sampler2D u_baseColor;\nuniform sampler2D u_metallicRoughness;\nuniform sampler2D u_normal;\nuniform sampler2D u_emissive;\nuniform sampler2D u_occlusion;\n\nuniform samplerCube u_diffuseEnvironment;\nuniform samplerCube u_specularEnvironment;\nuniform sampler2D u_brdfLUT;\nuniform sampler2D u_shadowMap;\nuniform sampler2D u_lastFrame;\nuniform sampler2D u_normalDepth;\n\n#define MAX_LIGHTS 6\nuniform int u_numDiskLights;\nuniform DiskLight u_diskLights[MAX_LIGHTS];\n\nuniform int u_lightSampleIndex;\nuniform float u_lightFactor;\nuniform int u_numDiffuseEnvironmentSamples;\nuniform float u_diffuseEnvironmentFactor;\nuniform int u_numSpecularEnvironmentSamples;\nuniform float u_specularEnvironmentFactor;\n\nuniform int u_baseColorTexCoord;\nuniform int u_normalTexCoord;\nuniform int u_metallicRoughnessTexCoord;\nuniform int u_occlusionTexCoord;\nuniform int u_emissiveTexCoord;\n\nuniform vec4 u_baseColorFactor;\nuniform float u_metallicFactor;\nuniform float u_roughnessFactor;\nuniform vec3 u_emissiveFactor;\nuniform float u_normalScale;\nuniform int u_blendMode;\nuniform float u_blendCutoff;\n\nuniform mediump int u_geometryFlags;\nuniform mediump int u_pbrFlags;\nuniform vec3 u_eye;\nuniform vec2 u_lightNearFar;\nuniform mat4 u_lightView;\nuniform mat4 u_lightProjection;\n\nuniform mat4 u_viewProjection;\nuniform mat4 u_projection;\nuniform mat4 u_view;\nuniform mat3 u_viewNormalMatrix;\nuniform vec2 u_cameraNearFar;\n\nuniform int u_frameNumber;\nuniform int u_debugMode;\nuniform float u_iblStrength;\nuniform float u_occlusionRange;\n\nvarying vec2 v_uv[3];\nvarying vec4 v_color;\nvarying vec3 v_position;\n\nvarying mat3 v_TBN;\nvarying vec3 v_normal;\n\nbool checkGeometryFlag(int flag) {\n    return (u_geometryFlags & flag) == flag;\n}\n\nbool checkFlag(int flag) {\n    return (u_pbrFlags & flag) == flag;\n}\n\n// Find the normal for this fragment, pulling either from a predefined normal map\n// or from the interpolated mesh normal and tangent attributes.\nvec3 getNormal()\n{\n    mat3 TBN;\n    // Retrieve the tangent space matrix\n    if (!checkGeometryFlag(HAS_TANGENTS)) {\n        vec3 pos_dx = dFdx(v_position);\n        vec3 pos_dy = dFdy(v_position);\n        vec3 tex_dx = dFdx(vec3(v_uv[0], 0.0));\n        vec3 tex_dy = dFdy(vec3(v_uv[0], 0.0));\n        vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n        vec3 ng;\n        if (checkGeometryFlag(HAS_NORMALS))\n            ng = normalize(v_normal);\n        else\n            ng = cross(pos_dx, pos_dy);\n\n            t = normalize(t - ng * dot(ng, t));\n            vec3 b = normalize(cross(ng, t));\n            TBN = mat3(t, b, ng);\n        }\n    else { // HAS_TANGENTS\n        TBN = v_TBN;\n    }\n\n    vec3 n;\n    if (checkFlag(HAS_NORMALMAP)) {\n        n = texture(u_normal, v_uv[u_normalTexCoord]).rgb;\n        n = normalize(TBN * ((2.0 * n - 1.0) * vec3(u_normalScale, u_normalScale, 1.0)));\n    } else {\n        // The tbn matrix is linearly interpolated, so we need to re-normalize\n        n = normalize(TBN[2].xyz);\n    }\n\n    // reverse backface normals\n    n *= (2.0 * float(gl_FrontFacing) - 1.0);\n\n    return n;\n}\n\nvec3 sampleOcclusion(const in LightingInfo info, const in vec3 viewPosition, const in vec3 viewSampleOffset, out bool hit) {\n    vec3 viewSamplePoint = viewPosition + viewSampleOffset;\n    vec4 ndcSamplePoint = u_projection * vec4(viewSamplePoint, 1.0);\n    vec2 sampleUV = (ndcSamplePoint / ndcSamplePoint.w).xy * 0.5 + 0.5;\n    float sampleDepth = length(viewSamplePoint);\n\n    vec4 normalDepth = texture(u_normalDepth, sampleUV);\n    vec3 hitNormal = normalDepth.rgb;\n    float compareDepth = normalDepth.a;\n\n    // TODO: figure out math to get real sampled point\n    // vec3 sampledPoint = vec3(viewSamplePoint.xy, compareDepth);\n    vec3 sampledPoint = viewSamplePoint;\n    vec3 direction = normalize(sampledPoint - viewPosition);\n\n    // range check fixes halos when depths are very different\n    float rangeCheck = abs(compareDepth - sampleDepth) < u_occlusionRange ? 1.0 : 0.0;\n    float check = step(compareDepth, sampleDepth) * rangeCheck;\n\n    float cosOutgoing = clamp(dot(direction, normalize(u_viewNormalMatrix * -hitNormal)), 0.0, 1.0);\n    float cosIncoming = clamp(dot(direction, normalize(u_viewNormalMatrix * info.incidentNormal)), 0.0, 1.0);\n    float bounceDistance = max(length(sampledPoint - viewPosition), 1.0);\n\n    hit = true;\n    if (check <= 0.0) {\n        hit = false;\n        return vec3(0.0);\n    }\n\n    vec3 hitColor = texture(u_lastFrame, sampleUV).rgb;\n    return hitColor * cosIncoming * cosOutgoing / bounceDistance;\n}\n\nmat3 generateTBN(const in LightingInfo info) {\n    // generate matrix to transform from tangent to view space\n    vec3 viewNormal = normalize(u_viewNormalMatrix * info.incidentNormal);\n    vec3 random = normalize(vec3(0.0, 1.0, 1.0));\n    vec3 t = normalize(random - viewNormal * dot(random, viewNormal));\n    vec3 b = cross(viewNormal, t);\n    return mat3(t, b, viewNormal);\n}\n\nvec3 ssaoSample(const in LightingInfo info, const in mat3 TBN, out bool hit) {\n    vec3 viewPosition = (u_view * vec4(info.incidentPosition, 1.0)).xyz;\n\n    float random1 = rand(info.uv * float(u_frameNumber + 1));\n    float random2 = rand(info.uv * float(u_frameNumber + 2));\n    float random3 = rand(info.uv * float(u_frameNumber + 3));\n\n    vec3 viewSampleOffset = TBN * cosineSampleHemisphere(random1, random2);\n    viewSampleOffset *= u_occlusionRange * random3;\n\n    return sampleOcclusion(info, viewPosition, viewSampleOffset, hit);\n}\n\nvec3 ssrSample(const in LightingInfo info, const in mat3 TBN, out bool hit) {\n    vec3 viewPosition = (u_view * vec4(info.incidentPosition, 1.0)).xyz;\n\n    float random1 = rand(info.uv * float(u_frameNumber + 1));\n    float random2 = rand(info.uv * float(u_frameNumber + 2));\n    float random3 = rand(info.uv * float(u_frameNumber + 3));\n\n    vec3 viewHalfNormal = TBN * importanceSampleGGX(vec2(random1, random2), info.alphaRoughnessSq);\n    vec3 viewSampleOffset = reflect(-u_viewNormalMatrix * info.view, viewHalfNormal);\n    viewSampleOffset *= u_occlusionRange * random3;\n\n    return sampleOcclusion(info, viewPosition, viewSampleOffset, hit);\n}\n\nvec3 sampleDiffuseEnvironment(const in LightingInfo info, const in mat3 TBN, const in bool applyOcclusion)\n{\n    vec4 diffuseSample = texture(u_diffuseEnvironment, info.incidentNormal);\n    vec3 diffuseLight = SRGBtoLINEAR(diffuseSample).rgb * u_iblStrength;\n\n    vec3 diffuseReflection = vec3(0.0);\n    bool diffuseReflectionHit = false;\n\n    if (applyOcclusion) {\n        diffuseReflection = ssaoSample(info, TBN, diffuseReflectionHit);\n    }\n\n    vec3 diffuse = diffuseLight * info.diffuseColor;\n\n    if (diffuseReflectionHit) {\n        diffuse = diffuseReflection * info.diffuseColor;\n    }\n\n    return diffuse;\n}\n\nvec3 sampleSpecularEnvironment(const in LightingInfo info, const in mat3 TBN, const in bool applyOcclusion)\n{\n    float NdotV = clamp(dot(info.incidentNormal, info.view), 0.0, 1.0);\n\n    // TODO: pass uniform for mip count\n    const float MIP_COUNT = 8.0;\n    float lod = clamp(info.perceptualRoughness * MIP_COUNT, 0.0, MIP_COUNT);\n    vec3 reflection = normalize(reflect(-info.view, info.incidentNormal));\n\n    vec2 brdfSamplePoint = vec2(NdotV, info.perceptualRoughness);\n    vec2 brdf = texture(u_brdfLUT, brdfSamplePoint).rg;\n\n    vec4 specularSample = textureLod(u_specularEnvironment, reflection, lod);\n    vec3 specularLight = SRGBtoLINEAR(specularSample).rgb * u_iblStrength;\n\n    vec3 specularReflection = vec3(0.0);\n    bool specularReflectionHit = false;\n    if (applyOcclusion) {\n        specularReflection = ssrSample(info, TBN, specularReflectionHit);\n    }\n\n    vec3 specular = specularLight * (info.specularColor * brdf.x + brdf.y);\n\n    if (specularReflectionHit) {\n        specular = specularReflection * info.specularColor;\n    }\n\n    return specular;\n}\n\nvoid main(void)\n{\n    // The albedo may be defined from a base texture or a flat color\n    vec4 baseColor;\n    if (checkFlag(HAS_BASECOLORMAP)) {\n        baseColor = SRGBtoLINEAR(texture(u_baseColor, v_uv[u_baseColorTexCoord])) * u_baseColorFactor;\n    } else {\n        baseColor = u_baseColorFactor;\n    }\n\n    if (u_debugMode == 1) { // flat\n        fragColor = vec4(baseColor.rgb, 1.0);\n        return;\n    }\n\n    float perceptualRoughness = u_roughnessFactor;\n    float metallic = u_metallicFactor;\n    if (checkFlag(HAS_METALROUGHNESSMAP)) {\n        // Roughness is stored in the \'g\' channel, metallic is stored in the \'b\' channel.\n        // This layout intentionally reserves the \'r\' channel for (optional) occlusion map data\n        vec4 mrSample = texture(u_metallicRoughness, v_uv[u_metallicRoughnessTexCoord]);\n        perceptualRoughness = mrSample.g * perceptualRoughness;\n        metallic = mrSample.b * metallic;\n    }\n    perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);\n    metallic = clamp(metallic, 0.0, 1.0);\n    // Roughness is authored as perceptual roughness; as is convention,\n    // convert to material roughness by squaring the perceptual roughness [2].\n    float alphaRoughness = perceptualRoughness * perceptualRoughness;\n\n    if (u_debugMode == 4) { // Illuminance\n        baseColor = vec4(1.0);\n    }\n\n    // spec: COLOR_0 ... acts as an additional linear multiplier to baseColor\n    // TODO!: distinguish vec3/vec4 colors...\n    baseColor *= vec4(v_color.rgb, 1.0);\n\n    vec3 f0 = vec3(0.04);\n    vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);\n    diffuseColor *= 1.0 - metallic;\n    vec3 specularColor = mix(f0, baseColor.rgb, metallic);\n\n    // Compute reflectance.\n    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n\n    // For typical incident reflectance range (between 4% to 100%) set the grazing reflectance to 100% for typical fresnel effect.\n    // For very low reflectance range on highly diffuse objects (below 4%), incrementally reduce grazing reflecance to 0%.\n    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);\n    vec3 specularEnvironmentR0 = specularColor.rgb;\n    vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;\n\n    vec3 N = getNormal(); // normal at surface point\n    vec3 V = normalize(u_eye - v_position); // Vector from surface point to camera\n\n    vec4 ndcPosition = u_viewProjection * vec4(v_position, 1.0);\n    vec2 uv = (ndcPosition / ndcPosition.w).xy * 0.5 + 0.5;\n\n    LightingInfo info = LightingInfo(\n        v_position,\n        N,\n        V,\n        uv,\n\n        diffuseColor,\n        specularColor,\n        specularEnvironmentR0,\n        specularEnvironmentR90,\n        perceptualRoughness,\n        alphaRoughness,\n        alphaRoughness * alphaRoughness\n    );\n\n    vec3 color = vec3(0.0);\n    vec3 lightSources = vec3(0.0);\n\n    // Disk lights with shadow mapping\n    if (u_lightSampleIndex >= 0) {\n        vec4 vLightViewSpace = u_lightView * vec4(v_position, 1.0);\n        vec4 vLightViewProjectionSpace = u_lightProjection * vLightViewSpace;\n\n        float lightDepth = clamp((length(vLightViewSpace.xyz) - u_lightNearFar[0]) / (u_lightNearFar[1] - u_lightNearFar[0]), 0.0, 1.0);\n        vec2 shadowUv = (vLightViewProjectionSpace.xy / vLightViewProjectionSpace.w) * 0.5 + 0.5;\n\n        const float shadowBias = -0.0003;\n        float visibility = SMCompare(u_shadowMap, shadowUv, lightDepth, shadowBias);\n\n        if (any(greaterThan(shadowUv, vec2(1.0))) || any(lessThan(shadowUv, vec2(0.0)))) {\n            visibility = 1.0;\n        }\n\n        lightSources += diffuseDiskLightApproximated(u_diskLights[u_lightSampleIndex], info) * u_lightFactor * visibility;\n        lightSources += specularDiskLightKaris(u_diskLights[u_lightSampleIndex], info) * u_lightFactor * visibility;\n    }\n\n    color += lightSources;\n\n    // Environment lighting\n    mat3 TBN = generateTBN(info);\n    bool applyOcclusion = u_frameNumber > 0;\n    vec3 environmentLight = vec3(0.0);\n\n    for (int i = 0; i < u_numDiffuseEnvironmentSamples; ++i) {\n        environmentLight += sampleDiffuseEnvironment(info, TBN, applyOcclusion) * u_diffuseEnvironmentFactor;\n    }\n\n    for (int i = 0; i < u_numSpecularEnvironmentSamples; ++i) {\n        environmentLight += sampleSpecularEnvironment(info, TBN, applyOcclusion) * u_specularEnvironmentFactor;\n    }\n\n    color += environmentLight;\n\n    // Emissive lighting\n    if (checkFlag(HAS_EMISSIVEMAP)) {\n        vec3 emissive = SRGBtoLINEAR(texture(u_emissive, v_uv[u_emissiveTexCoord])).rgb * u_emissiveFactor;\n        color += emissive;\n    }\n\n    // NOTE: the spec mandates to ignore any alpha value in \'OPAQUE\' mode\n    float alpha = 1.0;\n    if (u_blendMode == 1) {\n        if (baseColor.a < u_blendCutoff) {\n            discard;\n        }\n    }\n    else if (u_blendMode == 2) {\n        alpha = baseColor.a;\n    }\n\n    fragColor = vec4(color, alpha);\n\n    if (u_debugMode == 2) { // IBL\n        fragColor = vec4(environmentLight, alpha);\n    }\n    else if (u_debugMode == 3) { // Light sources\n        fragColor = vec4(lightSources, alpha);\n    }\n}\n' }, function (n, t) { n.exports = "\n#if __VERSION__ == 100\n\n    #ifdef GL_OES_standard_derivatives\n        #extension GL_OES_standard_derivatives : enable\n    #endif\n\n#endif\n\nprecision highp float;\n\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else \n    #define varying in\n#endif\n\n\n\nuniform vec2 u_lightNearFar;\nuniform vec3 u_lightPosition;\nuniform mat4 u_view;\n\n\n#if __VERSION__ == 100\n    #define fragColor gl_FragColor\n#else\n    layout(location = 0) out vec4 fragColor;\n#endif\n\n\nvarying vec3 v_position;\n\n\n\nvec2 SMCoordinates(vec4 worldPosition, mat4 shadowViewProjection)\n{\n    vec4 transformed = shadowViewProjection * worldPosition;\n    return transformed.xy / transformed.w * 0.5 + 0.5;\n}\n\nfloat SMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar)\n{\n    return (distance(worldPosition, lightPosition) - lightNearFar.x) / (lightNearFar.y - lightNearFar.x);\n}\n\nfloat SMCompare(sampler2D depths, vec2 uv, float compare, float offset)\n{\n    float depth = texture(depths, uv).r;\n    return step(compare + offset, depth);\n}\n\nvec2 VSMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar)\n{\n    float depth = SMDepth(worldPosition, lightPosition, lightNearFar);\n\n    vec2 df = vec2(dFdx(depth), dFdy(depth));\n    float moment = depth * depth + 0.25 * dot(df, df);\n\n    return vec2(depth, moment);\n}\n\nfloat chebyshevUpperBound(vec2 moments, float compare, float minVariance, float lightBleedingReduction)\n{\n    float p = 0.0;\n\n    // Surface is fully lit, as the current fragment is before the light occluder\n    if (compare <= moments.x)\n        p = 1.0;\n\n    // The fragment is either in shadow or penumbra. We now use chebyshev's upperBound to check\n    // How likely this pixel is to be lit (p_max)\n    float variance = moments.y - (moments.x * moments.x);\n    variance = max(variance, minVariance);\n\n    float d = compare - moments.x;\n    float p_max = variance / (variance + d*d);\n\n    // Correct light bleeding\n    p_max = smoothstep(lightBleedingReduction, 1.0, p_max);\n\n    return max(p, p_max);\n}\n\nfloat VSMCompare(sampler2D depths, vec2 uv, float compare, float minVariance, float lightBleedingReduction)\n{\n    vec2 moments = texture(depths, uv).rg;\n    return chebyshevUpperBound(moments, compare, minVariance, lightBleedingReduction);\n}\n\nfloat ESMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar, float exponent)\n{\n    float depth = SMDepth(worldPosition, lightPosition, lightNearFar);\n    return exp(exponent * depth);\n}\n\nfloat ESMCompare(sampler2D depths, vec2 uv, float compare, float exponent)\n{\n    float expDepth = texture(depths, uv).r;\n    return clamp(expDepth * exp(-exponent  * compare), 0.0, 1.0);\n}\n\nvec2 EVSMWarpDepth(float depth, vec2 exponents)\n{\n    depth = depth * 2.0 - 1.0;\n    float pos =  exp( exponents.x * depth);\n    float neg = -exp(-exponents.y * depth);\n    return vec2(pos, neg);\n}\n\nvec4 EVSMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar, vec2 exponents)\n{\n    float depth = SMDepth(worldPosition, lightPosition, lightNearFar);\n    vec2 warpedDepth = EVSMWarpDepth(depth, exponents);\n    return vec4(warpedDepth, warpedDepth * warpedDepth);\n}\n\nfloat EVSMCompare(sampler2D depths, vec2 uv, float compare, vec2 exponents, float lightBleedingReduction)\n{\n    vec4 moments = texture(depths, uv);\n    vec2 warpedCompare = EVSMWarpDepth(compare, exponents);\n    vec2 depthScale = 0.0001 * exponents * warpedCompare;\n    vec2 minVariance = depthScale * depthScale;\n    return min(\n        chebyshevUpperBound(moments.xz, warpedCompare.x, minVariance.x, lightBleedingReduction),\n        chebyshevUpperBound(moments.yw, warpedCompare.y, minVariance.y, lightBleedingReduction)\n    );\n}\n\n// vec4 calculateShadowColor(vec4 objectColor, float visibility, float intensity, vec4 shadowColor, float colorIntensity)\n// {\n//   visibility = min(visibility + (1.0 - intensity) * (1.0 - visibility), 1.0);\n\n//   vec4 finalColor = vec4(visibility * objectColor.rgb, objectColor.a);\n//   if (visibility < 1.0)\n//   {\n//     finalColor = clamp(shadowColor * colorIntensity + finalColor, finalColor, objectColor);\n//   }\n\n//   return finalColor;\n// }\n\n\nvoid main(void)\n{\n    vec4 viewPosition = u_view * vec4(v_position, 1.0);\n    fragColor = vec4(VSMDepth(v_position, u_lightPosition, u_lightNearFar), 0.0, 1.0);\n}\n" }, function (n, t) { n.exports = "\n#if __VERSION__ == 100\n\n    #ifdef GL_OES_standard_derivatives\n        #extension GL_OES_standard_derivatives : enable\n    #endif\n\n#endif\n\nprecision highp float;\n\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else \n    #define varying in\n#endif\n\n\n\nuniform vec2 u_cameraNearFar;\nuniform mat4 u_view;\n\n\n#if __VERSION__ == 100\n    #define fragColor gl_FragColor\n#else\n    layout(location = 0) out vec4 fragColor;\n#endif\n\nconst int HAS_NORMALS           = 1;\nconst int HAS_TANGENTS          = 1 << 1;\nconst int HAS_UV                = 1 << 2;\nconst int HAS_COLORS            = 1 << 3;\nconst int USE_IBL               = 1 << 4;\nconst int HAS_BASECOLORMAP      = 1 << 5;\nconst int HAS_NORMALMAP         = 1 << 6;\nconst int HAS_EMISSIVEMAP       = 1 << 7;\nconst int HAS_METALROUGHNESSMAP = 1 << 8;\nconst int HAS_OCCLUSIONMAP      = 1 << 9;\nconst int USE_TEX_LOD           = 1 << 10;\n\nuniform mediump int u_geometryFlags;\n\nvarying vec3 v_position;\nvarying mat3 v_TBN;\nvarying vec3 v_normal;\nvarying vec2 v_uv[3];\n\nbool checkGeometryFlag(int flag) {\n    return (u_geometryFlags & flag) == flag;\n}\n\n// Find the normal for this fragment, pulling either from a predefined normal map\n// or from the interpolated mesh normal and tangent attributes.\nvec3 getNormal()\n{\n    mat3 TBN;\n    // Retrieve the tangent space matrix\n    if (!checkGeometryFlag(HAS_TANGENTS)) {\n        vec3 pos_dx = dFdx(v_position);\n        vec3 pos_dy = dFdy(v_position);\n        vec3 tex_dx = dFdx(vec3(v_uv[0], 0.0));\n        vec3 tex_dy = dFdy(vec3(v_uv[0], 0.0));\n        vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n        vec3 ng;\n        if (checkGeometryFlag(HAS_NORMALS))\n            ng = normalize(v_normal);\n        else\n            ng = cross(pos_dx, pos_dy);\n\n            t = normalize(t - ng * dot(ng, t));\n            vec3 b = normalize(cross(ng, t));\n            TBN = mat3(t, b, ng);\n        }\n    else { // HAS_TANGENTS\n        TBN = v_TBN;\n    }\n\n    // The tbn matrix is linearly interpolated, so we need to re-normalize\n    vec3 n = normalize(TBN[2].xyz);\n\n    // reverse backface normals\n    n *= (2.0 * float(gl_FrontFacing) - 1.0);\n\n    return n;\n}\n\nvoid main(void)\n{\n    vec4 viewPosition = u_view * vec4(v_position, 1.0);\n    viewPosition /= viewPosition.w;\n\n    float depth = length(viewPosition.xyz);\n    fragColor = vec4(getNormal(), depth);\n}\n" }]) }));
//# sourceMappingURL=progressive-lighting.js.map