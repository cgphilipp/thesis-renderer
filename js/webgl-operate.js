(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("rxjs"));
	else if(typeof define === 'function' && define.amd)
		define(["rxjs"], factory);
	else if(typeof exports === 'object')
		exports["gloperate"] = factory(require("rxjs"));
	else
		root["gloperate"] = factory(root["rxjs"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE_rxjs__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "../node_modules/gl-matrix/esm/common.js":
/*!***********************************************!*\
  !*** ../node_modules/gl-matrix/esm/common.js ***!
  \***********************************************/
/*! exports provided: EPSILON, ARRAY_TYPE, RANDOM, setMatrixArrayType, toRadian, equals */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPSILON", function() { return EPSILON; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ARRAY_TYPE", function() { return ARRAY_TYPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RANDOM", function() { return RANDOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setMatrixArrayType", function() { return setMatrixArrayType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toRadian", function() { return toRadian; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = 0.000001;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
var RANDOM = Math.random;
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array
 */

function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}
var degree = Math.PI / 180;
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */

function toRadian(a) {
  return a * degree;
}
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */

function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}
if (!Math.hypot) Math.hypot = function () {
  var y = 0,
      i = arguments.length;

  while (i--) {
    y += arguments[i] * arguments[i];
  }

  return Math.sqrt(y);
};

/***/ }),

/***/ "../node_modules/gl-matrix/esm/index.js":
/*!**********************************************!*\
  !*** ../node_modules/gl-matrix/esm/index.js ***!
  \**********************************************/
/*! exports provided: glMatrix, mat2, mat2d, mat3, mat4, quat, quat2, vec2, vec3, vec4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "../node_modules/gl-matrix/esm/common.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "glMatrix", function() { return _common_js__WEBPACK_IMPORTED_MODULE_0__; });
/* harmony import */ var _mat2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mat2.js */ "../node_modules/gl-matrix/esm/mat2.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat2", function() { return _mat2_js__WEBPACK_IMPORTED_MODULE_1__; });
/* harmony import */ var _mat2d_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mat2d.js */ "../node_modules/gl-matrix/esm/mat2d.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat2d", function() { return _mat2d_js__WEBPACK_IMPORTED_MODULE_2__; });
/* harmony import */ var _mat3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mat3.js */ "../node_modules/gl-matrix/esm/mat3.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat3", function() { return _mat3_js__WEBPACK_IMPORTED_MODULE_3__; });
/* harmony import */ var _mat4_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mat4.js */ "../node_modules/gl-matrix/esm/mat4.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat4", function() { return _mat4_js__WEBPACK_IMPORTED_MODULE_4__; });
/* harmony import */ var _quat_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./quat.js */ "../node_modules/gl-matrix/esm/quat.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "quat", function() { return _quat_js__WEBPACK_IMPORTED_MODULE_5__; });
/* harmony import */ var _quat2_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./quat2.js */ "../node_modules/gl-matrix/esm/quat2.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "quat2", function() { return _quat2_js__WEBPACK_IMPORTED_MODULE_6__; });
/* harmony import */ var _vec2_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./vec2.js */ "../node_modules/gl-matrix/esm/vec2.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec2", function() { return _vec2_js__WEBPACK_IMPORTED_MODULE_7__; });
/* harmony import */ var _vec3_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./vec3.js */ "../node_modules/gl-matrix/esm/vec3.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec3", function() { return _vec3_js__WEBPACK_IMPORTED_MODULE_8__; });
/* harmony import */ var _vec4_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./vec4.js */ "../node_modules/gl-matrix/esm/vec4.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec4", function() { return _vec4_js__WEBPACK_IMPORTED_MODULE_9__; });












/***/ }),

/***/ "../node_modules/gl-matrix/esm/mat2.js":
/*!*********************************************!*\
  !*** ../node_modules/gl-matrix/esm/mat2.js ***!
  \*********************************************/
/*! exports provided: create, clone, copy, identity, fromValues, set, transpose, invert, adjoint, determinant, multiply, rotate, scale, fromRotation, fromScaling, str, frob, LDU, add, subtract, exactEquals, equals, multiplyScalar, multiplyScalarAndAdd, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return transpose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "adjoint", function() { return adjoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LDU", function() { return LDU; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "../node_modules/gl-matrix/esm/common.js");

/**
 * 2x2 Matrix
 * @module mat2
 */

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
  }

  out[0] = 1;
  out[3] = 1;
  return out;
}
/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */

function fromValues(m00, m01, m10, m11) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */

function set(out, m00, m01, m10, m11) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache
  // some values
  if (out === a) {
    var a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }

  return out;
}
/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */

function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3]; // Calculate the determinant

  var det = a0 * a3 - a2 * a1;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] = a0 * det;
  return out;
}
/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */

function adjoint(out, a) {
  // Caching this value is nessecary if out == a
  var a0 = a[0];
  out[0] = a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a0;
  return out;
}
/**
 * Calculates the determinant of a mat2
 *
 * @param {ReadonlyMat2} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}
/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */

function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}
/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */

function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}
/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to rotate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/

function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat2} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  return out;
}
/**
 * Returns a string representation of a mat2
 *
 * @param {ReadonlyMat2} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Returns Frobenius norm of a mat2
 *
 * @param {ReadonlyMat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3]);
}
/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {ReadonlyMat2} L the lower triangular matrix
 * @param {ReadonlyMat2} D the diagonal matrix
 * @param {ReadonlyMat2} U the upper triangular matrix
 * @param {ReadonlyMat2} a the input matrix to factorize
 */

function LDU(L, D, U, a) {
  L[2] = a[2] / a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}
/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat2} a The first matrix.
 * @param {ReadonlyMat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat2} a The first matrix.
 * @param {ReadonlyMat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Alias for {@link mat2.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat2.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "../node_modules/gl-matrix/esm/mat2d.js":
/*!**********************************************!*\
  !*** ../node_modules/gl-matrix/esm/mat2d.js ***!
  \**********************************************/
/*! exports provided: create, clone, copy, identity, fromValues, set, invert, determinant, multiply, rotate, scale, translate, fromRotation, fromScaling, fromTranslation, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "../node_modules/gl-matrix/esm/common.js");

/**
 * 2x3 Matrix
 * @module mat2d
 * @description
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, b,
 *  c, d,
 *  tx, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, b, 0,
 *  c, d, 0,
 *  tx, ty, 1]
 * </pre>
 * The last column is ignored so the array is shorter and operations are faster.
 */

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](6);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[4] = 0;
    out[5] = 0;
  }

  out[0] = 1;
  out[3] = 1;
  return out;
}
/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {ReadonlyMat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](6);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}
/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {mat2d} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}
/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */

function fromValues(a, b, c, d, tx, ty) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](6);
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}
/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */

function set(out, a, b, c, d, tx, ty) {
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}
/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {mat2d} out
 */

function invert(out, a) {
  var aa = a[0],
      ab = a[1],
      ac = a[2],
      ad = a[3];
  var atx = a[4],
      aty = a[5];
  var det = aa * ad - ab * ac;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = ad * det;
  out[1] = -ab * det;
  out[2] = -ac * det;
  out[3] = aa * det;
  out[4] = (ac * aty - ad * atx) * det;
  out[5] = (ab * atx - aa * aty) * det;
  return out;
}
/**
 * Calculates the determinant of a mat2d
 *
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  return a[0] * a[3] - a[1] * a[2];
}
/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */

function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  out[4] = a0 * b4 + a2 * b5 + a4;
  out[5] = a1 * b4 + a3 * b5 + a5;
  return out;
}
/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */

function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  out[4] = a4;
  out[5] = a5;
  return out;
}
/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to translate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/

function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  out[4] = a4;
  out[5] = a5;
  return out;
}
/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to translate
 * @param {ReadonlyVec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/

function translate(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0;
  out[1] = a1;
  out[2] = a2;
  out[3] = a3;
  out[4] = a0 * v0 + a2 * v1 + a4;
  out[5] = a1 * v0 + a3 * v1 + a5;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat2d} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {ReadonlyVec2} v Translation vector
 * @returns {mat2d} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = v[0];
  out[5] = v[1];
  return out;
}
/**
 * Returns a string representation of a mat2d
 *
 * @param {ReadonlyMat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat2d(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ")";
}
/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {ReadonlyMat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], 1);
}
/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  return out;
}
/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat2d} a The first matrix.
 * @param {ReadonlyMat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat2d} a The first matrix.
 * @param {ReadonlyMat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5));
}
/**
 * Alias for {@link mat2d.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat2d.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "../node_modules/gl-matrix/esm/mat3.js":
/*!*********************************************!*\
  !*** ../node_modules/gl-matrix/esm/mat3.js ***!
  \*********************************************/
/*! exports provided: create, fromMat4, clone, copy, fromValues, set, identity, transpose, invert, adjoint, determinant, multiply, translate, rotate, scale, fromTranslation, fromRotation, fromScaling, fromMat2d, fromQuat, normalFromMat4, projection, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat4", function() { return fromMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return transpose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "adjoint", function() { return adjoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat2d", function() { return fromMat2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromQuat", function() { return fromQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalFromMat4", function() { return normalFromMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "projection", function() { return projection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "../node_modules/gl-matrix/esm/common.js");

/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](9);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }

  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {ReadonlyMat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */

function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */

function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */

function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}
/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

  var det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
/**
 * Calculates the determinant of a mat3
 *
 * @param {ReadonlyMat3} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b00 = b[0],
      b01 = b[1],
      b02 = b[2];
  var b10 = b[3],
      b11 = b[4],
      b12 = b[5];
  var b20 = b[6],
      b21 = b[7],
      b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to translate
 * @param {ReadonlyVec2} v vector to translate by
 * @returns {mat3} out
 */

function translate(out, a, v) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      x = v[0],
      y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function rotate(out, a, rad) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Translation vector
 * @returns {mat3} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat3} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to copy
 * @returns {mat3} out
 **/

function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
/**
 * Calculates a 3x3 matrix from the given quaternion
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat3} out
 */

function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
/**
 * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from
 *
 * @returns {mat3} out
 */

function normalFromMat4(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */

function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
/**
 * Returns a string representation of a mat3
 *
 * @param {ReadonlyMat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
}
/**
 * Returns Frobenius norm of a mat3
 *
 * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}
/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7],
      a8 = a[8];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7],
      b8 = b[8];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}
/**
 * Alias for {@link mat3.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat3.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "../node_modules/gl-matrix/esm/mat4.js":
/*!*********************************************!*\
  !*** ../node_modules/gl-matrix/esm/mat4.js ***!
  \*********************************************/
/*! exports provided: create, clone, copy, fromValues, set, identity, transpose, invert, adjoint, determinant, multiply, translate, scale, rotate, rotateX, rotateY, rotateZ, fromTranslation, fromScaling, fromRotation, fromXRotation, fromYRotation, fromZRotation, fromRotationTranslation, fromQuat2, getTranslation, getScaling, getRotation, fromRotationTranslationScale, fromRotationTranslationScaleOrigin, fromQuat, frustum, perspective, perspectiveFromFieldOfView, ortho, lookAt, targetTo, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return transpose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "adjoint", function() { return adjoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromXRotation", function() { return fromXRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromYRotation", function() { return fromYRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromZRotation", function() { return fromZRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslation", function() { return fromRotationTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromQuat2", function() { return fromQuat2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTranslation", function() { return getTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getScaling", function() { return getScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRotation", function() { return getRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslationScale", function() { return fromRotationTranslationScale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslationScaleOrigin", function() { return fromRotationTranslationScaleOrigin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromQuat", function() { return fromQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frustum", function() { return frustum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "perspective", function() { return perspective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "perspectiveFromFieldOfView", function() { return perspectiveFromFieldOfView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ortho", function() { return ortho; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lookAt", function() { return lookAt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "targetTo", function() { return targetTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "../node_modules/gl-matrix/esm/common.js");

/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](16);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }

  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */

function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */

function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a12 = a[6],
        a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}
/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
/**
 * Calculates the determinant of a mat4
 *
 * @param {ReadonlyMat4} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15]; // Cache only the current line of the second matrix

  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to translate
 * @param {ReadonlyVec3} v vector to translate by
 * @returns {mat4} out
 */

function translate(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}
/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {ReadonlyVec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function rotate(out, a, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;

  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11]; // Construct the elements of the rotation matrix

  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  return out;
}
/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Scaling vector
 * @returns {mat4} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function fromRotation(out, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;

  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c; // Perform rotation-specific matrix multiplication

  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */

function fromRotationTranslation(out, q, v) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {ReadonlyQuat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */

function fromQuat2(out, a) {
  var translation = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }

  fromRotationTranslation(out, a, translation);
  return out;
}
/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */

function getRotation(out, mat) {
  var scaling = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }

  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @returns {mat4} out
 */

function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @param {ReadonlyVec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */

function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */

function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */

function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
/**
 * Generates a perspective projection matrix with the given bounds.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */

function perspective(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;

  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }

  return out;
}
/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  var xScale = 2.0 / (leftTan + rightTan);
  var yScale = 2.0 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
}
/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function ortho(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */

function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];

  if (Math.abs(eyex - centerx) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] && Math.abs(eyey - centery) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] && Math.abs(eyez - centerz) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.hypot(z0, z1, z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.hypot(x0, x1, x2);

  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.hypot(y0, y1, y2);

  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */

function targetTo(out, eye, target, up) {
  var eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];
  var z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];
  var len = z0 * z0 + z1 * z1 + z2 * z2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  var x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;
  len = x0 * x0 + x1 * x1 + x2 * x2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
/**
 * Returns a string representation of a mat4
 *
 * @param {ReadonlyMat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}
/**
 * Returns Frobenius norm of a mat4
 *
 * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var a8 = a[8],
      a9 = a[9],
      a10 = a[10],
      a11 = a[11];
  var a12 = a[12],
      a13 = a[13],
      a14 = a[14],
      a15 = a[15];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  var b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  var b8 = b[8],
      b9 = b[9],
      b10 = b[10],
      b11 = b[11];
  var b12 = b[12],
      b13 = b[13],
      b14 = b[14],
      b15 = b[15];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}
/**
 * Alias for {@link mat4.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat4.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "../node_modules/gl-matrix/esm/quat.js":
/*!*********************************************!*\
  !*** ../node_modules/gl-matrix/esm/quat.js ***!
  \*********************************************/
/*! exports provided: create, identity, setAxisAngle, getAxisAngle, getAngle, multiply, rotateX, rotateY, rotateZ, calculateW, exp, ln, pow, slerp, random, invert, conjugate, fromMat3, fromEuler, str, clone, fromValues, copy, set, add, mul, scale, dot, lerp, length, len, squaredLength, sqrLen, normalize, exactEquals, equals, rotationTo, sqlerp, setAxes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAxisAngle", function() { return setAxisAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAxisAngle", function() { return getAxisAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAngle", function() { return getAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calculateW", function() { return calculateW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exp", function() { return exp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ln", function() { return ln; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pow", function() { return pow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slerp", function() { return slerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conjugate", function() { return conjugate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat3", function() { return fromMat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromEuler", function() { return fromEuler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotationTo", function() { return rotationTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqlerp", function() { return sqlerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAxes", function() { return setAxes; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "../node_modules/gl-matrix/esm/common.js");
/* harmony import */ var _mat3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mat3.js */ "../node_modules/gl-matrix/esm/mat3.js");
/* harmony import */ var _vec3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vec3.js */ "../node_modules/gl-matrix/esm/vec3.js");
/* harmony import */ var _vec4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vec4.js */ "../node_modules/gl-matrix/esm/vec4.js");




/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  out[3] = 1;
  return out;
}
/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */

function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyVec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/

function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {ReadonlyQuat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */

function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2.0;
  var s = Math.sin(rad / 2.0);

  if (s > _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }

  return rad;
}
/**
 * Gets the angular distance between two unit quaternions
 *
 * @param  {ReadonlyQuat} a     Origin unit quaternion
 * @param  {ReadonlyQuat} b     Destination unit quaternion
 * @return {Number}     Angle, in radians, between the two quaternions
 */

function getAngle(a, b) {
  var dotproduct = dot(a, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {quat} out
 */

function multiply(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateX(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateY(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var by = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateZ(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bz = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate W component of
 * @returns {quat} out
 */

function calculateW(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}
/**
 * Calculate the exponential of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @returns {quat} out
 */

function exp(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var et = Math.exp(w);
  var s = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x * s;
  out[1] = y * s;
  out[2] = z * s;
  out[3] = et * Math.cos(r);
  return out;
}
/**
 * Calculate the natural logarithm of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @returns {quat} out
 */

function ln(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var t = r > 0 ? Math.atan2(r, w) / r : 0;
  out[0] = x * t;
  out[1] = y * t;
  out[2] = z * t;
  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
  return out;
}
/**
 * Calculate the scalar power of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @param {Number} b amount to scale the quaternion by
 * @returns {quat} out
 */

function pow(out, a, b) {
  ln(out, a);
  scale(out, out, b);
  exp(out, out);
  return out;
}
/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  var omega, cosom, sinom, scale0, scale1; // calc cosine

  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  } // calculate coefficients


  if (1.0 - cosom > _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  } // calculate final values


  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
/**
 * Generates a random unit quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */

function random(out) {
  // Implementation of http://planning.cs.uiuc.edu/node198.html
  // TODO: Calling random 3 times is probably not the fastest solution
  var u1 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]();
  var u2 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]();
  var u3 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
  return out;
}
/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate inverse of
 * @returns {quat} out
 */

function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate conjugate of
 * @returns {quat} out
 */

function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyMat3} m rotation matrix
 * @returns {quat} out
 * @function
 */

function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;

  if (fTrace > 0.0) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0); // 2w

    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot; // 1/(4w)

    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    // |w| <= 1/2
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }

  return out;
}
/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */

function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180.0;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
/**
 * Returns a string representation of a quatenion
 *
 * @param {ReadonlyQuat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {ReadonlyQuat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */

var clone = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["clone"];
/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */

var fromValues = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["fromValues"];
/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the source quaternion
 * @returns {quat} out
 * @function
 */

var copy = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["copy"];
/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */

var set = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["set"];
/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {quat} out
 * @function
 */

var add = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["add"];
/**
 * Alias for {@link quat.multiply}
 * @function
 */

var mul = multiply;
/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {ReadonlyQuat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */

var scale = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["scale"];
/**
 * Calculates the dot product of two quat's
 *
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */

var dot = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["dot"];
/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 * @function
 */

var lerp = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["lerp"];
/**
 * Calculates the length of a quat
 *
 * @param {ReadonlyQuat} a vector to calculate length of
 * @returns {Number} length of a
 */

var length = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["length"];
/**
 * Alias for {@link quat.length}
 * @function
 */

var len = length;
/**
 * Calculates the squared length of a quat
 *
 * @param {ReadonlyQuat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

var squaredLength = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["squaredLength"];
/**
 * Alias for {@link quat.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */

var normalize = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["normalize"];
/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyQuat} a The first quaternion.
 * @param {ReadonlyQuat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

var exactEquals = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["exactEquals"];
/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {ReadonlyQuat} a The first vector.
 * @param {ReadonlyQuat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

var equals = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["equals"];
/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {ReadonlyVec3} a the initial vector
 * @param {ReadonlyVec3} b the destination vector
 * @returns {quat} out
 */

var rotationTo = function () {
  var tmpvec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["create"]();
  var xUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["fromValues"](1, 0, 0);
  var yUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["fromValues"](0, 1, 0);
  return function (out, a, b) {
    var dot = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["dot"](a, b);

    if (dot < -0.999999) {
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__["cross"](tmpvec3, xUnitVec3, a);
      if (_vec3_js__WEBPACK_IMPORTED_MODULE_2__["len"](tmpvec3) < 0.000001) _vec3_js__WEBPACK_IMPORTED_MODULE_2__["cross"](tmpvec3, yUnitVec3, a);
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__["normalize"](tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__["cross"](tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize(out, out);
    }
  };
}();
/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {ReadonlyQuat} c the third operand
 * @param {ReadonlyQuat} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

var sqlerp = function () {
  var temp1 = create();
  var temp2 = create();
  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {ReadonlyVec3} view  the vector representing the viewing direction
 * @param {ReadonlyVec3} right the vector representing the local "right" direction
 * @param {ReadonlyVec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */

var setAxes = function () {
  var matr = _mat3_js__WEBPACK_IMPORTED_MODULE_1__["create"]();
  return function (out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize(out, fromMat3(out, matr));
  };
}();

/***/ }),

/***/ "../node_modules/gl-matrix/esm/quat2.js":
/*!**********************************************!*\
  !*** ../node_modules/gl-matrix/esm/quat2.js ***!
  \**********************************************/
/*! exports provided: create, clone, fromValues, fromRotationTranslationValues, fromRotationTranslation, fromTranslation, fromRotation, fromMat4, copy, identity, set, getReal, getDual, setReal, setDual, getTranslation, translate, rotateX, rotateY, rotateZ, rotateByQuatAppend, rotateByQuatPrepend, rotateAroundAxis, add, multiply, mul, scale, dot, lerp, invert, conjugate, length, len, squaredLength, sqrLen, normalize, str, exactEquals, equals */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslationValues", function() { return fromRotationTranslationValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslation", function() { return fromRotationTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat4", function() { return fromMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getReal", function() { return getReal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDual", function() { return getDual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setReal", function() { return setReal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setDual", function() { return setDual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTranslation", function() { return getTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateByQuatAppend", function() { return rotateByQuatAppend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateByQuatPrepend", function() { return rotateByQuatPrepend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateAroundAxis", function() { return rotateAroundAxis; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conjugate", function() { return conjugate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "../node_modules/gl-matrix/esm/common.js");
/* harmony import */ var _quat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./quat.js */ "../node_modules/gl-matrix/esm/quat.js");
/* harmony import */ var _mat4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mat4.js */ "../node_modules/gl-matrix/esm/mat4.js");



/**
 * Dual Quaternion<br>
 * Format: [real, dual]<br>
 * Quaternion format: XYZW<br>
 * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>
 * @module quat2
 */

/**
 * Creates a new identity dual quat
 *
 * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]
 */

function create() {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](8);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    dq[0] = 0;
    dq[1] = 0;
    dq[2] = 0;
    dq[4] = 0;
    dq[5] = 0;
    dq[6] = 0;
    dq[7] = 0;
  }

  dq[3] = 1;
  return dq;
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {ReadonlyQuat2} a dual quaternion to clone
 * @returns {quat2} new dual quaternion
 * @function
 */

function clone(a) {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](8);
  dq[0] = a[0];
  dq[1] = a[1];
  dq[2] = a[2];
  dq[3] = a[3];
  dq[4] = a[4];
  dq[5] = a[5];
  dq[6] = a[6];
  dq[7] = a[7];
  return dq;
}
/**
 * Creates a new dual quat initialized with the given values
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} new dual quaternion
 * @function
 */

function fromValues(x1, y1, z1, w1, x2, y2, z2, w2) {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  dq[4] = x2;
  dq[5] = y2;
  dq[6] = z2;
  dq[7] = w2;
  return dq;
}
/**
 * Creates a new dual quat from the given values (quat and translation)
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component (translation)
 * @param {Number} y2 Y component (translation)
 * @param {Number} z2 Z component (translation)
 * @returns {quat2} new dual quaternion
 * @function
 */

function fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  var ax = x2 * 0.5,
      ay = y2 * 0.5,
      az = z2 * 0.5;
  dq[4] = ax * w1 + ay * z1 - az * y1;
  dq[5] = ay * w1 + az * x1 - ax * z1;
  dq[6] = az * w1 + ax * y1 - ay * x1;
  dq[7] = -ax * x1 - ay * y1 - az * z1;
  return dq;
}
/**
 * Creates a dual quat from a quaternion and a translation
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyQuat} q a normalized quaternion
 * @param {ReadonlyVec3} t tranlation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */

function fromRotationTranslation(out, q, t) {
  var ax = t[0] * 0.5,
      ay = t[1] * 0.5,
      az = t[2] * 0.5,
      bx = q[0],
      by = q[1],
      bz = q[2],
      bw = q[3];
  out[0] = bx;
  out[1] = by;
  out[2] = bz;
  out[3] = bw;
  out[4] = ax * bw + ay * bz - az * by;
  out[5] = ay * bw + az * bx - ax * bz;
  out[6] = az * bw + ax * by - ay * bx;
  out[7] = -ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Creates a dual quat from a translation
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyVec3} t translation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */

function fromTranslation(out, t) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = t[0] * 0.5;
  out[5] = t[1] * 0.5;
  out[6] = t[2] * 0.5;
  out[7] = 0;
  return out;
}
/**
 * Creates a dual quat from a quaternion
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyQuat} q the quaternion
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */

function fromRotation(out, q) {
  out[0] = q[0];
  out[1] = q[1];
  out[2] = q[2];
  out[3] = q[3];
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
/**
 * Creates a new dual quat from a matrix (4x4)
 *
 * @param {quat2} out the dual quaternion
 * @param {ReadonlyMat4} a the matrix
 * @returns {quat2} dual quat receiving operation result
 * @function
 */

function fromMat4(out, a) {
  //TODO Optimize this
  var outer = _quat_js__WEBPACK_IMPORTED_MODULE_1__["create"]();
  _mat4_js__WEBPACK_IMPORTED_MODULE_2__["getRotation"](outer, a);
  var t = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  _mat4_js__WEBPACK_IMPORTED_MODULE_2__["getTranslation"](t, a);
  fromRotationTranslation(out, outer, t);
  return out;
}
/**
 * Copy the values from one dual quat to another
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the source dual quaternion
 * @returns {quat2} out
 * @function
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  return out;
}
/**
 * Set a dual quat to the identity dual quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @returns {quat2} out
 */

function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
/**
 * Set the components of a dual quat to the given values
 *
 * @param {quat2} out the receiving quaternion
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} out
 * @function
 */

function set(out, x1, y1, z1, w1, x2, y2, z2, w2) {
  out[0] = x1;
  out[1] = y1;
  out[2] = z1;
  out[3] = w1;
  out[4] = x2;
  out[5] = y2;
  out[6] = z2;
  out[7] = w2;
  return out;
}
/**
 * Gets the real part of a dual quat
 * @param  {quat} out real part
 * @param  {ReadonlyQuat2} a Dual Quaternion
 * @return {quat} real part
 */

var getReal = _quat_js__WEBPACK_IMPORTED_MODULE_1__["copy"];
/**
 * Gets the dual part of a dual quat
 * @param  {quat} out dual part
 * @param  {ReadonlyQuat2} a Dual Quaternion
 * @return {quat} dual part
 */

function getDual(out, a) {
  out[0] = a[4];
  out[1] = a[5];
  out[2] = a[6];
  out[3] = a[7];
  return out;
}
/**
 * Set the real component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat} q a quaternion representing the real part
 * @returns {quat2} out
 * @function
 */

var setReal = _quat_js__WEBPACK_IMPORTED_MODULE_1__["copy"];
/**
 * Set the dual component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat} q a quaternion representing the dual part
 * @returns {quat2} out
 * @function
 */

function setDual(out, q) {
  out[4] = q[0];
  out[5] = q[1];
  out[6] = q[2];
  out[7] = q[3];
  return out;
}
/**
 * Gets the translation of a normalized dual quat
 * @param  {vec3} out translation
 * @param  {ReadonlyQuat2} a Dual Quaternion to be decomposed
 * @return {vec3} translation
 */

function getTranslation(out, a) {
  var ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3];
  out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
  out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
  out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  return out;
}
/**
 * Translates a dual quat by the given vector
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to translate
 * @param {ReadonlyVec3} v vector to translate by
 * @returns {quat2} out
 */

function translate(out, a, v) {
  var ax1 = a[0],
      ay1 = a[1],
      az1 = a[2],
      aw1 = a[3],
      bx1 = v[0] * 0.5,
      by1 = v[1] * 0.5,
      bz1 = v[2] * 0.5,
      ax2 = a[4],
      ay2 = a[5],
      az2 = a[6],
      aw2 = a[7];
  out[0] = ax1;
  out[1] = ay1;
  out[2] = az1;
  out[3] = aw1;
  out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;
  out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;
  out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;
  out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;
  return out;
}
/**
 * Rotates a dual quat around the X axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */

function rotateX(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  _quat_js__WEBPACK_IMPORTED_MODULE_1__["rotateX"](out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat around the Y axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */

function rotateY(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  _quat_js__WEBPACK_IMPORTED_MODULE_1__["rotateY"](out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat around the Z axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */

function rotateZ(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  _quat_js__WEBPACK_IMPORTED_MODULE_1__["rotateZ"](out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat by a given quaternion (a * q)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {ReadonlyQuat} q quaternion to rotate by
 * @returns {quat2} out
 */

function rotateByQuatAppend(out, a, q) {
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  out[0] = ax * qw + aw * qx + ay * qz - az * qy;
  out[1] = ay * qw + aw * qy + az * qx - ax * qz;
  out[2] = az * qw + aw * qz + ax * qy - ay * qx;
  out[3] = aw * qw - ax * qx - ay * qy - az * qz;
  ax = a[4];
  ay = a[5];
  az = a[6];
  aw = a[7];
  out[4] = ax * qw + aw * qx + ay * qz - az * qy;
  out[5] = ay * qw + aw * qy + az * qx - ax * qz;
  out[6] = az * qw + aw * qz + ax * qy - ay * qx;
  out[7] = aw * qw - ax * qx - ay * qy - az * qz;
  return out;
}
/**
 * Rotates a dual quat by a given quaternion (q * a)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat} q quaternion to rotate by
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @returns {quat2} out
 */

function rotateByQuatPrepend(out, q, a) {
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      bx = a[0],
      by = a[1],
      bz = a[2],
      bw = a[3];
  out[0] = qx * bw + qw * bx + qy * bz - qz * by;
  out[1] = qy * bw + qw * by + qz * bx - qx * bz;
  out[2] = qz * bw + qw * bz + qx * by - qy * bx;
  out[3] = qw * bw - qx * bx - qy * by - qz * bz;
  bx = a[4];
  by = a[5];
  bz = a[6];
  bw = a[7];
  out[4] = qx * bw + qw * bx + qy * bz - qz * by;
  out[5] = qy * bw + qw * by + qz * bx - qx * bz;
  out[6] = qz * bw + qw * bz + qx * by - qy * bx;
  out[7] = qw * bw - qx * bx - qy * by - qz * bz;
  return out;
}
/**
 * Rotates a dual quat around a given axis. Does the normalisation automatically
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @param {Number} rad how far the rotation should be
 * @returns {quat2} out
 */

function rotateAroundAxis(out, a, axis, rad) {
  //Special case for rad = 0
  if (Math.abs(rad) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return copy(out, a);
  }

  var axisLength = Math.hypot(axis[0], axis[1], axis[2]);
  rad = rad * 0.5;
  var s = Math.sin(rad);
  var bx = s * axis[0] / axisLength;
  var by = s * axis[1] / axisLength;
  var bz = s * axis[2] / axisLength;
  var bw = Math.cos(rad);
  var ax1 = a[0],
      ay1 = a[1],
      az1 = a[2],
      aw1 = a[3];
  out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  var ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  out[4] = ax * bw + aw * bx + ay * bz - az * by;
  out[5] = ay * bw + aw * by + az * bx - ax * bz;
  out[6] = az * bw + aw * bz + ax * by - ay * bx;
  out[7] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Adds two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {quat2} out
 * @function
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  return out;
}
/**
 * Multiplies two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {quat2} out
 */

function multiply(out, a, b) {
  var ax0 = a[0],
      ay0 = a[1],
      az0 = a[2],
      aw0 = a[3],
      bx1 = b[4],
      by1 = b[5],
      bz1 = b[6],
      bw1 = b[7],
      ax1 = a[4],
      ay1 = a[5],
      az1 = a[6],
      aw1 = a[7],
      bx0 = b[0],
      by0 = b[1],
      bz0 = b[2],
      bw0 = b[3];
  out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;
  out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;
  out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;
  out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;
  out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;
  out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;
  out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;
  out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;
  return out;
}
/**
 * Alias for {@link quat2.multiply}
 * @function
 */

var mul = multiply;
/**
 * Scales a dual quat by a scalar number
 *
 * @param {quat2} out the receiving dual quat
 * @param {ReadonlyQuat2} a the dual quat to scale
 * @param {Number} b amount to scale the dual quat by
 * @returns {quat2} out
 * @function
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  return out;
}
/**
 * Calculates the dot product of two dual quat's (The dot product of the real parts)
 *
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */

var dot = _quat_js__WEBPACK_IMPORTED_MODULE_1__["dot"];
/**
 * Performs a linear interpolation between two dual quats's
 * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)
 *
 * @param {quat2} out the receiving dual quat
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat2} out
 */

function lerp(out, a, b, t) {
  var mt = 1 - t;
  if (dot(a, b) < 0) t = -t;
  out[0] = a[0] * mt + b[0] * t;
  out[1] = a[1] * mt + b[1] * t;
  out[2] = a[2] * mt + b[2] * t;
  out[3] = a[3] * mt + b[3] * t;
  out[4] = a[4] * mt + b[4] * t;
  out[5] = a[5] * mt + b[5] * t;
  out[6] = a[6] * mt + b[6] * t;
  out[7] = a[7] * mt + b[7] * t;
  return out;
}
/**
 * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a dual quat to calculate inverse of
 * @returns {quat2} out
 */

function invert(out, a) {
  var sqlen = squaredLength(a);
  out[0] = -a[0] / sqlen;
  out[1] = -a[1] / sqlen;
  out[2] = -a[2] / sqlen;
  out[3] = a[3] / sqlen;
  out[4] = -a[4] / sqlen;
  out[5] = -a[5] / sqlen;
  out[6] = -a[6] / sqlen;
  out[7] = a[7] / sqlen;
  return out;
}
/**
 * Calculates the conjugate of a dual quat
 * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat2} a quat to calculate conjugate of
 * @returns {quat2} out
 */

function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  out[4] = -a[4];
  out[5] = -a[5];
  out[6] = -a[6];
  out[7] = a[7];
  return out;
}
/**
 * Calculates the length of a dual quat
 *
 * @param {ReadonlyQuat2} a dual quat to calculate length of
 * @returns {Number} length of a
 * @function
 */

var length = _quat_js__WEBPACK_IMPORTED_MODULE_1__["length"];
/**
 * Alias for {@link quat2.length}
 * @function
 */

var len = length;
/**
 * Calculates the squared length of a dual quat
 *
 * @param {ReadonlyQuat2} a dual quat to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

var squaredLength = _quat_js__WEBPACK_IMPORTED_MODULE_1__["squaredLength"];
/**
 * Alias for {@link quat2.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Normalize a dual quat
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a dual quaternion to normalize
 * @returns {quat2} out
 * @function
 */

function normalize(out, a) {
  var magnitude = squaredLength(a);

  if (magnitude > 0) {
    magnitude = Math.sqrt(magnitude);
    var a0 = a[0] / magnitude;
    var a1 = a[1] / magnitude;
    var a2 = a[2] / magnitude;
    var a3 = a[3] / magnitude;
    var b0 = a[4];
    var b1 = a[5];
    var b2 = a[6];
    var b3 = a[7];
    var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = (b0 - a0 * a_dot_b) / magnitude;
    out[5] = (b1 - a1 * a_dot_b) / magnitude;
    out[6] = (b2 - a2 * a_dot_b) / magnitude;
    out[7] = (b3 - a3 * a_dot_b) / magnitude;
  }

  return out;
}
/**
 * Returns a string representation of a dual quatenion
 *
 * @param {ReadonlyQuat2} a dual quaternion to represent as a string
 * @returns {String} string representation of the dual quat
 */

function str(a) {
  return "quat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ")";
}
/**
 * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyQuat2} a the first dual quaternion.
 * @param {ReadonlyQuat2} b the second dual quaternion.
 * @returns {Boolean} true if the dual quaternions are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];
}
/**
 * Returns whether or not the dual quaternions have approximately the same elements in the same position.
 *
 * @param {ReadonlyQuat2} a the first dual quat.
 * @param {ReadonlyQuat2} b the second dual quat.
 * @returns {Boolean} true if the dual quats are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a7), Math.abs(b7));
}

/***/ }),

/***/ "../node_modules/gl-matrix/esm/vec2.js":
/*!*********************************************!*\
  !*** ../node_modules/gl-matrix/esm/vec2.js ***!
  \*********************************************/
/*! exports provided: create, clone, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, length, squaredLength, negate, inverse, normalize, dot, cross, lerp, random, transformMat2, transformMat2d, transformMat3, transformMat4, rotate, angle, zero, str, exactEquals, equals, len, sub, mul, div, dist, sqrDist, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleAndAdd", function() { return scaleAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return negate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat2", function() { return transformMat2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat2d", function() { return transformMat2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat3", function() { return transformMat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat4", function() { return transformMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "angle", function() { return angle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zero", function() { return zero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dist", function() { return dist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrDist", function() { return sqrDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "../node_modules/gl-matrix/esm/common.js");

/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](2);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }

  return out;
}
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {ReadonlyVec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */

function fromValues(x, y) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](2);
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the source vector
 * @returns {vec2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */

function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to ceil
 * @returns {vec2} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to floor
 * @returns {vec2} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to round
 * @returns {vec2} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
}
/**
 * Calculates the length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0],
      y = a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
}
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to negate
 * @returns {vec2} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to invert
 * @returns {vec2} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to normalize
 * @returns {vec2} out
 */

function normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  return out;
}
/**
 * Calculates the dot product of two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */

function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2d} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat3} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {ReadonlyVec2} a The vec2 point to rotate
 * @param {ReadonlyVec2} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec2} out
 */

function rotate(out, a, b, rad) {
  //Translate point to the origin
  var p0 = a[0] - b[0],
      p1 = a[1] - b[1],
      sinC = Math.sin(rad),
      cosC = Math.cos(rad); //perform rotation and translate to correct position

  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
/**
 * Get the angle between two 2D vectors
 * @param {ReadonlyVec2} a The first operand
 * @param {ReadonlyVec2} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var x1 = a[0],
      y1 = a[1],
      x2 = b[0],
      y2 = b[1],
      // mag is the product of the magnitudes of a and b
  mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),
      // mag &&.. short circuits if mag == 0
  cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1

  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec2 to zero
 *
 * @param {vec2} out the receiving vector
 * @returns {vec2} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec2(" + a[0] + ", " + a[1] + ")";
}
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1];
  var b0 = b[0],
      b1 = b[1];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}
/**
 * Alias for {@link vec2.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec2.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec2.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec2.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec2.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 2;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }

    return a;
  };
}();

/***/ }),

/***/ "../node_modules/gl-matrix/esm/vec3.js":
/*!*********************************************!*\
  !*** ../node_modules/gl-matrix/esm/vec3.js ***!
  \*********************************************/
/*! exports provided: create, clone, length, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, squaredLength, negate, inverse, normalize, dot, cross, lerp, hermite, bezier, random, transformMat4, transformMat3, transformQuat, rotateX, rotateY, rotateZ, angle, zero, str, exactEquals, equals, sub, mul, div, dist, sqrDist, len, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleAndAdd", function() { return scaleAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return negate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hermite", function() { return hermite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bezier", function() { return bezier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat4", function() { return transformMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat3", function() { return transformMat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformQuat", function() { return transformQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "angle", function() { return angle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zero", function() { return zero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dist", function() { return dist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrDist", function() { return sqrDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "../node_modules/gl-matrix/esm/common.js");

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  return out;
}
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {ReadonlyVec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Calculates the length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */

function fromValues(x, y, z) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the source vector
 * @returns {vec3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */

function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to ceil
 * @returns {vec3} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to floor
 * @returns {vec3} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to round
 * @returns {vec3} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
/**
 * Calculates the squared length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to negate
 * @returns {vec3} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to invert
 * @returns {vec3} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to normalize
 * @returns {vec3} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
/**
 * Calculates the dot product of two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2.0 * Math.PI;
  var z = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec3} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec3} out
 */

function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];
  var x = a[0],
      y = a[1],
      z = a[2]; // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);

  var uvx = qy * z - qz * y,
      uvy = qz * x - qx * z,
      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

  var uuvx = qy * uvz - qz * uvy,
      uuvy = qz * uvx - qx * uvz,
      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2; // vec3.scale(uuv, uuv, 2);

  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateX(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateY(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateZ(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2]; //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Get the angle between two 3D vectors
 * @param {ReadonlyVec3} a The first operand
 * @param {ReadonlyVec3} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      bx = b[0],
      by = b[1],
      bz = b[2],
      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),
      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),
      mag = mag1 * mag2,
      cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec3 to zero
 *
 * @param {vec3} out the receiving vector
 * @returns {vec3} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}
/**
 * Alias for {@link vec3.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec3.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec3.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec3.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec3.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }

    return a;
  };
}();

/***/ }),

/***/ "../node_modules/gl-matrix/esm/vec4.js":
/*!*********************************************!*\
  !*** ../node_modules/gl-matrix/esm/vec4.js ***!
  \*********************************************/
/*! exports provided: create, clone, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, length, squaredLength, negate, inverse, normalize, dot, cross, lerp, random, transformMat4, transformQuat, zero, str, exactEquals, equals, sub, mul, div, dist, sqrDist, len, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleAndAdd", function() { return scaleAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return negate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat4", function() { return transformMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformQuat", function() { return transformQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zero", function() { return zero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dist", function() { return dist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrDist", function() { return sqrDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "../node_modules/gl-matrix/esm/common.js");

/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }

  return out;
}
/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {ReadonlyVec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */

function fromValues(x, y, z, w) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the source vector
 * @returns {vec4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */

function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}
/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}
/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to ceil
 * @returns {vec4} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}
/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to floor
 * @returns {vec4} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}
/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}
/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}
/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to round
 * @returns {vec4} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}
/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Calculates the length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to negate
 * @returns {vec4} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}
/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to invert
 * @returns {vec4} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}
/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to normalize
 * @returns {vec4} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }

  out[0] = x * len;
  out[1] = y * len;
  out[2] = z * len;
  out[3] = w * len;
  return out;
}
/**
 * Calculates the dot product of two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
/**
 * Returns the cross-product of three vectors in a 4-dimensional space
 *
 * @param {ReadonlyVec4} result the receiving vector
 * @param {ReadonlyVec4} U the first vector
 * @param {ReadonlyVec4} V the second vector
 * @param {ReadonlyVec4} W the third vector
 * @returns {vec4} result
 */

function cross(out, u, v, w) {
  var A = v[0] * w[1] - v[1] * w[0],
      B = v[0] * w[2] - v[2] * w[0],
      C = v[0] * w[3] - v[3] * w[0],
      D = v[1] * w[2] - v[2] * w[1],
      E = v[1] * w[3] - v[3] * w[1],
      F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E + J * D;
  out[1] = -(G * F) + I * C - J * B;
  out[2] = G * E - H * C + J * A;
  out[3] = -(G * D) + H * B - I * A;
  return out;
}
/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec4} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */

function random(out, scale) {
  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a
  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
  // http://projecteuclid.org/euclid.aoms/1177692644;

  var v1, v2, v3, v4;
  var s1, s2;

  do {
    v1 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    v2 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);

  do {
    v3 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    v4 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);

  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale * v1;
  out[1] = scale * v2;
  out[2] = scale * v3 * d;
  out[3] = scale * v4 * d;
  return out;
}
/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec4} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec4} out
 */

function transformQuat(out, a, q) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3]; // calculate quat * vec

  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to zero
 *
 * @param {vec4} out the receiving vector
 * @returns {vec4} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Alias for {@link vec4.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec4.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec4.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec4.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec4.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 4;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }

    return a;
  };
}();

/***/ }),

/***/ "../node_modules/gltf-loader-ts/lib/gltf-loader.js":
/*!*********************************************************!*\
  !*** ../node_modules/gltf-loader-ts/lib/gltf-loader.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports=function(e){var t={};function r(i){if(t[i])return t[i].exports;var s=t[i]={i:i,l:!1,exports:{}};return e[i].call(s.exports,s,s.exports,r),s.l=!0,s.exports}return r.m=e,r.c=t,r.d=function(e,t,i){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:i})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var i=Object.create(null);if(r.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var s in e)r.d(i,s,function(t){return e[t]}.bind(null,s));return i},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=7)}([function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.LoadingManager=class{constructor(){this.urlModifier=void 0,this.onStart=void 0,this.onProgress=void 0,this.onLoad=void 0,this.onError=void 0,this.isLoading=!1,this.itemsLoaded=0,this.itemsTotal=0}itemStart(e){this.itemsTotal++,!this.isLoading&&this.onStart&&this.onStart(e,this.itemsLoaded,this.itemsTotal),this.isLoading=!0}itemEnd(e){this.itemsLoaded++,this.onProgress&&this.onProgress(e,this.itemsLoaded,this.itemsTotal),this.itemsLoaded===this.itemsTotal&&(this.isLoading=!1,this.onLoad&&this.onLoad())}itemError(e){this.onError&&this.onError(e)}resolveURL(e){return this.urlModifier?this.urlModifier(e):e}}},function(e,t,r){"use strict";var i=this&&this.__awaiter||function(e,t,r,i){return new(r||(r=Promise))(function(s,n){function o(e){try{u(i.next(e))}catch(e){n(e)}}function a(e){try{u(i.throw(e))}catch(e){n(e)}}function u(e){e.done?s(e.value):new r(function(t){t(e.value)}).then(o,a)}u((i=i.apply(e,t||[])).next())})};Object.defineProperty(t,"__esModule",{value:!0});const s=r(3),n=r(0);t.GLTF_COMPONENT_TYPE_ARRAYS={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},t.GLTF_ELEMENTS_PER_TYPE={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16};t.GltfAsset=class{constructor(e,t,r,i=new n.LoadingManager){this.gltf=e,this.glbData=r,this.bufferData=new o(this,t,i),this.imageData=new a(this,t,i)}bufferViewData(e){return i(this,void 0,void 0,function*(){if(!this.gltf.bufferViews)throw new Error("No buffer views found.");const t=this.gltf.bufferViews[e],r=yield this.bufferData.get(t.buffer),i=t.byteLength||0,s=t.byteOffset||0,n=r.buffer,o=r.byteOffset;return new Uint8Array(n,o+s,i)})}accessorData(e){return i(this,void 0,void 0,function*(){if(!this.gltf.accessors)throw new Error("No accessors views found.");const r=this.gltf.accessors[e],i=t.GLTF_ELEMENTS_PER_TYPE[r.type];let s;if(void 0!==r.bufferView)s=yield this.bufferViewData(r.bufferView);else{const e=t.GLTF_COMPONENT_TYPE_ARRAYS[r.componentType].BYTES_PER_ELEMENT*i*r.count;s=new Uint8Array(e)}if(r.sparse){const{count:e,indices:n,values:o}=r.sparse;let a=t.GLTF_COMPONENT_TYPE_ARRAYS[n.componentType],u=yield this.bufferViewData(n.bufferView);const f=new a(u.buffer,u.byteOffset+(n.byteOffset||0),e);a=t.GLTF_COMPONENT_TYPE_ARRAYS[r.componentType],u=yield this.bufferViewData(o.bufferView);const c=new a((yield this.bufferViewData(o.bufferView)).buffer,u.byteOffset+(o.byteOffset||0),e*i);r.bufferView&&(s=new Uint8Array(s));const h=new t.GLTF_COMPONENT_TYPE_ARRAYS[r.componentType](s.buffer);for(let t=0;t<e;t++)for(let e=0;e<i;e++)h[i*f[t]+e]=c[i*t+e]}return s})}preFetchAll(){return i(this,void 0,void 0,function*(){return Promise.all([this.bufferData.preFetchAll(),this.imageData.preFetchAll()])})}};class o{constructor(e,t,r){this.bufferCache=[],this.asset=e,this.baseUri=t,this.manager=r,this.loader=new s.FileLoader(r),this.loader.responseType="arraybuffer"}get(e){return i(this,void 0,void 0,function*(){if(void 0!==this.bufferCache[e])return this.bufferCache[e];const t=this.asset.gltf;if(!t.buffers)throw new Error("No buffers found.");const r=t.buffers[e];if(void 0===r.uri){if(0!==e)throw new Error("GLB container is required to be the first buffer");if(void 0===this.asset.glbData)throw new Error("invalid gltf: buffer has no uri nor is there a GLB buffer");return this.asset.glbData.binaryChunk}const i=u(r.uri,this.baseUri),s=yield this.loader.load(i),n=new Uint8Array(s);return this.bufferCache[e]=n,n})}preFetchAll(){return i(this,void 0,void 0,function*(){const e=this.asset.gltf.buffers;return e?Promise.all(e.map((e,t)=>this.get(t))):[]})}}t.BufferData=o;class a{constructor(e,t,r){this.crossOrigin="anonymous",this.imageCache=[],this.asset=e,this.baseUri=t,this.manager=r}get(e){return i(this,void 0,void 0,function*(){if(void 0!==this.imageCache[e])return this.imageCache[e];const t=this.asset.gltf;if(!t.images)throw new Error("No images found.");const r=t.images[e];let i,s=!1;if(void 0!==r.bufferView){const e=yield this.asset.bufferViewData(r.bufferView);s=!0;const t=new Blob([e],{type:r.mimeType});i=URL.createObjectURL(t)}else{if(void 0===r.uri)throw new Error("Invalid glTF: image must either have a `uri` or a `bufferView`");i=this.manager.resolveURL(u(r.uri,this.baseUri))}const n=new Image;return n.crossOrigin=this.crossOrigin,new Promise((t,r)=>{n.onerror=(()=>{r(`Failed to load ${i}`),this.manager.itemEnd(i),this.manager.itemError(i)}),n.onload=(()=>{s&&URL.revokeObjectURL(i),this.imageCache[e]=n,t(n),this.manager.itemEnd(i)}),n.src=i,this.manager.itemStart(i)})})}preFetchAll(){return i(this,void 0,void 0,function*(){const e=this.asset.gltf.images;return e?Promise.all(e.map((e,t)=>this.get(t))):[]})}}function u(e,t){return"string"!=typeof e||""===e?"":/^(https?:)?\/\//i.test(e)?e:/^data:.*,.*$/i.test(e)?e:/^blob:.*$/i.test(e)?e:t+e}t.ImageData=a,t.resolveURL=u},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.LoaderUtils=class{static decodeText(e){if("undefined"!=typeof TextDecoder)return(new TextDecoder).decode(e);let t="";for(const r of e)t+=String.fromCharCode(r);return decodeURIComponent(escape(t))}static extractUrlBase(e){const t=e.split("/");return 1===t.length?"./":(t.pop(),t.join("/")+"/")}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.FileLoader=class{constructor(e){this.runningRequests={},this.manager=e}load(e,t){if(void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e),this.runningRequests[e])return this.runningRequests[e];const r=new Promise((r,i)=>{const s=new XMLHttpRequest;s.open("GET",e,!0);const n=this;s.onload=function(t){const o=this.response;0===this.status?(console.warn("FileLoader: HTTP Status 0 received."),r(o),n.manager.itemEnd(e)):200===this.status?(r(o),n.manager.itemEnd(e)):(i({url:e,status:this.status,statusText:s.statusText}),n.manager.itemEnd(e),n.manager.itemError(e)),delete n.runningRequests[e]},s.onprogress=(e=>{t&&t(e)}),s.onerror=function(t){i({url:e,status:this.status,statusText:s.statusText}),n.manager.itemEnd(e),n.manager.itemError(e),delete n.runningRequests[e]},this.responseType&&(s.responseType=this.responseType),this.withCredentials&&(s.withCredentials=this.withCredentials),this.mimeType&&s.overrideMimeType&&s.overrideMimeType(void 0!==this.mimeType?this.mimeType:"text/plain");for(const e in this.requestHeaders)s.setRequestHeader(e,this.requestHeaders[e]);s.send(null),this.manager.itemStart(e)});return this.runningRequests[e]=r,r}setRequestHeader(e,t){return this.requestHeaders[e]=t,this}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0})},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=r(2);t.BINARY_HEADER_MAGIC="glTF";const s=12,n={JSON:1313821514,BIN:5130562};t.GLTFBinaryData=class{constructor(e){const r=new DataView(e,0,s),o=i.LoaderUtils.decodeText(new Uint8Array(e,0,4)),a=r.getUint32(4,!0);if(r.getUint32(8,!0),o!==t.BINARY_HEADER_MAGIC)throw new Error("Unsupported glTF-Binary header.");if(a<2)throw new Error("Unsupported legacy binary file detected.");const u=new DataView(e,s);let f=0;for(;f<u.byteLength;){const t=u.getUint32(f,!0);f+=4;const r=u.getUint32(f,!0);if(f+=4,r===n.JSON){const r=new Uint8Array(e,s+f,t);this.json=i.LoaderUtils.decodeText(r)}else if(r===n.BIN){const r=s+f;this.binaryChunk=new Uint8Array(e,r,t)}f+=t}if(null===this.json)throw new Error("glTF-Binary: JSON content not found.")}}},function(e,t,r){"use strict";var i=this&&this.__awaiter||function(e,t,r,i){return new(r||(r=Promise))(function(s,n){function o(e){try{u(i.next(e))}catch(e){n(e)}}function a(e){try{u(i.throw(e))}catch(e){n(e)}}function u(e){e.done?s(e.value):new r(function(t){t(e.value)}).then(o,a)}u((i=i.apply(e,t||[])).next())})};function s(e){for(var r in e)t.hasOwnProperty(r)||(t[r]=e[r])}Object.defineProperty(t,"__esModule",{value:!0});const n=r(3),o=r(5),a=r(1),u=r(2),f=r(0),c=r(4);t.gltf=c,s(r(1)),s(r(0));t.GltfLoader=class{constructor(e){this.manager=e||new f.LoadingManager}load(e,t){return i(this,void 0,void 0,function*(){const r=u.LoaderUtils.extractUrlBase(e),i=new n.FileLoader(this.manager);i.responseType="arraybuffer";const s=yield i.load(e,t);return yield this.parse(s,r)})}loadFromFiles(e){return i(this,void 0,void 0,function*(){let t,r;for(const[i,s]of e)s.name.match(/\.(gltf|glb)$/)&&(t=s,r=i.replace(s.name,""));if(!t)throw new Error("No .gltf or .glb asset found.");const i="string"==typeof t?t:URL.createObjectURL(t),s=u.LoaderUtils.extractUrlBase(i),n=[];this.manager.urlModifier=(t=>{const i=r+t.replace(s,"").replace(/^(\.?\/)/,"");if(e.has(i)){const t=e.get(i),r=URL.createObjectURL(t);return n.push(r),r}return t});const o=yield this.load(i);return yield o.preFetchAll(),URL.revokeObjectURL(i),n.forEach(URL.revokeObjectURL),o})}parse(e,t){return i(this,void 0,void 0,function*(){let r,i=void 0;r="string"==typeof e?e:u.LoaderUtils.decodeText(new Uint8Array(e,0,4))===o.BINARY_HEADER_MAGIC?(i=new o.GLTFBinaryData(e)).json:u.LoaderUtils.decodeText(new Uint8Array(e));const s=JSON.parse(r);if(void 0===s.asset||s.asset.version[0]<2)throw new Error("Unsupported asset. glTF versions >=2.0 are supported.");return new a.GltfAsset(s,t,i,this.manager)})}}},function(e,t,r){e.exports=r(6)}]);
//# sourceMappingURL=gltf-loader.js.map

/***/ }),

/***/ "../node_modules/jsonschema/lib/attribute.js":
/*!***************************************************!*\
  !*** ../node_modules/jsonschema/lib/attribute.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var helpers = __webpack_require__(/*! ./helpers */ "../node_modules/jsonschema/lib/helpers.js");

/** @type ValidatorResult */
var ValidatorResult = helpers.ValidatorResult;
/** @type SchemaError */
var SchemaError = helpers.SchemaError;

var attribute = {};

attribute.ignoreProperties = {
  // informative properties
  'id': true,
  'default': true,
  'description': true,
  'title': true,
  // arguments to other properties
  'exclusiveMinimum': true,
  'exclusiveMaximum': true,
  'additionalItems': true,
  // special-handled properties
  '$schema': true,
  '$ref': true,
  'extends': true,
};

/**
 * @name validators
 */
var validators = attribute.validators = {};

/**
 * Validates whether the instance if of a certain type
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {ValidatorResult|null}
 */
validators.type = function validateType (instance, schema, options, ctx) {
  // Ignore undefined instances
  if (instance === undefined) {
    return null;
  }
  var result = new ValidatorResult(instance, schema, options, ctx);
  var types = Array.isArray(schema.type) ? schema.type : [schema.type];
  if (!types.some(this.testType.bind(this, instance, schema, options, ctx))) {
    var list = types.map(function (v) {
      if(!v) return;
      return v.id && ('<' + v.id + '>') || (v+'');
    });
    result.addError({
      name: 'type',
      argument: list,
      message: "is not of a type(s) " + list,
    });
  }
  return result;
};

function testSchemaNoThrow(instance, options, ctx, callback, schema){
  var throwError = options.throwError;
  options.throwError = false;
  var res = this.validateSchema(instance, schema, options, ctx);
  options.throwError = throwError;

  if (!res.valid && callback instanceof Function) {
    callback(res);
  }
  return res.valid;
}

/**
 * Validates whether the instance matches some of the given schemas
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {ValidatorResult|null}
 */
validators.anyOf = function validateAnyOf (instance, schema, options, ctx) {
  // Ignore undefined instances
  if (instance === undefined) {
    return null;
  }
  var result = new ValidatorResult(instance, schema, options, ctx);
  var inner = new ValidatorResult(instance, schema, options, ctx);
  if (!Array.isArray(schema.anyOf)){
    throw new SchemaError("anyOf must be an array");
  }
  if (!schema.anyOf.some(
    testSchemaNoThrow.bind(
      this, instance, options, ctx, function(res){inner.importErrors(res);}
    ))) {
    var list = schema.anyOf.map(function (v, i) {
      return (v.id && ('<' + v.id + '>')) || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';
    });
    if (options.nestedErrors) {
      result.importErrors(inner);
    }
    result.addError({
      name: 'anyOf',
      argument: list,
      message: "is not any of " + list.join(','),
    });
  }
  return result;
};

/**
 * Validates whether the instance matches every given schema
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {String|null}
 */
validators.allOf = function validateAllOf (instance, schema, options, ctx) {
  // Ignore undefined instances
  if (instance === undefined) {
    return null;
  }
  if (!Array.isArray(schema.allOf)){
    throw new SchemaError("allOf must be an array");
  }
  var result = new ValidatorResult(instance, schema, options, ctx);
  var self = this;
  schema.allOf.forEach(function(v, i){
    var valid = self.validateSchema(instance, v, options, ctx);
    if(!valid.valid){
      var msg = (v.id && ('<' + v.id + '>')) || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';
      result.addError({
        name: 'allOf',
        argument: { id: msg, length: valid.errors.length, valid: valid },
        message: 'does not match allOf schema ' + msg + ' with ' + valid.errors.length + ' error[s]:',
      });
      result.importErrors(valid);
    }
  });
  return result;
};

/**
 * Validates whether the instance matches exactly one of the given schemas
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {String|null}
 */
validators.oneOf = function validateOneOf (instance, schema, options, ctx) {
  // Ignore undefined instances
  if (instance === undefined) {
    return null;
  }
  if (!Array.isArray(schema.oneOf)){
    throw new SchemaError("oneOf must be an array");
  }
  var result = new ValidatorResult(instance, schema, options, ctx);
  var inner = new ValidatorResult(instance, schema, options, ctx);
  var count = schema.oneOf.filter(
    testSchemaNoThrow.bind(
      this, instance, options, ctx, function(res) {inner.importErrors(res);}
    ) ).length;
  var list = schema.oneOf.map(function (v, i) {
    return (v.id && ('<' + v.id + '>')) || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';
  });
  if (count!==1) {
    if (options.nestedErrors) {
      result.importErrors(inner);
    }
    result.addError({
      name: 'oneOf',
      argument: list,
      message: "is not exactly one from " + list.join(','),
    });
  }
  return result;
};

function getEnumerableProperty(object, key){
  // Determine if `key` shows up in `for(var key in object)`
  // First test Object.hasOwnProperty.call as an optimization: that guarantees it does
  if(Object.hasOwnProperty.call(object, key)) return object[key];
  // Test `key in object` as an optimization; false means it won't
  if(!(key in object)) return;
  while(object = Object.getPrototypeOf(object)){
    if(Object.propertyIsEnumerable.call(object, key)) return object[key];
  }
}

/**
 * Validates properties
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {String|null|ValidatorResult}
 */
validators.properties = function validateProperties (instance, schema, options, ctx) {
  if(!this.types.object(instance)) return;
  var result = new ValidatorResult(instance, schema, options, ctx);
  var properties = schema.properties || {};
  for (var property in properties) {
    var subschema = properties[property];
    if(subschema===undefined){
      continue;
    }else if(subschema===null){
      throw new SchemaError('Unexpected null, expected schema in "properties"');
    }
    if (typeof options.preValidateProperty == 'function') {
      options.preValidateProperty(instance, property, subschema, options, ctx);
    }
    var prop = getEnumerableProperty(instance, property);
    var res = this.validateSchema(prop, subschema, options, ctx.makeChild(subschema, property));
    if(res.instance !== result.instance[property]) result.instance[property] = res.instance;
    result.importErrors(res);
  }
  return result;
};

/**
 * Test a specific property within in instance against the additionalProperties schema attribute
 * This ignores properties with definitions in the properties schema attribute, but no other attributes.
 * If too many more types of property-existence tests pop up they may need their own class of tests (like `type` has)
 * @private
 * @return {boolean}
 */
function testAdditionalProperty (instance, schema, options, ctx, property, result) {
  if(!this.types.object(instance)) return;
  if (schema.properties && schema.properties[property] !== undefined) {
    return;
  }
  if (schema.additionalProperties === false) {
    result.addError({
      name: 'additionalProperties',
      argument: property,
      message: "additionalProperty " + JSON.stringify(property) + " exists in instance when not allowed",
    });
  } else {
    var additionalProperties = schema.additionalProperties || {};

    if (typeof options.preValidateProperty == 'function') {
      options.preValidateProperty(instance, property, additionalProperties, options, ctx);
    }

    var res = this.validateSchema(instance[property], additionalProperties, options, ctx.makeChild(additionalProperties, property));
    if(res.instance !== result.instance[property]) result.instance[property] = res.instance;
    result.importErrors(res);
  }
}

/**
 * Validates patternProperties
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {String|null|ValidatorResult}
 */
validators.patternProperties = function validatePatternProperties (instance, schema, options, ctx) {
  if(!this.types.object(instance)) return;
  var result = new ValidatorResult(instance, schema, options, ctx);
  var patternProperties = schema.patternProperties || {};

  for (var property in instance) {
    var test = true;
    for (var pattern in patternProperties) {
      var subschema = patternProperties[pattern];
      if(subschema===undefined){
        continue;
      }else if(subschema===null){
        throw new SchemaError('Unexpected null, expected schema in "patternProperties"');
      }
      try {
        var regexp = new RegExp(pattern, 'u');
      } catch(_e) {
        // In the event the stricter handling causes an error, fall back on the forgiving handling
        // DEPRECATED
        regexp = new RegExp(pattern);
      }
      if (!regexp.test(property)) {
        continue;
      }
      test = false;

      if (typeof options.preValidateProperty == 'function') {
        options.preValidateProperty(instance, property, subschema, options, ctx);
      }

      var res = this.validateSchema(instance[property], subschema, options, ctx.makeChild(subschema, property));
      if(res.instance !== result.instance[property]) result.instance[property] = res.instance;
      result.importErrors(res);
    }
    if (test) {
      testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);
    }
  }

  return result;
};

/**
 * Validates additionalProperties
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {String|null|ValidatorResult}
 */
validators.additionalProperties = function validateAdditionalProperties (instance, schema, options, ctx) {
  if(!this.types.object(instance)) return;
  // if patternProperties is defined then we'll test when that one is called instead
  if (schema.patternProperties) {
    return null;
  }
  var result = new ValidatorResult(instance, schema, options, ctx);
  for (var property in instance) {
    testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);
  }
  return result;
};

/**
 * Validates whether the instance value is at least of a certain length, when the instance value is a string.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.minProperties = function validateMinProperties (instance, schema, options, ctx) {
  if (!this.types.object(instance)) return;
  var result = new ValidatorResult(instance, schema, options, ctx);
  var keys = Object.keys(instance);
  if (!(keys.length >= schema.minProperties)) {
    result.addError({
      name: 'minProperties',
      argument: schema.minProperties,
      message: "does not meet minimum property length of " + schema.minProperties,
    });
  }
  return result;
};

/**
 * Validates whether the instance value is at most of a certain length, when the instance value is a string.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.maxProperties = function validateMaxProperties (instance, schema, options, ctx) {
  if (!this.types.object(instance)) return;
  var result = new ValidatorResult(instance, schema, options, ctx);
  var keys = Object.keys(instance);
  if (!(keys.length <= schema.maxProperties)) {
    result.addError({
      name: 'maxProperties',
      argument: schema.maxProperties,
      message: "does not meet maximum property length of " + schema.maxProperties,
    });
  }
  return result;
};

/**
 * Validates items when instance is an array
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {String|null|ValidatorResult}
 */
validators.items = function validateItems (instance, schema, options, ctx) {
  var self = this;
  if (!this.types.array(instance)) return;
  if (!schema.items) return;
  var result = new ValidatorResult(instance, schema, options, ctx);
  instance.every(function (value, i) {
    var items = Array.isArray(schema.items) ? (schema.items[i] || schema.additionalItems) : schema.items;
    if (items === undefined) {
      return true;
    }
    if (items === false) {
      result.addError({
        name: 'items',
        message: "additionalItems not permitted",
      });
      return false;
    }
    var res = self.validateSchema(value, items, options, ctx.makeChild(items, i));
    if(res.instance !== result.instance[i]) result.instance[i] = res.instance;
    result.importErrors(res);
    return true;
  });
  return result;
};

/**
 * Validates minimum and exclusiveMinimum when the type of the instance value is a number.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.minimum = function validateMinimum (instance, schema, options, ctx) {
  if (!this.types.number(instance)) return;
  var result = new ValidatorResult(instance, schema, options, ctx);
  var valid = true;
  if (schema.exclusiveMinimum && schema.exclusiveMinimum === true) {
    valid = instance > schema.minimum;
  } else {
    valid = instance >= schema.minimum;
  }
  if (!valid) {
    result.addError({
      name: 'minimum',
      argument: schema.minimum,
      message: "must have a minimum value of " + schema.minimum,
    });
  }
  return result;
};

/**
 * Validates maximum and exclusiveMaximum when the type of the instance value is a number.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.maximum = function validateMaximum (instance, schema, options, ctx) {
  if (!this.types.number(instance)) return;
  var result = new ValidatorResult(instance, schema, options, ctx);
  var valid;
  if (schema.exclusiveMaximum && schema.exclusiveMaximum === true) {
    valid = instance < schema.maximum;
  } else {
    valid = instance <= schema.maximum;
  }
  if (!valid) {
    result.addError({
      name: 'maximum',
      argument: schema.maximum,
      message: "must have a maximum value of " + schema.maximum,
    });
  }
  return result;
};

/**
 * Perform validation for multipleOf and divisibleBy, which are essentially the same.
 * @param instance
 * @param schema
 * @param validationType
 * @param errorMessage
 * @returns {String|null}
 */
var validateMultipleOfOrDivisbleBy = function validateMultipleOfOrDivisbleBy (instance, schema, options, ctx, validationType, errorMessage) {
  if (!this.types.number(instance)) return;

  var validationArgument = schema[validationType];
  if (validationArgument == 0) {
    throw new SchemaError(validationType + " cannot be zero");
  }

  var result = new ValidatorResult(instance, schema, options, ctx);

  var instanceDecimals = helpers.getDecimalPlaces(instance);
  var divisorDecimals = helpers.getDecimalPlaces(validationArgument);

  var maxDecimals = Math.max(instanceDecimals , divisorDecimals);
  var multiplier = Math.pow(10, maxDecimals);

  if (Math.round(instance * multiplier) % Math.round(validationArgument * multiplier) !== 0) {
    result.addError({
      name: validationType,
      argument:  validationArgument,
      message: errorMessage + JSON.stringify(validationArgument),
    });
  }

  return result;
};

/**
 * Validates divisibleBy when the type of the instance value is a number.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.multipleOf = function validateMultipleOf (instance, schema, options, ctx) {
  return validateMultipleOfOrDivisbleBy.call(this, instance, schema, options, ctx, "multipleOf", "is not a multiple of (divisible by) ");
};

/**
 * Validates multipleOf when the type of the instance value is a number.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.divisibleBy = function validateDivisibleBy (instance, schema, options, ctx) {
  return validateMultipleOfOrDivisbleBy.call(this, instance, schema, options, ctx, "divisibleBy", "is not divisible by (multiple of) ");
};

/**
 * Validates whether the instance value is present.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.required = function validateRequired (instance, schema, options, ctx) {
  var result = new ValidatorResult(instance, schema, options, ctx);
  if (instance === undefined && schema.required === true) {
    // A boolean form is implemented for reverse-compatibility with schemas written against older drafts
    result.addError({
      name: 'required',
      message: "is required",
    });
  } else if (this.types.object(instance) && Array.isArray(schema.required)) {
    schema.required.forEach(function(n){
      if(getEnumerableProperty(instance, n)===undefined){
        result.addError({
          name: 'required',
          argument: n,
          message: "requires property " + JSON.stringify(n),
        });
      }
    });
  }
  return result;
};

/**
 * Validates whether the instance value matches the regular expression, when the instance value is a string.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.pattern = function validatePattern (instance, schema, options, ctx) {
  if (!this.types.string(instance)) return;
  var result = new ValidatorResult(instance, schema, options, ctx);
  var pattern = schema.pattern;
  try {
    var regexp = new RegExp(pattern, 'u');
  } catch(_e) {
    // In the event the stricter handling causes an error, fall back on the forgiving handling
    // DEPRECATED
    regexp = new RegExp(pattern);
  }
  if (!instance.match(regexp)) {
    result.addError({
      name: 'pattern',
      argument: schema.pattern,
      message: "does not match pattern " + JSON.stringify(schema.pattern.toString()),
    });
  }
  return result;
};

/**
 * Validates whether the instance value is of a certain defined format or a custom
 * format.
 * The following formats are supported for string types:
 *   - date-time
 *   - date
 *   - time
 *   - ip-address
 *   - ipv6
 *   - uri
 *   - color
 *   - host-name
 *   - alpha
 *   - alpha-numeric
 *   - utc-millisec
 * @param instance
 * @param schema
 * @param [options]
 * @param [ctx]
 * @return {String|null}
 */
validators.format = function validateFormat (instance, schema, options, ctx) {
  if (instance===undefined) return;
  var result = new ValidatorResult(instance, schema, options, ctx);
  if (!result.disableFormat && !helpers.isFormat(instance, schema.format, this)) {
    result.addError({
      name: 'format',
      argument: schema.format,
      message: "does not conform to the " + JSON.stringify(schema.format) + " format",
    });
  }
  return result;
};

/**
 * Validates whether the instance value is at least of a certain length, when the instance value is a string.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.minLength = function validateMinLength (instance, schema, options, ctx) {
  if (!this.types.string(instance)) return;
  var result = new ValidatorResult(instance, schema, options, ctx);
  var hsp = instance.match(/[\uDC00-\uDFFF]/g);
  var length = instance.length - (hsp ? hsp.length : 0);
  if (!(length >= schema.minLength)) {
    result.addError({
      name: 'minLength',
      argument: schema.minLength,
      message: "does not meet minimum length of " + schema.minLength,
    });
  }
  return result;
};

/**
 * Validates whether the instance value is at most of a certain length, when the instance value is a string.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.maxLength = function validateMaxLength (instance, schema, options, ctx) {
  if (!this.types.string(instance)) return;
  var result = new ValidatorResult(instance, schema, options, ctx);
  // TODO if this was already computed in "minLength", use that value instead of re-computing
  var hsp = instance.match(/[\uDC00-\uDFFF]/g);
  var length = instance.length - (hsp ? hsp.length : 0);
  if (!(length <= schema.maxLength)) {
    result.addError({
      name: 'maxLength',
      argument: schema.maxLength,
      message: "does not meet maximum length of " + schema.maxLength,
    });
  }
  return result;
};

/**
 * Validates whether instance contains at least a minimum number of items, when the instance is an Array.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.minItems = function validateMinItems (instance, schema, options, ctx) {
  if (!this.types.array(instance)) return;
  var result = new ValidatorResult(instance, schema, options, ctx);
  if (!(instance.length >= schema.minItems)) {
    result.addError({
      name: 'minItems',
      argument: schema.minItems,
      message: "does not meet minimum length of " + schema.minItems,
    });
  }
  return result;
};

/**
 * Validates whether instance contains no more than a maximum number of items, when the instance is an Array.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.maxItems = function validateMaxItems (instance, schema, options, ctx) {
  if (!this.types.array(instance)) return;
  var result = new ValidatorResult(instance, schema, options, ctx);
  if (!(instance.length <= schema.maxItems)) {
    result.addError({
      name: 'maxItems',
      argument: schema.maxItems,
      message: "does not meet maximum length of " + schema.maxItems,
    });
  }
  return result;
};

/**
 * Deep compares arrays for duplicates
 * @param v
 * @param i
 * @param a
 * @private
 * @return {boolean}
 */
function testArrays (v, i, a) {
  var j, len = a.length;
  for (j = i + 1, len; j < len; j++) {
    if (helpers.deepCompareStrict(v, a[j])) {
      return false;
    }
  }
  return true;
}

/**
 * Validates whether there are no duplicates, when the instance is an Array.
 * @param instance
 * @return {String|null}
 */
validators.uniqueItems = function validateUniqueItems (instance, schema, options, ctx) {
  if (schema.uniqueItems!==true) return;
  if (!this.types.array(instance)) return;
  var result = new ValidatorResult(instance, schema, options, ctx);
  if (!instance.every(testArrays)) {
    result.addError({
      name: 'uniqueItems',
      message: "contains duplicate item",
    });
  }
  return result;
};

/**
 * Validate for the presence of dependency properties, if the instance is an object.
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {null|ValidatorResult}
 */
validators.dependencies = function validateDependencies (instance, schema, options, ctx) {
  if (!this.types.object(instance)) return;
  var result = new ValidatorResult(instance, schema, options, ctx);
  for (var property in schema.dependencies) {
    if (instance[property] === undefined) {
      continue;
    }
    var dep = schema.dependencies[property];
    var childContext = ctx.makeChild(dep, property);
    if (typeof dep == 'string') {
      dep = [dep];
    }
    if (Array.isArray(dep)) {
      dep.forEach(function (prop) {
        if (instance[prop] === undefined) {
          result.addError({
            // FIXME there's two different "dependencies" errors here with slightly different outputs
            // Can we make these the same? Or should we create different error types?
            name: 'dependencies',
            argument: childContext.propertyPath,
            message: "property " + prop + " not found, required by " + childContext.propertyPath,
          });
        }
      });
    } else {
      var res = this.validateSchema(instance, dep, options, childContext);
      if(result.instance !== res.instance) result.instance = res.instance;
      if (res && res.errors.length) {
        result.addError({
          name: 'dependencies',
          argument: childContext.propertyPath,
          message: "does not meet dependency required by " + childContext.propertyPath,
        });
        result.importErrors(res);
      }
    }
  }
  return result;
};

/**
 * Validates whether the instance value is one of the enumerated values.
 *
 * @param instance
 * @param schema
 * @return {ValidatorResult|null}
 */
validators['enum'] = function validateEnum (instance, schema, options, ctx) {
  if (instance === undefined) {
    return null;
  }
  if (!Array.isArray(schema['enum'])) {
    throw new SchemaError("enum expects an array", schema);
  }
  var result = new ValidatorResult(instance, schema, options, ctx);
  if (!schema['enum'].some(helpers.deepCompareStrict.bind(null, instance))) {
    result.addError({
      name: 'enum',
      argument: schema['enum'],
      message: "is not one of enum values: " + schema['enum'].map(String).join(','),
    });
  }
  return result;
};

/**
 * Validates whether the instance exactly matches a given value
 *
 * @param instance
 * @param schema
 * @return {ValidatorResult|null}
 */
validators['const'] = function validateEnum (instance, schema, options, ctx) {
  if (instance === undefined) {
    return null;
  }
  var result = new ValidatorResult(instance, schema, options, ctx);
  if (!helpers.deepCompareStrict(schema['const'], instance)) {
    result.addError({
      name: 'const',
      argument: schema['const'],
      message: "does not exactly match expected constant: " + schema['const'],
    });
  }
  return result;
};

/**
 * Validates whether the instance if of a prohibited type.
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {null|ValidatorResult}
 */
validators.not = validators.disallow = function validateNot (instance, schema, options, ctx) {
  var self = this;
  if(instance===undefined) return null;
  var result = new ValidatorResult(instance, schema, options, ctx);
  var notTypes = schema.not || schema.disallow;
  if(!notTypes) return null;
  if(!Array.isArray(notTypes)) notTypes=[notTypes];
  notTypes.forEach(function (type) {
    if (self.testType(instance, schema, options, ctx, type)) {
      var schemaId = type && type.id && ('<' + type.id + '>') || type;
      result.addError({
        name: 'not',
        argument: schemaId,
        message: "is of prohibited type " + schemaId,
      });
    }
  });
  return result;
};

module.exports = attribute;


/***/ }),

/***/ "../node_modules/jsonschema/lib/helpers.js":
/*!*************************************************!*\
  !*** ../node_modules/jsonschema/lib/helpers.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var uri = __webpack_require__(/*! url */ "../node_modules/url/url.js");

var ValidationError = exports.ValidationError = function ValidationError (message, instance, schema, propertyPath, name, argument) {
  if (propertyPath) {
    this.property = propertyPath;
  }
  if (message) {
    this.message = message;
  }
  if (schema) {
    if (schema.id) {
      this.schema = schema.id;
    } else {
      this.schema = schema;
    }
  }
  if (instance !== undefined) {
    this.instance = instance;
  }
  this.name = name;
  this.argument = argument;
  this.stack = this.toString();
};

ValidationError.prototype.toString = function toString() {
  return this.property + ' ' + this.message;
};

var ValidatorResult = exports.ValidatorResult = function ValidatorResult(instance, schema, options, ctx) {
  this.instance = instance;
  this.schema = schema;
  this.propertyPath = ctx.propertyPath;
  this.errors = [];
  this.throwError = options && options.throwError;
  this.disableFormat = options && options.disableFormat === true;
};

ValidatorResult.prototype.addError = function addError(detail) {
  var err;
  if (typeof detail == 'string') {
    err = new ValidationError(detail, this.instance, this.schema, this.propertyPath);
  } else {
    if (!detail) throw new Error('Missing error detail');
    if (!detail.message) throw new Error('Missing error message');
    if (!detail.name) throw new Error('Missing validator type');
    err = new ValidationError(detail.message, this.instance, this.schema, this.propertyPath, detail.name, detail.argument);
  }

  if (this.throwError) {
    throw err;
  }
  this.errors.push(err);
  return err;
};

ValidatorResult.prototype.importErrors = function importErrors(res) {
  if (typeof res == 'string' || (res && res.validatorType)) {
    this.addError(res);
  } else if (res && res.errors) {
    Array.prototype.push.apply(this.errors, res.errors);
  }
};

function stringizer (v,i){
  return i+': '+v.toString()+'\n';
}
ValidatorResult.prototype.toString = function toString(res) {
  return this.errors.map(stringizer).join('');
};

Object.defineProperty(ValidatorResult.prototype, "valid", { get: function() {
  return !this.errors.length;
} });

/**
 * Describes a problem with a Schema which prevents validation of an instance
 * @name SchemaError
 * @constructor
 */
var SchemaError = exports.SchemaError = function SchemaError (msg, schema) {
  this.message = msg;
  this.schema = schema;
  Error.call(this, msg);
  Error.captureStackTrace(this, SchemaError);
};
SchemaError.prototype = Object.create(Error.prototype,
  {
    constructor: {value: SchemaError, enumerable: false},
    name: {value: 'SchemaError', enumerable: false},
  });

var SchemaContext = exports.SchemaContext = function SchemaContext (schema, options, propertyPath, base, schemas) {
  this.schema = schema;
  this.options = options;
  this.propertyPath = propertyPath;
  this.base = base;
  this.schemas = schemas;
};

SchemaContext.prototype.resolve = function resolve (target) {
  return uri.resolve(this.base, target);
};

SchemaContext.prototype.makeChild = function makeChild(schema, propertyName){
  var propertyPath = (propertyName===undefined) ? this.propertyPath : this.propertyPath+makeSuffix(propertyName);
  var base = uri.resolve(this.base, schema.id||'');
  var ctx = new SchemaContext(schema, this.options, propertyPath, base, Object.create(this.schemas));
  if(schema.id && !ctx.schemas[base]){
    ctx.schemas[base] = schema;
  }
  return ctx;
};

var FORMAT_REGEXPS = exports.FORMAT_REGEXPS = {
  'date-time': /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-(3[01]|0[1-9]|[12][0-9])[tT ](2[0-4]|[01][0-9]):([0-5][0-9]):(60|[0-5][0-9])(\.\d+)?([zZ]|[+-]([0-5][0-9]):(60|[0-5][0-9]))$/,
  'date': /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-(3[01]|0[1-9]|[12][0-9])$/,
  'time': /^(2[0-4]|[01][0-9]):([0-5][0-9]):(60|[0-5][0-9])$/,

  'email': /^(?:[\w\!\#\$\%\&\'\*\+\-\/\=\?\^\`\{\|\}\~]+\.)*[\w\!\#\$\%\&\'\*\+\-\/\=\?\^\`\{\|\}\~]+@(?:(?:(?:[a-zA-Z0-9](?:[a-zA-Z0-9\-](?!\.)){0,61}[a-zA-Z0-9]?\.)+[a-zA-Z0-9](?:[a-zA-Z0-9\-](?!$)){0,61}[a-zA-Z0-9]?)|(?:\[(?:(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\.){3}(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\]))$/,
  'ip-address': /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/,
  'ipv6': /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/,
  'uri': /^[a-zA-Z][a-zA-Z0-9+-.]*:[^\s]*$/,

  'color': /^(#?([0-9A-Fa-f]{3}){1,2}\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\)))$/,

  // hostname regex from: http://stackoverflow.com/a/1420225/5628
  'hostname': /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\.?$/,
  'host-name': /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\.?$/,

  'alpha': /^[a-zA-Z]+$/,
  'alphanumeric': /^[a-zA-Z0-9]+$/,
  'utc-millisec': function (input) {
    return (typeof input === 'string') && parseFloat(input) === parseInt(input, 10) && !isNaN(input);
  },
  'regex': function (input) {
    var result = true;
    try {
      new RegExp(input);
    } catch (e) {
      result = false;
    }
    return result;
  },
  'style': /\s*(.+?):\s*([^;]+);?/,
  'phone': /^\+(?:[0-9] ?){6,14}[0-9]$/,
};

FORMAT_REGEXPS.regexp = FORMAT_REGEXPS.regex;
FORMAT_REGEXPS.pattern = FORMAT_REGEXPS.regex;
FORMAT_REGEXPS.ipv4 = FORMAT_REGEXPS['ip-address'];

exports.isFormat = function isFormat (input, format, validator) {
  if (typeof input === 'string' && FORMAT_REGEXPS[format] !== undefined) {
    if (FORMAT_REGEXPS[format] instanceof RegExp) {
      return FORMAT_REGEXPS[format].test(input);
    }
    if (typeof FORMAT_REGEXPS[format] === 'function') {
      return FORMAT_REGEXPS[format](input);
    }
  } else if (validator && validator.customFormats &&
      typeof validator.customFormats[format] === 'function') {
    return validator.customFormats[format](input);
  }
  return true;
};

var makeSuffix = exports.makeSuffix = function makeSuffix (key) {
  key = key.toString();
  // This function could be capable of outputting valid a ECMAScript string, but the
  // resulting code for testing which form to use would be tens of thousands of characters long
  // That means this will use the name form for some illegal forms
  if (!key.match(/[.\s\[\]]/) && !key.match(/^[\d]/)) {
    return '.' + key;
  }
  if (key.match(/^\d+$/)) {
    return '[' + key + ']';
  }
  return '[' + JSON.stringify(key) + ']';
};

exports.deepCompareStrict = function deepCompareStrict (a, b) {
  if (typeof a !== typeof b) {
    return false;
  }
  if (Array.isArray(a)) {
    if (!Array.isArray(b)) {
      return false;
    }
    if (a.length !== b.length) {
      return false;
    }
    return a.every(function (v, i) {
      return deepCompareStrict(a[i], b[i]);
    });
  }
  if (typeof a === 'object') {
    if (!a || !b) {
      return a === b;
    }
    var aKeys = Object.keys(a);
    var bKeys = Object.keys(b);
    if (aKeys.length !== bKeys.length) {
      return false;
    }
    return aKeys.every(function (v) {
      return deepCompareStrict(a[v], b[v]);
    });
  }
  return a === b;
};

function deepMerger (target, dst, e, i) {
  if (typeof e === 'object') {
    dst[i] = deepMerge(target[i], e);
  } else {
    if (target.indexOf(e) === -1) {
      dst.push(e);
    }
  }
}

function copyist (src, dst, key) {
  dst[key] = src[key];
}

function copyistWithDeepMerge (target, src, dst, key) {
  if (typeof src[key] !== 'object' || !src[key]) {
    dst[key] = src[key];
  }
  else {
    if (!target[key]) {
      dst[key] = src[key];
    } else {
      dst[key] = deepMerge(target[key], src[key]);
    }
  }
}

function deepMerge (target, src) {
  var array = Array.isArray(src);
  var dst = array && [] || {};

  if (array) {
    target = target || [];
    dst = dst.concat(target);
    src.forEach(deepMerger.bind(null, target, dst));
  } else {
    if (target && typeof target === 'object') {
      Object.keys(target).forEach(copyist.bind(null, target, dst));
    }
    Object.keys(src).forEach(copyistWithDeepMerge.bind(null, target, src, dst));
  }

  return dst;
}

module.exports.deepMerge = deepMerge;

/**
 * Validates instance against the provided schema
 * Implements URI+JSON Pointer encoding, e.g. "%7e"="~0"=>"~", "~1"="%2f"=>"/"
 * @param o
 * @param s The path to walk o along
 * @return any
 */
exports.objectGetPath = function objectGetPath(o, s) {
  var parts = s.split('/').slice(1);
  var k;
  while (typeof (k=parts.shift()) == 'string') {
    var n = decodeURIComponent(k.replace(/~0/,'~').replace(/~1/g,'/'));
    if (!(n in o)) return;
    o = o[n];
  }
  return o;
};

function pathEncoder (v) {
  return '/'+encodeURIComponent(v).replace(/~/g,'%7E');
}
/**
 * Accept an Array of property names and return a JSON Pointer URI fragment
 * @param Array a
 * @return {String}
 */
exports.encodePath = function encodePointer(a){
  // ~ must be encoded explicitly because hacks
  // the slash is encoded by encodeURIComponent
  return a.map(pathEncoder).join('');
};


/**
 * Calculate the number of decimal places a number uses
 * We need this to get correct results out of multipleOf and divisibleBy
 * when either figure is has decimal places, due to IEEE-754 float issues.
 * @param number
 * @returns {number}
 */
exports.getDecimalPlaces = function getDecimalPlaces(number) {

  var decimalPlaces = 0;
  if (isNaN(number)) return decimalPlaces;

  if (typeof number !== 'number') {
    number = Number(number);
  }

  var parts = number.toString().split('e');
  if (parts.length === 2) {
    if (parts[1][0] !== '-') {
      return decimalPlaces;
    } else {
      decimalPlaces = Number(parts[1].slice(1));
    }
  }

  var decimalParts = parts[0].split('.');
  if (decimalParts.length === 2) {
    decimalPlaces += decimalParts[1].length;
  }

  return decimalPlaces;
};



/***/ }),

/***/ "../node_modules/jsonschema/lib/index.js":
/*!***********************************************!*\
  !*** ../node_modules/jsonschema/lib/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Validator = module.exports.Validator = __webpack_require__(/*! ./validator */ "../node_modules/jsonschema/lib/validator.js");

module.exports.ValidatorResult = __webpack_require__(/*! ./helpers */ "../node_modules/jsonschema/lib/helpers.js").ValidatorResult;
module.exports.ValidationError = __webpack_require__(/*! ./helpers */ "../node_modules/jsonschema/lib/helpers.js").ValidationError;
module.exports.SchemaError = __webpack_require__(/*! ./helpers */ "../node_modules/jsonschema/lib/helpers.js").SchemaError;
module.exports.SchemaScanResult = __webpack_require__(/*! ./scan */ "../node_modules/jsonschema/lib/scan.js").SchemaScanResult;
module.exports.scan = __webpack_require__(/*! ./scan */ "../node_modules/jsonschema/lib/scan.js").scan;

module.exports.validate = function (instance, schema, options) {
  var v = new Validator();
  return v.validate(instance, schema, options);
};


/***/ }),

/***/ "../node_modules/jsonschema/lib/scan.js":
/*!**********************************************!*\
  !*** ../node_modules/jsonschema/lib/scan.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var urilib = __webpack_require__(/*! url */ "../node_modules/url/url.js");
var helpers = __webpack_require__(/*! ./helpers */ "../node_modules/jsonschema/lib/helpers.js");

module.exports.SchemaScanResult = SchemaScanResult;
function SchemaScanResult(found, ref){
  this.id = found;
  this.ref = ref;
}

/**
 * Adds a schema with a certain urn to the Validator instance.
 * @param string uri
 * @param object schema
 * @return {Object}
 */
module.exports.scan = function scan(base, schema){
  function scanSchema(baseuri, schema){
    if(!schema || typeof schema!='object') return;
    // Mark all referenced schemas so we can tell later which schemas are referred to, but never defined
    if(schema.$ref){
      var resolvedUri = urilib.resolve(baseuri, schema.$ref);
      ref[resolvedUri] = ref[resolvedUri] ? ref[resolvedUri]+1 : 0;
      return;
    }
    var ourBase = schema.id ? urilib.resolve(baseuri, schema.id) : baseuri;
    if (ourBase) {
      // If there's no fragment, append an empty one
      if(ourBase.indexOf('#')<0) ourBase += '#';
      if(found[ourBase]){
        if(!helpers.deepCompareStrict(found[ourBase], schema)){
          throw new Error('Schema <'+ourBase+'> already exists with different definition');
        }
        return found[ourBase];
      }
      found[ourBase] = schema;
      // strip trailing fragment
      if(ourBase[ourBase.length-1]=='#'){
        found[ourBase.substring(0, ourBase.length-1)] = schema;
      }
    }
    scanArray(ourBase+'/items', (Array.isArray(schema.items)?schema.items:[schema.items]));
    scanArray(ourBase+'/extends', (Array.isArray(schema.extends)?schema.extends:[schema.extends]));
    scanSchema(ourBase+'/additionalItems', schema.additionalItems);
    scanObject(ourBase+'/properties', schema.properties);
    scanSchema(ourBase+'/additionalProperties', schema.additionalProperties);
    scanObject(ourBase+'/definitions', schema.definitions);
    scanObject(ourBase+'/patternProperties', schema.patternProperties);
    scanObject(ourBase+'/dependencies', schema.dependencies);
    scanArray(ourBase+'/disallow', schema.disallow);
    scanArray(ourBase+'/allOf', schema.allOf);
    scanArray(ourBase+'/anyOf', schema.anyOf);
    scanArray(ourBase+'/oneOf', schema.oneOf);
    scanSchema(ourBase+'/not', schema.not);
  }
  function scanArray(baseuri, schemas){
    if(!Array.isArray(schemas)) return;
    for(var i=0; i<schemas.length; i++){
      scanSchema(baseuri+'/'+i, schemas[i]);
    }
  }
  function scanObject(baseuri, schemas){
    if(!schemas || typeof schemas!='object') return;
    for(var p in schemas){
      scanSchema(baseuri+'/'+p, schemas[p]);
    }
  }

  var found = {};
  var ref = {};
  scanSchema(base, schema);
  return new SchemaScanResult(found, ref);
};


/***/ }),

/***/ "../node_modules/jsonschema/lib/validator.js":
/*!***************************************************!*\
  !*** ../node_modules/jsonschema/lib/validator.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var urilib = __webpack_require__(/*! url */ "../node_modules/url/url.js");

var attribute = __webpack_require__(/*! ./attribute */ "../node_modules/jsonschema/lib/attribute.js");
var helpers = __webpack_require__(/*! ./helpers */ "../node_modules/jsonschema/lib/helpers.js");
var scanSchema = __webpack_require__(/*! ./scan */ "../node_modules/jsonschema/lib/scan.js").scan;
var ValidatorResult = helpers.ValidatorResult;
var SchemaError = helpers.SchemaError;
var SchemaContext = helpers.SchemaContext;
//var anonymousBase = 'vnd.jsonschema:///';
var anonymousBase = '/';

/**
 * Creates a new Validator object
 * @name Validator
 * @constructor
 */
var Validator = function Validator () {
  // Allow a validator instance to override global custom formats or to have their
  // own custom formats.
  this.customFormats = Object.create(Validator.prototype.customFormats);
  this.schemas = {};
  this.unresolvedRefs = [];

  // Use Object.create to make this extensible without Validator instances stepping on each other's toes.
  this.types = Object.create(types);
  this.attributes = Object.create(attribute.validators);
};

// Allow formats to be registered globally.
Validator.prototype.customFormats = {};

// Hint at the presence of a property
Validator.prototype.schemas = null;
Validator.prototype.types = null;
Validator.prototype.attributes = null;
Validator.prototype.unresolvedRefs = null;

/**
 * Adds a schema with a certain urn to the Validator instance.
 * @param schema
 * @param urn
 * @return {Object}
 */
Validator.prototype.addSchema = function addSchema (schema, base) {
  var self = this;
  if (!schema) {
    return null;
  }
  var scan = scanSchema(base||anonymousBase, schema);
  var ourUri = base || schema.id;
  for(var uri in scan.id){
    this.schemas[uri] = scan.id[uri];
  }
  for(var uri in scan.ref){
    this.unresolvedRefs.push(uri);
  }
  this.unresolvedRefs = this.unresolvedRefs.filter(function(uri){
    return typeof self.schemas[uri]==='undefined';
  });
  return this.schemas[ourUri];
};

Validator.prototype.addSubSchemaArray = function addSubSchemaArray(baseuri, schemas) {
  if(!Array.isArray(schemas)) return;
  for(var i=0; i<schemas.length; i++){
    this.addSubSchema(baseuri, schemas[i]);
  }
};

Validator.prototype.addSubSchemaObject = function addSubSchemaArray(baseuri, schemas) {
  if(!schemas || typeof schemas!='object') return;
  for(var p in schemas){
    this.addSubSchema(baseuri, schemas[p]);
  }
};



/**
 * Sets all the schemas of the Validator instance.
 * @param schemas
 */
Validator.prototype.setSchemas = function setSchemas (schemas) {
  this.schemas = schemas;
};

/**
 * Returns the schema of a certain urn
 * @param urn
 */
Validator.prototype.getSchema = function getSchema (urn) {
  return this.schemas[urn];
};

/**
 * Validates instance against the provided schema
 * @param instance
 * @param schema
 * @param [options]
 * @param [ctx]
 * @return {Array}
 */
Validator.prototype.validate = function validate (instance, schema, options, ctx) {
  if((typeof schema !== 'boolean' && typeof schema !== 'object') || schema === null){
    throw new SchemaError('Expected `schema` to be an object or boolean');
  }
  if (!options) {
    options = {};
  }
  var propertyName = options.propertyName || 'instance';
  // This will work so long as the function at uri.resolve() will resolve a relative URI to a relative URI
  var base = urilib.resolve(options.base||anonymousBase, schema.id||'');
  if(!ctx){
    ctx = new SchemaContext(schema, options, propertyName, base, Object.create(this.schemas));
    if (!ctx.schemas[base]) {
      ctx.schemas[base] = schema;
    }
    var found = scanSchema(base, schema);
    for(var n in found.id){
      var sch = found.id[n];
      ctx.schemas[n] = sch;
    }
  }
  var result = this.validateSchema(instance, schema, options, ctx);
  if (!result) {
    throw new Error('Result undefined');
  }
  return result;
};

/**
* @param Object schema
* @return mixed schema uri or false
*/
function shouldResolve(schema) {
  var ref = (typeof schema === 'string') ? schema : schema.$ref;
  if (typeof ref=='string') return ref;
  return false;
}

/**
 * Validates an instance against the schema (the actual work horse)
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @private
 * @return {ValidatorResult}
 */
Validator.prototype.validateSchema = function validateSchema (instance, schema, options, ctx) {
  var result = new ValidatorResult(instance, schema, options, ctx);

  // Support for the true/false schemas
  if(typeof schema==='boolean') {
    if(schema===true){
      // `true` is always valid
      schema = {};
    }else if(schema===false){
      // `false` is always invalid
      schema = {type: []};
    }
  }else if(!schema){
    // This might be a string
    throw new Error("schema is undefined");
  }

  if (schema['extends']) {
    if (Array.isArray(schema['extends'])) {
      var schemaobj = {schema: schema, ctx: ctx};
      schema['extends'].forEach(this.schemaTraverser.bind(this, schemaobj));
      schema = schemaobj.schema;
      schemaobj.schema = null;
      schemaobj.ctx = null;
      schemaobj = null;
    } else {
      schema = helpers.deepMerge(schema, this.superResolve(schema['extends'], ctx));
    }
  }

  // If passed a string argument, load that schema URI
  var switchSchema = shouldResolve(schema);
  if (switchSchema) {
    var resolved = this.resolve(schema, switchSchema, ctx);
    var subctx = new SchemaContext(resolved.subschema, options, ctx.propertyPath, resolved.switchSchema, ctx.schemas);
    return this.validateSchema(instance, resolved.subschema, options, subctx);
  }

  var skipAttributes = options && options.skipAttributes || [];
  // Validate each schema attribute against the instance
  for (var key in schema) {
    if (!attribute.ignoreProperties[key] && skipAttributes.indexOf(key) < 0) {
      var validatorErr = null;
      var validator = this.attributes[key];
      if (validator) {
        validatorErr = validator.call(this, instance, schema, options, ctx);
      } else if (options.allowUnknownAttributes === false) {
        // This represents an error with the schema itself, not an invalid instance
        throw new SchemaError("Unsupported attribute: " + key, schema);
      }
      if (validatorErr) {
        result.importErrors(validatorErr);
      }
    }
  }

  if (typeof options.rewrite == 'function') {
    var value = options.rewrite.call(this, instance, schema, options, ctx);
    result.instance = value;
  }
  return result;
};

/**
* @private
* @param Object schema
* @param SchemaContext ctx
* @returns Object schema or resolved schema
*/
Validator.prototype.schemaTraverser = function schemaTraverser (schemaobj, s) {
  schemaobj.schema = helpers.deepMerge(schemaobj.schema, this.superResolve(s, schemaobj.ctx));
};

/**
* @private
* @param Object schema
* @param SchemaContext ctx
* @returns Object schema or resolved schema
*/
Validator.prototype.superResolve = function superResolve (schema, ctx) {
  var ref = shouldResolve(schema);
  if(ref) {
    return this.resolve(schema, ref, ctx).subschema;
  }
  return schema;
};

/**
* @private
* @param Object schema
* @param Object switchSchema
* @param SchemaContext ctx
* @return Object resolved schemas {subschema:String, switchSchema: String}
* @throws SchemaError
*/
Validator.prototype.resolve = function resolve (schema, switchSchema, ctx) {
  switchSchema = ctx.resolve(switchSchema);
  // First see if the schema exists under the provided URI
  if (ctx.schemas[switchSchema]) {
    return {subschema: ctx.schemas[switchSchema], switchSchema: switchSchema};
  }
  // Else try walking the property pointer
  var parsed = urilib.parse(switchSchema);
  var fragment = parsed && parsed.hash;
  var document = fragment && fragment.length && switchSchema.substr(0, switchSchema.length - fragment.length);
  if (!document || !ctx.schemas[document]) {
    throw new SchemaError("no such schema <" + switchSchema + ">", schema);
  }
  var subschema = helpers.objectGetPath(ctx.schemas[document], fragment.substr(1));
  if(subschema===undefined){
    throw new SchemaError("no such schema " + fragment + " located in <" + document + ">", schema);
  }
  return {subschema: subschema, switchSchema: switchSchema};
};

/**
 * Tests whether the instance if of a certain type.
 * @private
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @param type
 * @return {boolean}
 */
Validator.prototype.testType = function validateType (instance, schema, options, ctx, type) {
  if(type===undefined){
    return;
  }else if(type===null){
    throw new SchemaError('Unexpected null in "type" keyword');
  }
  if (typeof this.types[type] == 'function') {
    return this.types[type].call(this, instance);
  }
  if (type && typeof type == 'object') {
    var res = this.validateSchema(instance, type, options, ctx);
    return res === undefined || !(res && res.errors.length);
  }
  // Undefined or properties not on the list are acceptable, same as not being defined
  return true;
};

var types = Validator.prototype.types = {};
types.string = function testString (instance) {
  return typeof instance == 'string';
};
types.number = function testNumber (instance) {
  // isFinite returns false for NaN, Infinity, and -Infinity
  return typeof instance == 'number' && isFinite(instance);
};
types.integer = function testInteger (instance) {
  return (typeof instance == 'number') && instance % 1 === 0;
};
types.boolean = function testBoolean (instance) {
  return typeof instance == 'boolean';
};
types.array = function testArray (instance) {
  return Array.isArray(instance);
};
types['null'] = function testNull (instance) {
  return instance === null;
};
types.date = function testDate (instance) {
  return instance instanceof Date;
};
types.any = function testAny (instance) {
  return true;
};
types.object = function testObject (instance) {
  // TODO: fix this - see #15
  return instance && (typeof instance === 'object') && !(Array.isArray(instance)) && !(instance instanceof Date);
};

module.exports = Validator;


/***/ }),

/***/ "../node_modules/node-libs-browser/node_modules/punycode/punycode.js":
/*!***************************************************************************!*\
  !*** ../node_modules/node-libs-browser/node_modules/punycode/punycode.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports =  true && exports &&
		!exports.nodeType && exports;
	var freeModule =  true && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}

}(this));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "../node_modules/webpack/buildin/module.js")(module), __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/qs/lib/formats.js":
/*!*****************************************!*\
  !*** ../node_modules/qs/lib/formats.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var replace = String.prototype.replace;
var percentTwenties = /%20/g;

module.exports = {
    'default': 'RFC3986',
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return String(value);
        }
    },
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};


/***/ }),

/***/ "../node_modules/qs/lib/index.js":
/*!***************************************!*\
  !*** ../node_modules/qs/lib/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var stringify = __webpack_require__(/*! ./stringify */ "../node_modules/qs/lib/stringify.js");
var parse = __webpack_require__(/*! ./parse */ "../node_modules/qs/lib/parse.js");
var formats = __webpack_require__(/*! ./formats */ "../node_modules/qs/lib/formats.js");

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};


/***/ }),

/***/ "../node_modules/qs/lib/parse.js":
/*!***************************************!*\
  !*** ../node_modules/qs/lib/parse.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "../node_modules/qs/lib/utils.js");

var has = Object.prototype.hasOwnProperty;

var defaults = {
    allowDots: false,
    allowPrototypes: false,
    arrayLimit: 20,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    parameterLimit: 1000,
    plainObjects: false,
    strictNullHandling: false
};

var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);

    for (var i = 0; i < parts.length; ++i) {
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder);
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder);
            val = options.decoder(part.slice(pos + 1), defaults.decoder);
        }
        if (has.call(obj, key)) {
            obj[key] = [].concat(obj[key]).concat(val);
        } else {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options) {
    var leaf = val;

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]' && options.parseArrays) {
            obj = [].concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var index = parseInt(cleanRoot, 10);
            if (!options.parseArrays && cleanRoot === '') {
                obj = { 0: leaf };
            } else if (
                !isNaN(index)
                && root !== cleanRoot
                && String(index) === cleanRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else if (cleanRoot !== '__proto__') {
                obj[cleanRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys
        // that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while ((segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options);
};

module.exports = function (str, opts) {
    var options = opts ? utils.assign({}, opts) : {};

    if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    options.ignoreQueryPrefix = options.ignoreQueryPrefix === true;
    options.delimiter = typeof options.delimiter === 'string' || utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;
    options.depth = typeof options.depth === 'number' ? options.depth : defaults.depth;
    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults.arrayLimit;
    options.parseArrays = options.parseArrays !== false;
    options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults.decoder;
    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults.allowDots;
    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults.plainObjects;
    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults.allowPrototypes;
    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults.parameterLimit;
    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options);
        obj = utils.merge(obj, newObj, options);
    }

    return utils.compact(obj);
};


/***/ }),

/***/ "../node_modules/qs/lib/stringify.js":
/*!*******************************************!*\
  !*** ../node_modules/qs/lib/stringify.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "../node_modules/qs/lib/utils.js");
var formats = __webpack_require__(/*! ./formats */ "../node_modules/qs/lib/formats.js");

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
        return prefix + '[]';
    },
    indices: function indices(prefix, key) {
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) {
        return prefix;
    }
};

var isArray = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function (arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};

var toISO = Date.prototype.toISOString;

var defaults = {
    delimiter: '&',
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    serializeDate: function serializeDate(date) {
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var stringify = function stringify(
    object,
    prefix,
    generateArrayPrefix,
    strictNullHandling,
    skipNulls,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    formatter,
    encodeValuesOnly
) {
    var obj = object;
    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    }

    if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder) : prefix;
        }

        obj = '';
    }

    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder);
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls && obj[key] === null) {
            continue;
        }

        if (isArray(obj)) {
            pushToArray(values, stringify(
                obj[key],
                generateArrayPrefix(prefix, key),
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly
            ));
        } else {
            pushToArray(values, stringify(
                obj[key],
                prefix + (allowDots ? '.' + key : '[' + key + ']'),
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly
            ));
        }
    }

    return values;
};

module.exports = function (object, opts) {
    var obj = object;
    var options = opts ? utils.assign({}, opts) : {};

    if (options.encoder !== null && typeof options.encoder !== 'undefined' && typeof options.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var delimiter = typeof options.delimiter === 'undefined' ? defaults.delimiter : options.delimiter;
    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;
    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : defaults.skipNulls;
    var encode = typeof options.encode === 'boolean' ? options.encode : defaults.encode;
    var encoder = typeof options.encoder === 'function' ? options.encoder : defaults.encoder;
    var sort = typeof options.sort === 'function' ? options.sort : null;
    var allowDots = typeof options.allowDots === 'undefined' ? false : options.allowDots;
    var serializeDate = typeof options.serializeDate === 'function' ? options.serializeDate : defaults.serializeDate;
    var encodeValuesOnly = typeof options.encodeValuesOnly === 'boolean' ? options.encodeValuesOnly : defaults.encodeValuesOnly;
    if (typeof options.format === 'undefined') {
        options.format = formats['default'];
    } else if (!Object.prototype.hasOwnProperty.call(formats.formatters, options.format)) {
        throw new TypeError('Unknown format option provided.');
    }
    var formatter = formats.formatters[options.format];
    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var arrayFormat;
    if (options.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = options.arrayFormat;
    } else if ('indices' in options) {
        arrayFormat = options.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = 'indices';
    }

    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (sort) {
        objKeys.sort(sort);
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls && obj[key] === null) {
            continue;
        }
        pushToArray(keys, stringify(
            obj[key],
            key,
            generateArrayPrefix,
            strictNullHandling,
            skipNulls,
            encode ? encoder : null,
            filter,
            sort,
            allowDots,
            serializeDate,
            formatter,
            encodeValuesOnly
        ));
    }

    var joined = keys.join(delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    return joined.length > 0 ? prefix + joined : '';
};


/***/ }),

/***/ "../node_modules/qs/lib/utils.js":
/*!***************************************!*\
  !*** ../node_modules/qs/lib/utils.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = Object.prototype.hasOwnProperty;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    var obj;

    while (queue.length) {
        var item = queue.pop();
        obj = item.obj[item.prop];

        if (Array.isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }

    return obj;
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (Array.isArray(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (!target || typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (Array.isArray(target) && !Array.isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (Array.isArray(target) && Array.isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str) {
    try {
        return decodeURIComponent(str.replace(/\+/g, ' '));
    } catch (e) {
        return str;
    }
};

var encode = function encode(str) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = typeof str === 'string' ? str : String(str);

    var out = '';
    for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);

        if (
            c === 0x2D // -
            || c === 0x2E // .
            || c === 0x5F // _
            || c === 0x7E // ~
            || (c >= 0x30 && c <= 0x39) // 0-9
            || (c >= 0x41 && c <= 0x5A) // a-z
            || (c >= 0x61 && c <= 0x7A) // A-Z
        ) {
            out += string.charAt(i);
            continue;
        }

        if (c < 0x80) {
            out = out + hexTable[c];
            continue;
        }

        if (c < 0x800) {
            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        if (c < 0xD800 || c >= 0xE000) {
            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        i += 1;
        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
        /* eslint operator-linebreak: [2, "before"] */
        out += hexTable[0xF0 | (c >> 18)]
            + hexTable[0x80 | ((c >> 12) & 0x3F)]
            + hexTable[0x80 | ((c >> 6) & 0x3F)]
            + hexTable[0x80 | (c & 0x3F)];
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    return compactQueue(queue);
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (obj === null || typeof obj === 'undefined') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    merge: merge
};


/***/ }),

/***/ "../node_modules/url/url.js":
/*!**********************************!*\
  !*** ../node_modules/url/url.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Copyright Joyent, Inc. and other Node contributors.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to permit
 * persons to whom the Software is furnished to do so, subject to the
 * following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
 * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 */



var punycode = __webpack_require__(/*! punycode/ */ "../node_modules/node-libs-browser/node_modules/punycode/punycode.js");

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

/*
 * define these here so at least they only have to be
 * compiled once on the first module load.
 */
var protocolPattern = /^([a-z0-9.+-]+:)/i,
  portPattern = /:[0-9]*$/,

  // Special case for a simple path URL
  simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/,

  /*
   * RFC 2396: characters reserved for delimiting URLs.
   * We actually just auto-escape these.
   */
  delims = [
    '<', '>', '"', '`', ' ', '\r', '\n', '\t'
  ],

  // RFC 2396: characters not allowed for various reasons.
  unwise = [
    '{', '}', '|', '\\', '^', '`'
  ].concat(delims),

  // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
  autoEscape = ['\''].concat(unwise),
  /*
   * Characters that are never ever allowed in a hostname.
   * Note that any invalid chars are also handled, but these
   * are the ones that are *expected* to be seen, so we fast-path
   * them.
   */
  nonHostChars = [
    '%', '/', '?', ';', '#'
  ].concat(autoEscape),
  hostEndingChars = [
    '/', '?', '#'
  ],
  hostnameMaxLen = 255,
  hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
  hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
  // protocols that can allow "unsafe" and "unwise" chars.
  unsafeProtocol = {
    javascript: true,
    'javascript:': true
  },
  // protocols that never have a hostname.
  hostlessProtocol = {
    javascript: true,
    'javascript:': true
  },
  // protocols that always contain a // bit.
  slashedProtocol = {
    http: true,
    https: true,
    ftp: true,
    gopher: true,
    file: true,
    'http:': true,
    'https:': true,
    'ftp:': true,
    'gopher:': true,
    'file:': true
  },
  querystring = __webpack_require__(/*! qs */ "../node_modules/qs/lib/index.js");

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && typeof url === 'object' && url instanceof Url) { return url; }

  var u = new Url();
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
  if (typeof url !== 'string') {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  /*
   * Copy chrome, IE, opera backslash-handling behavior.
   * Back slashes before the query string get converted to forward slashes
   * See: https://code.google.com/p/chromium/issues/detail?id=25916
   */
  var queryIndex = url.indexOf('?'),
    splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
    uSplit = url.split(splitter),
    slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  /*
   * trim before proceeding.
   * This is to support parse stuff like "  http://foo.com  \n"
   */
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  /*
   * figure out if it's got a host
   * user@server is *always* interpreted as a hostname, and url
   * resolution will treat //foo/bar as host=foo,path=bar because that's
   * how the browser resolves relative URLs.
   */
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@/]+@[^@/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] && (slashes || (proto && !slashedProtocol[proto]))) {

    /*
     * there's a hostname.
     * the first instance of /, ?, ;, or # ends the host.
     *
     * If there is an @ in the hostname, then non-host chars *are* allowed
     * to the left of the last @ sign, unless some host-ending character
     * comes *before* the @-sign.
     * URLs are obnoxious.
     *
     * ex:
     * http://a@b@c/ => user:a@b host:c
     * http://a@b?@c => user:a host:c path:/?@c
     */

    /*
     * v0.12 TODO(isaacs): This is not quite how Chrome does things.
     * Review our test case against browsers more comprehensively.
     */

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) { hostEnd = hec; }
    }

    /*
     * at this point, either we have an explicit point where the
     * auth portion cannot go past, or the last @ char is the decider.
     */
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      /*
       * atSign must be in auth portion.
       * http://a@b/c@d => host:b auth:a path:/c@d
       */
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    /*
     * Now we have a portion which is definitely the auth.
     * Pull that off.
     */
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) { hostEnd = hec; }
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1) { hostEnd = rest.length; }

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    /*
     * we've indicated that there is a hostname,
     * so even if it's empty, it has to be present.
     */
    this.hostname = this.hostname || '';

    /*
     * if hostname begins with [ and ends with ]
     * assume that it's an IPv6 address.
     */
    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) { continue; }
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              /*
               * we replace non-ASCII char with a temporary placeholder
               * we need this to make sure size of hostname is not
               * broken by replacing non-ASCII by nothing
               */
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      /*
       * IDNA Support: Returns a punycoded representation of "domain".
       * It only converts parts of the domain name that
       * have non-ASCII characters, i.e. it doesn't matter if
       * you call it with a domain that already is ASCII-only.
       */
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    /*
     * strip [ and ] from the hostname
     * the host field still retains them, though
     */
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  /*
   * now rest is set to the post-host stuff.
   * chop off any delim chars.
   */
  if (!unsafeProtocol[lowerProto]) {

    /*
     * First, make 100% sure that any "autoEscape" chars get
     * escaped, even if encodeURIComponent doesn't think they
     * need to be.
     */
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1) { continue; }
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }

  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) { this.pathname = rest; }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  // to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  /*
   * ensure it's an object, and not a string url.
   * If it's an obj, this is a no-op.
   * this way, you can call url_format() on strings
   * to clean up potentially wonky urls.
   */
  if (typeof obj === 'string') { obj = urlParse(obj); }
  if (!(obj instanceof Url)) { return Url.prototype.format.call(obj); }
  return obj.format();
}

Url.prototype.format = function () {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
    pathname = this.pathname || '',
    hash = this.hash || '',
    host = false,
    query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query && typeof this.query === 'object' && Object.keys(this.query).length) {
    query = querystring.stringify(this.query, {
      arrayFormat: 'repeat',
      addQueryPrefix: false
    });
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') { protocol += ':'; }

  /*
   * only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
   * unless they had them to begin with.
   */
  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') { pathname = '/' + pathname; }
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') { hash = '#' + hash; }
  if (search && search.charAt(0) !== '?') { search = '?' + search; }

  pathname = pathname.replace(/[?#]/g, function (match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function (relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) { return relative; }
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function (relative) {
  if (typeof relative === 'string') {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  /*
   * hash is always overridden, no matter what.
   * even href="" will remove it.
   */
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol') { result[rkey] = relative[rkey]; }
    }

    // urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
      result.pathname = '/';
      result.path = result.pathname;
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    /*
     * if it's a known url protocol, then changing
     * the protocol does weird things
     * first, if it's not file:, then we MUST have a host,
     * and if there was a path
     * to begin with, then we MUST have a path.
     * if it is file:, then the host is dropped,
     * because that's known to be hostless.
     * anything else is assumed to be absolute.
     */
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift())) { }
      if (!relative.host) { relative.host = ''; }
      if (!relative.hostname) { relative.hostname = ''; }
      if (relPath[0] !== '') { relPath.unshift(''); }
      if (relPath.length < 2) { relPath.unshift(''); }
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
    isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',
    mustEndAbs = isRelAbs || isSourceAbs || (result.host && relative.pathname),
    removeAllDots = mustEndAbs,
    srcPath = result.pathname && result.pathname.split('/') || [],
    relPath = relative.pathname && relative.pathname.split('/') || [],
    psychotic = result.protocol && !slashedProtocol[result.protocol];

  /*
   * if the url is a non-slashed url, then relative
   * links like ../.. should be able
   * to crawl up to the hostname, as well.  This is strange.
   * result.protocol has already been set by now.
   * Later on, put the first path part into the host field.
   */
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') { srcPath[0] = result.host; } else { srcPath.unshift(result.host); }
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') { relPath[0] = relative.host; } else { relPath.unshift(relative.host); }
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = relative.host || relative.host === '' ? relative.host : result.host;
    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    /*
     * it's relative
     * throw away the existing file, and take the new path instead.
     */
    if (!srcPath) { srcPath = []; }
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (relative.search != null) {
    /*
     * just pull out the search.
     * like href='?foo'.
     * Put this after the other two cases because it simplifies the booleans
     */
    if (psychotic) {
      result.host = srcPath.shift();
      result.hostname = result.host;
      /*
       * occationaly the auth can get stuck only in host
       * this especially happens in cases like
       * url.resolveObject('mailto:local1@domain1', 'local2@domain2')
       */
      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.hostname = authInHost.shift();
        result.host = result.hostname;
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    // to support http.request
    if (result.pathname !== null || result.search !== null) {
      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    /*
     * no path at all.  easy.
     * we've already handled the other stuff above.
     */
    result.pathname = null;
    // to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  /*
   * if a url ENDs in . or .., then it must get a trailing slash.
   * however, if it ends in anything else non-slashy,
   * then it must NOT get a trailing slash.
   */
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '';

  /*
   * strip single dots, resolve double dots to parent dir
   * if the path tries to go above the root, `up` ends up > 0
   */
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' || (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';
    result.host = result.hostname;
    /*
     * occationaly the auth can get stuck only in host
     * this especially happens in cases like
     * url.resolveObject('mailto:local1@domain1', 'local2@domain2')
     */
    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.hostname = authInHost.shift();
      result.host = result.hostname;
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (srcPath.length > 0) {
    result.pathname = srcPath.join('/');
  } else {
    result.pathname = null;
    result.path = null;
  }

  // to support request.http
  if (result.pathname !== null || result.search !== null) {
    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function () {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) { this.hostname = host; }
};

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;


/***/ }),

/***/ "../node_modules/webpack/buildin/global.js":
/*!*************************************************!*\
  !*** ../node_modules/webpack/buildin/global.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "../node_modules/webpack/buildin/module.js":
/*!*************************************************!*\
  !*** ../node_modules/webpack/buildin/module.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./accumulatepass.ts":
/*!***************************!*\
  !*** ./accumulatepass.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var changelookup_1 = __webpack_require__(/*! ./changelookup */ "./changelookup.ts");
var framebuffer_1 = __webpack_require__(/*! ./framebuffer */ "./framebuffer.ts");
var initializable_1 = __webpack_require__(/*! ./initializable */ "./initializable.ts");
var ndcfillingtriangle_1 = __webpack_require__(/*! ./ndcfillingtriangle */ "./ndcfillingtriangle.ts");
var program_1 = __webpack_require__(/*! ./program */ "./program.ts");
var shader_1 = __webpack_require__(/*! ./shader */ "./shader.ts");
var texture2d_1 = __webpack_require__(/*! ./texture2d */ "./texture2d.ts");
var wizard_1 = __webpack_require__(/*! ./wizard */ "./wizard.ts");
var AccumulatePass = (function (_super) {
    __extends(AccumulatePass, _super);
    function AccumulatePass(context) {
        var _this = _super.call(this) || this;
        _this._altered = Object.assign(new changelookup_1.ChangeLookup(), {
            any: false, texture: false, precision: false, passThrough: false,
        });
        _this._precision = wizard_1.Wizard.Precision.half;
        _this._write = 0;
        _this._ndcTriangleShared = false;
        _this._context = context;
        return _this;
    }
    AccumulatePass.prototype.initialize = function (ndcTriangle) {
        var gl = this._context.gl;
        this._accumulationFBOs = [
            new framebuffer_1.Framebuffer(this._context, 'AccumPingFBO'),
            new framebuffer_1.Framebuffer(this._context, 'AccumPongFBO')
        ];
        this._accumulationTextures = [
            new texture2d_1.Texture2D(this._context, 'AccumPingTexture'),
            new texture2d_1.Texture2D(this._context, 'AccumPongTexture')
        ];
        if (ndcTriangle === undefined) {
            this._ndcTriangle = new ndcfillingtriangle_1.NdcFillingTriangle(this._context, 'NdcFillingTriangle-Accumulate');
        }
        else {
            this._ndcTriangle = ndcTriangle;
            this._ndcTriangleShared = true;
        }
        var vert = new shader_1.Shader(this._context, gl.VERTEX_SHADER, 'ndcvertices.vert (accumulate)');
        vert.initialize(__webpack_require__(/*! ./shaders/ndcvertices.vert */ "./shaders/ndcvertices.vert"));
        var frag = new shader_1.Shader(this._context, gl.FRAGMENT_SHADER, 'accumulate.frag');
        frag.initialize(__webpack_require__(/*! ./shaders/accumulate.frag */ "./shaders/accumulate.frag"));
        this._program = new program_1.Program(this._context, 'AccumulateProgram');
        this._program.initialize([vert, frag], false);
        if (!this._ndcTriangle.initialized) {
            this._ndcTriangle.initialize();
        }
        this._program.attribute('a_vertex', this._ndcTriangle.vertexLocation);
        this._program.link();
        this._uWeight = this._program.uniform('u_weight');
        this._program.bind();
        gl.uniform1f(this._uWeight, 0.0);
        gl.uniform1i(this._program.uniform('u_accumulationTexture'), 0);
        gl.uniform1i(this._program.uniform('u_currentFrameTexture'), 1);
        this._program.unbind();
        return true;
    };
    AccumulatePass.prototype.uninitialize = function () {
        if (!this._ndcTriangleShared && this._ndcTriangle.initialized) {
            this._ndcTriangle.uninitialize();
        }
        this._program.uninitialize();
        this._accumulationFBOs[0].uninitialize();
        this._accumulationFBOs[1].uninitialize();
        this._accumulationTextures[0].uninitialize();
        this._accumulationTextures[1].uninitialize();
        this._write = 0;
    };
    AccumulatePass.prototype.update = function () {
        if (!this._texture || !this._texture.valid) {
            auxiliaries_1.log(auxiliaries_1.LogLevel.Warning, "valid texture for accumulation update expected, given " + this._texture);
            return;
        }
        if (this._passThrough) {
            return;
        }
        var sizeAltered = this._altered.texture || this._accumulationTextures[0].width !== this._texture.width ||
            this._accumulationTextures[0].height !== this._texture.height;
        if (!this._altered.any && !sizeAltered) {
            auxiliaries_1.assert(this._accumulationFBOs[0].valid && this._accumulationFBOs[1].valid, "valid accumulation framebuffers expected");
            return;
        }
        var gl = this._context.gl;
        var gl2facade = this._context.gl2facade;
        var textureSize = this._texture.size;
        if (!this._accumulationTextures[0].initialized) {
            var internalFormat = wizard_1.Wizard.queryInternalTextureFormat(this._context, gl.RGBA, this._precision);
            this._accumulationTextures[0].initialize(textureSize[0], textureSize[1], internalFormat[0], gl.RGBA, internalFormat[1]);
            this._accumulationTextures[1].initialize(textureSize[0], textureSize[1], internalFormat[0], gl.RGBA, internalFormat[1]);
        }
        else {
            if (this._altered.texture || sizeAltered) {
                this._accumulationTextures[0].resize(this._texture.width, this._texture.height);
                this._accumulationTextures[1].resize(this._texture.width, this._texture.height);
            }
            if (this._altered.precision) {
                var internalFormat = wizard_1.Wizard.queryInternalTextureFormat(this._context, gl.RGBA, this._precision);
                this._accumulationTextures[0].reformat(internalFormat[0], gl.RGBA, internalFormat[1]);
                this._accumulationTextures[1].reformat(internalFormat[0], gl.RGBA, internalFormat[1]);
            }
        }
        if (!this._accumulationFBOs[0].initialized) {
            this._accumulationFBOs[0].initialize([[gl2facade.COLOR_ATTACHMENT0, this._accumulationTextures[0]]]);
            this._accumulationFBOs[1].initialize([[gl2facade.COLOR_ATTACHMENT0, this._accumulationTextures[1]]]);
        }
        auxiliaries_1.assert(this._accumulationFBOs[0].valid && this._accumulationFBOs[1].valid, "valid accumulation framebuffers expected");
        this._altered.reset();
    };
    AccumulatePass.prototype.frame = function (frameNumber, viewport) {
        auxiliaries_1.assert(this._accumulationFBOs[0].valid && this._accumulationFBOs[1].valid, "valid framebuffer objects for accumulation expected (initialize or update was probably not be called");
        if (this._passThrough || this._texture === undefined) {
            return;
        }
        auxiliaries_1.logIf(!this._texture || !this._texture.valid, auxiliaries_1.LogLevel.Warning, "valid texture for accumulation frame expected, given " + this._texture);
        var gl = this._context.gl;
        if (viewport !== undefined) {
            gl.viewport(0, 0, viewport[0], viewport[1]);
        }
        var readIndex = frameNumber % 2;
        var writeIndex = this._write = 1 - readIndex;
        var accumTexture = this._accumulationTextures[readIndex];
        var frameTexture = this._texture;
        accumTexture.bind(gl.TEXTURE0);
        frameTexture.bind(gl.TEXTURE1);
        this._program.bind();
        gl.uniform1f(this._uWeight, 1.0 / (frameNumber + 1));
        this._accumulationFBOs[writeIndex].bind(gl.DRAW_FRAMEBUFFER);
        this._ndcTriangle.bind();
        this._ndcTriangle.draw();
        this._ndcTriangle.unbind();
        this._accumulationFBOs[writeIndex].unbind(gl.DRAW_FRAMEBUFFER);
        accumTexture.unbind(gl.TEXTURE0);
        frameTexture.unbind(gl.TEXTURE1);
    };
    Object.defineProperty(AccumulatePass.prototype, "texture", {
        set: function (texture) {
            this.assertInitialized();
            if (this._texture !== texture) {
                this._texture = texture;
                this._altered.alter('texture');
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AccumulatePass.prototype, "precision", {
        set: function (precision) {
            this.assertInitialized();
            if (this._precision !== precision) {
                this._precision = precision;
                this._altered.alter('precision');
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AccumulatePass.prototype, "passThrough", {
        set: function (passThrough) {
            this.assertInitialized();
            if (this._passThrough === passThrough) {
                return;
            }
            if (this._passThrough && this._accumulationTextures[0].initialized) {
                this._accumulationTextures[0].uninitialize();
                this._accumulationTextures[1].uninitialize();
            }
            if (this._passThrough && this._accumulationFBOs[0].initialized) {
                this._accumulationFBOs[0].uninitialize();
                this._accumulationFBOs[1].uninitialize();
            }
            this._passThrough = passThrough;
            this._altered.alter('passThrough');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AccumulatePass.prototype, "framebuffer", {
        get: function () {
            return this._passThrough ? undefined : this._accumulationFBOs[this._write];
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        initializable_1.Initializable.initialize()
    ], AccumulatePass.prototype, "initialize", null);
    __decorate([
        initializable_1.Initializable.uninitialize()
    ], AccumulatePass.prototype, "uninitialize", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], AccumulatePass.prototype, "update", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], AccumulatePass.prototype, "frame", null);
    return AccumulatePass;
}(initializable_1.Initializable));
exports.AccumulatePass = AccumulatePass;


/***/ }),

/***/ "./allocationregister.ts":
/*!*******************************!*\
  !*** ./allocationregister.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var rxjs_1 = __webpack_require__(/*! rxjs */ "rxjs");
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var AllocationRegister = (function () {
    function AllocationRegister() {
        this._bytesByIdentifier = new Map();
        this._bytes = 0;
        this._bytesSubject = new rxjs_1.ReplaySubject(1);
    }
    AllocationRegister.prototype.bytesNext = function () {
        this._bytesSubject.next([this._bytes, this.bytesToString()]);
    };
    AllocationRegister.prototype.assertIdentifier = function (identifier) {
        auxiliaries_1.assert(this._bytesByIdentifier.has(identifier), "allocation identifier unknown");
    };
    AllocationRegister.prototype.createUniqueIdentifier = function (identifier) {
        var uniqueIdentifier = identifier;
        var unificationSuffix = 2;
        while (this._bytesByIdentifier.has(uniqueIdentifier)) {
            uniqueIdentifier = identifier + "-" + unificationSuffix;
            ++unificationSuffix;
        }
        this._bytesByIdentifier.set(uniqueIdentifier, 0);
        return uniqueIdentifier;
    };
    AllocationRegister.prototype.deleteUniqueIdentifier = function (identifier) {
        auxiliaries_1.assert(this._bytesByIdentifier.has(identifier), "identifier expected to be known for allocation registration");
        this._bytesByIdentifier.delete(identifier);
    };
    AllocationRegister.prototype.allocate = function (identifier, allocate) {
        this.assertIdentifier(identifier);
        auxiliaries_1.assert(allocate >= 0, "positive number of bytes expected for allocation, given " + allocate);
        if (allocate === 0) {
            return;
        }
        var bytes = (this._bytesByIdentifier.get(identifier)) + allocate;
        this._bytesByIdentifier.set(identifier, bytes);
        this._bytes = this._bytes + allocate;
        this.bytesNext();
    };
    AllocationRegister.prototype.deallocate = function (identifier, deallocate) {
        this.assertIdentifier(identifier);
        var bytes = this._bytesByIdentifier.get(identifier);
        auxiliaries_1.assert(deallocate >= 0, "positive number of bytes expected for deallocation, given " + deallocate);
        auxiliaries_1.assert(deallocate <= bytes, "deallocation cannot exceed previous allocations of " + bytes + ", given " + deallocate);
        if (deallocate === 0) {
            return;
        }
        this._bytesByIdentifier.set(identifier, bytes - deallocate);
        this._bytes = this._bytes - deallocate;
        this.bytesNext();
    };
    AllocationRegister.prototype.reallocate = function (identifier, reallocate) {
        this.assertIdentifier(identifier);
        auxiliaries_1.assert(reallocate >= 0, "positive number of bytes expected for reallocation, given " + reallocate);
        var previousBytes = this._bytesByIdentifier.get(identifier);
        if (previousBytes === reallocate) {
            return;
        }
        this._bytes = this._bytes - previousBytes;
        this._bytesByIdentifier.set(identifier, reallocate);
        this._bytes = this._bytes + reallocate;
        this.bytesNext();
    };
    AllocationRegister.prototype.allocated = function (identifier) {
        if (identifier === undefined) {
            return this._bytes;
        }
        this.assertIdentifier(identifier);
        return this._bytesByIdentifier.get(identifier);
    };
    AllocationRegister.prototype.toString = function () {
        var output = new Array();
        this._bytesByIdentifier.forEach(function (bytes, identifier) {
            output.push(identifier + ": " + auxiliaries_1.prettyPrintBytes(bytes));
        });
        return output.join(', ');
    };
    AllocationRegister.prototype.bytesToString = function (identifier) {
        return auxiliaries_1.prettyPrintBytes(this.allocated(identifier));
    };
    Object.defineProperty(AllocationRegister.prototype, "bytes", {
        get: function () {
            return this._bytes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AllocationRegister.prototype, "bytes$", {
        get: function () {
            return this._bytesSubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    return AllocationRegister;
}());
exports.AllocationRegister = AllocationRegister;


/***/ }),

/***/ "./antialiasingkernel.ts":
/*!*******************************!*\
  !*** ./antialiasingkernel.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var randomsquarekernel_1 = __webpack_require__(/*! ./randomsquarekernel */ "./randomsquarekernel.ts");
var AntiAliasingKernel = (function (_super) {
    __extends(AntiAliasingKernel, _super);
    function AntiAliasingKernel(width) {
        return _super.call(this, width) || this;
    }
    AntiAliasingKernel.prototype.generate = function () {
        switch (this._width) {
            case 8:
                this.fromJSON(__webpack_require__(/*! ./data/goldenset08.json */ "./data/goldenset08.json"));
                break;
            case 64:
                this.fromJSON(__webpack_require__(/*! ./data/goldenset64.json */ "./data/goldenset64.json"));
                break;
            case 128:
                this.fromJSON(__webpack_require__(/*! ./data/goldenset128.json */ "./data/goldenset128.json"));
                break;
            default:
                _super.prototype.generate.call(this);
        }
    };
    return AntiAliasingKernel;
}(randomsquarekernel_1.RandomSquareKernel));
exports.AntiAliasingKernel = AntiAliasingKernel;


/***/ }),

/***/ "./auxiliaries.ts":
/*!************************!*\
  !*** ./auxiliaries.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var gl_matrix_extensions_1 = __webpack_require__(/*! ./gl-matrix-extensions */ "./gl-matrix-extensions.ts");
var auxiliaries;
(function (auxiliaries) {
    var logVerbosityThreshold =  true ? 3 : undefined;
    function logVerbosity(verbosity) {
        if (verbosity !== undefined) {
            logVerbosityThreshold = Math.max(-1, verbosity);
        }
        return logVerbosityThreshold;
    }
    auxiliaries.logVerbosity = logVerbosity;
    var LogLevel;
    (function (LogLevel) {
        LogLevel[LogLevel["Debug"] = 3] = "Debug";
        LogLevel[LogLevel["Info"] = 2] = "Info";
        LogLevel[LogLevel["Warning"] = 1] = "Warning";
        LogLevel[LogLevel["Error"] = 0] = "Error";
    })(LogLevel = auxiliaries.LogLevel || (auxiliaries.LogLevel = {}));
    var assertImpl = function (statement, message) {
        if (statement) {
            return;
        }
        throw new EvalError(message);
    };
    var assertEmpty = function (statement, message) { };
    auxiliaries.assert = assertImpl;
    if (false) {}
    function assertions(enable) {
        if (enable !== undefined) {
            auxiliaries.assert = enable ? assertImpl : assertEmpty;
        }
        return auxiliaries.assert !== assertEmpty;
    }
    auxiliaries.assertions = assertions;
    function log(verbosity) {
        var message = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            message[_i - 1] = arguments[_i];
        }
        if (verbosity > logVerbosityThreshold) {
            return;
        }
        console.log.apply(console, __spreadArrays(["[" + verbosity + "]"], message));
    }
    auxiliaries.log = log;
    function logIf(statement, verbosity) {
        var message = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            message[_i - 2] = arguments[_i];
        }
        if (!statement) {
            return;
        }
        log.apply(void 0, __spreadArrays([verbosity], message));
    }
    auxiliaries.logIf = logIf;
    function logPerformanceStart(mark) {
        var start = mark + "-start";
        auxiliaries.assert(performance.getEntriesByName(mark).length === 0, "expected mark identifier to not already exists, given " + mark);
        auxiliaries.assert(performance.getEntriesByName(start).length === 0, "expected mark identifier to not already exists, given " + start);
        performance.mark(start);
    }
    auxiliaries.logPerformanceStart = logPerformanceStart;
    function logPerformanceStartIf(statement, mark) {
        if (!statement) {
            return;
        }
        logPerformanceStart(mark);
    }
    auxiliaries.logPerformanceStartIf = logPerformanceStartIf;
    function logPerformanceStop(mark, message, measureIndent) {
        if (measureIndent === void 0) { measureIndent = 0; }
        var start = mark + "-start";
        var end = mark + "-end";
        auxiliaries.assert(performance.getEntriesByName(mark).length === 0, "expected mark identifier to not already exists, given " + mark);
        auxiliaries.assert(performance.getEntriesByName(end).length === 0, "expected mark identifier to not already exists, given " + end);
        performance.mark(end);
        performance.measure(mark, start, end);
        var measures = performance.getEntriesByName(mark);
        var measure = measures[0];
        performance.clearMarks(start);
        performance.clearMarks(end);
        performance.clearMeasures(mark);
        var minIndent = message === undefined || message.length === 0 ? 0 : 2;
        var indent = Math.max(minIndent, measureIndent - mark.length - (message ? message.length : 0) - 1);
        var prettyMeasure = prettyPrintMilliseconds(measure.duration);
        log(LogLevel.Debug, "" + mark + ' '.repeat(indent) + (message ? message : '') + " | " + prettyMeasure);
    }
    auxiliaries.logPerformanceStop = logPerformanceStop;
    function logPerformanceStopIf(statement, mark, message, measureIndent) {
        if (measureIndent === void 0) { measureIndent = 0; }
        if (!statement) {
            return;
        }
        logPerformanceStop(mark, message, measureIndent);
    }
    auxiliaries.logPerformanceStopIf = logPerformanceStopIf;
    function rand(min, max) {
        if (min === void 0) { min = 0.0; }
        if (max === void 0) { max = 1.0; }
        return Math.random() * (max - min) + min;
    }
    auxiliaries.rand = rand;
    function isPowerOfTwo(x) {
        return Number.isInteger(x) && Number.isInteger(Math.log2(x));
    }
    auxiliaries.isPowerOfTwo = isPowerOfTwo;
    function upperPowerOfTwo(x) {
        --x;
        x |= x >> 1;
        x |= x >> 2;
        x |= x >> 4;
        x |= x >> 8;
        x |= x >> 16;
        return ++x;
    }
    auxiliaries.upperPowerOfTwo = upperPowerOfTwo;
    var byteSuffixes = ['', 'Ki', 'Mi', 'Gi', 'Ti', 'Pi', 'Ei', 'Zi', 'Yi'];
    function prettyPrintBytes(bytes) {
        var prefix = bytes > 0 ? Math.floor(Math.log(bytes) / Math.log(1024)) : 0;
        var value = bytes / Math.pow(1024, prefix);
        return "" + (prefix > 0 ? value.toFixed(3) : value) + byteSuffixes[prefix] + "B";
    }
    auxiliaries.prettyPrintBytes = prettyPrintBytes;
    var msSuffixes = ['ms', 'ns', 's', 'ms', 's'];
    var msScales = [0, 1e+6, 1e+3, 1e+0, 1e-3];
    function prettyPrintMilliseconds(milliseconds) {
        var prefix = milliseconds > 0 ?
            Math.max(1, Math.floor(Math.log(milliseconds * 10) / Math.log(1e+3)) + 3) : 0;
        prefix = gl_matrix_extensions_1.clamp(prefix, 0, 4);
        var value = milliseconds * msScales[prefix];
        return "" + value.toFixed(3) + msSuffixes[prefix];
    }
    auxiliaries.prettyPrintMilliseconds = prettyPrintMilliseconds;
    function bitInBitfield(flags, flag) {
        if (flag === undefined) {
            return false;
        }
        return (flags & flag) === flag;
    }
    auxiliaries.bitInBitfield = bitInBitfield;
    auxiliaries.RAD2DEG = 57.295779513082320;
    auxiliaries.DEG2RAD = 0.017453292519943295;
    function GETsearch() {
        return window.location.search;
    }
    auxiliaries.GETsearch = GETsearch;
    function GETparameter(parameter) {
        var re = new RegExp(parameter + "=([^&]+)");
        var match = window.location.search.match(re);
        if (!match) {
            return undefined;
        }
        return match[1];
    }
    auxiliaries.GETparameter = GETparameter;
    auxiliaries.PATH_SEPARATOR = '/';
    function dirname(path) {
        if (path.includes(auxiliaries.PATH_SEPARATOR) === false) {
            return '';
        }
        return path.substr(0, path.lastIndexOf(auxiliaries.PATH_SEPARATOR)).trimLeft();
    }
    auxiliaries.dirname = dirname;
    function basename(path) {
        if (path.includes(auxiliaries.PATH_SEPARATOR) === false) {
            return path;
        }
        return path.substr(path.lastIndexOf(auxiliaries.PATH_SEPARATOR) + 1).trimRight();
    }
    auxiliaries.basename = basename;
})(auxiliaries || (auxiliaries = {}));
module.exports = auxiliaries;


/***/ }),

/***/ "./blitpass.ts":
/*!*********************!*\
  !*** ./blitpass.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "../node_modules/gl-matrix/esm/index.js");
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var gl_matrix_extensions_1 = __webpack_require__(/*! ./gl-matrix-extensions */ "./gl-matrix-extensions.ts");
var initializable_1 = __webpack_require__(/*! ./initializable */ "./initializable.ts");
var ndcfillingtriangle_1 = __webpack_require__(/*! ./ndcfillingtriangle */ "./ndcfillingtriangle.ts");
var program_1 = __webpack_require__(/*! ./program */ "./program.ts");
var shader_1 = __webpack_require__(/*! ./shader */ "./shader.ts");
var BlitPass = (function (_super) {
    __extends(BlitPass, _super);
    function BlitPass(context) {
        var _this = _super.call(this) || this;
        _this._enforceProgramBlit = false;
        _this._ndcTriangleShared = false;
        _this._context = context;
        return _this;
    }
    BlitPass.prototype.functionBlit = function () {
        var gl = this._context.gl;
        this._target.bind(gl.DRAW_FRAMEBUFFER);
        this._framebuffer.bind(gl.READ_FRAMEBUFFER);
        gl.readBuffer(this._readBuffer);
        gl.drawBuffers([this._drawBuffer]);
        gl.enable(gl.SCISSOR_TEST);
        gl.scissor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.disable(gl.SCISSOR_TEST);
        var srcBounds = this._srcBounds ? this._srcBounds : [0, 0, this._framebuffer.width, this._framebuffer.height];
        var dstBounds = this._dstBounds ? this._dstBounds : [0, 0, this._target.width, this._target.height];
        gl.blitFramebuffer(srcBounds[0], srcBounds[1], srcBounds[2], srcBounds[3], dstBounds[0], dstBounds[1], dstBounds[2], dstBounds[3], gl.COLOR_BUFFER_BIT, this._filter);
        this._framebuffer.unbind(gl.READ_FRAMEBUFFER);
        this._target.unbind(gl.DRAW_FRAMEBUFFER);
    };
    BlitPass.prototype.programBlit = function () {
        if (this._program === undefined) {
            this.createProgram();
        }
        auxiliaries_1.assert(this._ndcTriangle && this._ndcTriangle.initialized, "expected an initialized ndc triangle");
        var gl = this._context.gl;
        var srcBounds = this._srcBounds ? this._srcBounds :
            gl_matrix_1.vec4.fromValues(0, 0, this._framebuffer.width, this._framebuffer.height);
        var dstBounds = this._dstBounds ? this._dstBounds :
            gl_matrix_1.vec4.fromValues(0, 0, this._target.width, this._target.height);
        var srcBoundsNormalized = gl_matrix_1.vec4.div(gl_matrix_extensions_1.v4(), srcBounds, [this._framebuffer.width, this._framebuffer.height, this._framebuffer.width, this._framebuffer.height]);
        var dstBoundsNormalized = gl_matrix_1.vec4.div(gl_matrix_extensions_1.v4(), dstBounds, [this._target.width, this._target.height, this._target.width, this._target.height]);
        gl.viewport(dstBounds[0], dstBounds[1], dstBounds[2] - dstBounds[0], dstBounds[3] - dstBounds[1]);
        gl.disable(gl.DEPTH_TEST);
        gl.depthMask(false);
        this._program.bind();
        gl.uniform4fv(this._uSrcBounds, srcBoundsNormalized);
        gl.uniform4fv(this._uDstBounds, dstBoundsNormalized);
        gl.uniform1i(this._uNearest, this.filter === gl.nearest);
        var texture = this._framebuffer.texture(this._readBuffer);
        texture.bind(gl.TEXTURE0);
        var target = this._context.isWebGL2 ? gl.DRAW_FRAMEBUFFER : gl.FRAMEBUFFER;
        this._target.bind(target);
        this._ndcTriangle.bind();
        this._ndcTriangle.draw();
        this._ndcTriangle.unbind();
        this._target.unbind(target);
        texture.unbind();
        gl.enable(gl.DEPTH_TEST);
        gl.depthMask(true);
    };
    BlitPass.prototype.createProgram = function () {
        auxiliaries_1.assert(this._program === undefined, "expected blit program to be undefined before its creation");
        var gl = this._context.gl;
        var vert = new shader_1.Shader(this._context, gl.VERTEX_SHADER, 'blit.vert (blit)');
        vert.initialize(__webpack_require__(/*! ./shaders/blit.vert */ "./shaders/blit.vert"));
        var frag = new shader_1.Shader(this._context, gl.FRAGMENT_SHADER, 'blit.frag (blit)');
        frag.initialize(__webpack_require__(/*! ./shaders/blit.frag */ "./shaders/blit.frag"));
        this._program = new program_1.Program(this._context, 'BlitProgram');
        this._program.initialize([vert, frag], false);
        if (!this._ndcTriangle.initialized) {
            this._ndcTriangle.initialize();
        }
        this._program.attribute('a_vertex', this._ndcTriangle.vertexLocation);
        this._program.link();
        this._uSrcBounds = this._program.uniform('u_srcBounds');
        this._uDstBounds = this._program.uniform('u_dstBounds');
        this._uNearest = this._program.uniform('u_nearest');
        this._program.bind();
        gl.uniform1i(this._program.uniform('u_source'), 0);
        this._program.unbind();
        return this._program.valid;
    };
    BlitPass.prototype.initialize = function (ndcTriangle) {
        var gl = this._context.gl;
        if (ndcTriangle === undefined) {
            this._ndcTriangle = new ndcfillingtriangle_1.NdcFillingTriangle(this._context, 'NdcFillingTriangle-Blit');
        }
        else {
            this._ndcTriangle = ndcTriangle;
            this._ndcTriangleShared = true;
        }
        this._filter = gl.NEAREST;
        return true;
    };
    BlitPass.prototype.uninitialize = function () {
        if (!this._ndcTriangleShared && this._ndcTriangle.initialized) {
            this._ndcTriangle.uninitialize();
        }
        this._program.uninitialize();
    };
    BlitPass.prototype.frame = function () {
        auxiliaries_1.logIf(!this._target || !this._target.valid, auxiliaries_1.LogLevel.Warning, "valid target expected, given " + this._target);
        auxiliaries_1.logIf(!this._framebuffer || !this._framebuffer.valid, auxiliaries_1.LogLevel.Warning, "valid framebuffer for blitting from expected, given " + this._framebuffer);
        var gl = this._context.gl;
        switch (this._readBuffer) {
            case gl.DEPTH_ATTACHMENT:
            case gl.STENCIL_ATTACHMENT:
            case gl.DEPTH_STENCIL_ATTACHMENT:
                return this.programBlit();
            default:
                break;
        }
        if (this._context.supportsBlitFramebuffer && this._enforceProgramBlit === false) {
            return this.functionBlit();
        }
        this.programBlit();
    };
    Object.defineProperty(BlitPass.prototype, "framebuffer", {
        set: function (framebuffer) {
            this.assertInitialized();
            this._framebuffer = framebuffer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BlitPass.prototype, "readBuffer", {
        set: function (readBuffer) {
            this.assertInitialized();
            this._readBuffer = readBuffer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BlitPass.prototype, "drawBuffer", {
        set: function (drawBuffer) {
            this.assertInitialized();
            this._drawBuffer = drawBuffer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BlitPass.prototype, "target", {
        set: function (target) {
            this.assertInitialized();
            this._target = target;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BlitPass.prototype, "filter", {
        set: function (filter) {
            this._filter = filter;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BlitPass.prototype, "srcBounds", {
        set: function (bounds) {
            this._srcBounds = bounds ? gl_matrix_1.vec4.clone(bounds) : undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BlitPass.prototype, "dstBounds", {
        set: function (bounds) {
            this._dstBounds = bounds ? gl_matrix_1.vec4.clone(bounds) : undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BlitPass.prototype, "enforceProgramBlit", {
        set: function (enforce) {
            this._enforceProgramBlit = enforce;
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        initializable_1.Initializable.initialize()
    ], BlitPass.prototype, "initialize", null);
    __decorate([
        initializable_1.Initializable.uninitialize()
    ], BlitPass.prototype, "uninitialize", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], BlitPass.prototype, "frame", null);
    return BlitPass;
}(initializable_1.Initializable));
exports.BlitPass = BlitPass;


/***/ }),

/***/ "./buffer.ts":
/*!*******************!*\
  !*** ./buffer.ts ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var initializable_1 = __webpack_require__(/*! ./initializable */ "./initializable.ts");
var object_1 = __webpack_require__(/*! ./object */ "./object.ts");
var Buffer = (function (_super) {
    __extends(Buffer, _super);
    function Buffer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._target = Buffer.DEFAULT_BUFFER;
        return _this;
    }
    Buffer.prototype.create = function (target) {
        var gl = this._context.gl;
        this._object = gl.createBuffer();
        this._valid = this._object instanceof WebGLBuffer;
        if (this._valid) {
            auxiliaries_1.assert(target === gl.ARRAY_BUFFER || target === gl.ELEMENT_ARRAY_BUFFER, "either ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER expected as buffer target");
            this._target = target;
        }
        return this._object;
    };
    Buffer.prototype.delete = function () {
        auxiliaries_1.assert(this._object instanceof WebGLBuffer, "expected WebGLBuffer object");
        this._context.gl.deleteBuffer(this._object);
        this._object = undefined;
        this._valid = false;
        this._target = Buffer.DEFAULT_BUFFER;
    };
    Buffer.prototype.bind = function () {
        auxiliaries_1.assert(this._target === this._context.gl.ARRAY_BUFFER || this._target === this._context.gl.ELEMENT_ARRAY_BUFFER, "expected either ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER as buffer target");
        this._context.gl.bindBuffer(this._target, this._object);
    };
    Buffer.prototype.unbind = function () {
        this.context.gl.bindBuffer(this._target, Buffer.DEFAULT_BUFFER);
    };
    Buffer.prototype.data = function (data, usage, bind, unbind) {
        if (bind === void 0) { bind = true; }
        if (unbind === void 0) { unbind = true; }
        var gl = this.context.gl;
        if (bind) {
            this.bind();
        }
        gl.bufferData(this._target, data, usage);
        if (unbind) {
            this.unbind();
        }
        this._valid = gl.isBuffer(this._object) && gl.getError() === gl.NO_ERROR;
        var byteLength = typeof data === "number" ? data : data.byteLength;
        var bytes = this._valid ? byteLength : 0;
        this.context.allocationRegister.reallocate(this._identifier, bytes);
    };
    Buffer.prototype.subData = function (dstByteOffset, srcData, srcOffset, length, bind, unbind) {
        if (srcOffset === void 0) { srcOffset = 0; }
        if (length === void 0) { length = 0; }
        if (bind === void 0) { bind = true; }
        if (unbind === void 0) { unbind = true; }
        var gl = this.context.gl;
        if (bind) {
            this.bind();
        }
        this.context.gl2facade.bufferSubData(this._target, dstByteOffset, srcData, srcOffset, length);
        if (unbind) {
            this.unbind();
        }
        this._valid = gl.getError() === gl.NO_ERROR;
    };
    Buffer.prototype.attribEnable = function (index, size, type, normalized, stride, offset, bind, unbind) {
        if (normalized === void 0) { normalized = false; }
        if (stride === void 0) { stride = 0; }
        if (offset === void 0) { offset = 0; }
        if (bind === void 0) { bind = true; }
        if (unbind === void 0) { unbind = true; }
        var gl = this.context.gl;
        if (bind) {
            this.bind();
        }
        gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
        gl.enableVertexAttribArray(index);
        if (unbind) {
            this.unbind();
        }
    };
    Buffer.prototype.attribDisable = function (index, bind, unbind) {
        if (bind === void 0) { bind = true; }
        if (unbind === void 0) { unbind = true; }
        var gl = this.context.gl;
        if (bind) {
            this.bind();
        }
        gl.disableVertexAttribArray(index);
        if (unbind) {
            this.unbind();
        }
    };
    Object.defineProperty(Buffer.prototype, "bytes", {
        get: function () {
            this.assertInitialized();
            return this.context.allocationRegister.allocated(this._identifier);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Buffer.prototype, "target", {
        get: function () {
            this.assertInitialized();
            return this._target;
        },
        enumerable: true,
        configurable: true
    });
    Buffer.DEFAULT_BUFFER = undefined;
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Buffer.prototype, "bind", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Buffer.prototype, "unbind", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Buffer.prototype, "data", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Buffer.prototype, "attribEnable", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Buffer.prototype, "attribDisable", null);
    return Buffer;
}(object_1.AbstractObject));
exports.Buffer = Buffer;


/***/ }),

/***/ "./camera.ts":
/*!*******************!*\
  !*** ./camera.ts ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "../node_modules/gl-matrix/esm/index.js");
var gl_matrix_extensions_1 = __webpack_require__(/*! ./gl-matrix-extensions */ "./gl-matrix-extensions.ts");
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var tuples_1 = __webpack_require__(/*! ./tuples */ "./tuples.ts");
var Camera = (function () {
    function Camera(eye, center, up) {
        this._fovy = Camera.DEFAULT_FOVY;
        this._near = Camera.DEFAULT_NEAR;
        this._far = Camera.DEFAULT_FAR;
        this._viewport = [1, 1];
        this._aspect = 1.0;
        this._altered = false;
        this._eye = eye ? gl_matrix_1.vec3.clone(eye) : gl_matrix_1.vec3.clone(Camera.DEFAULT_EYE);
        this._center = center ? gl_matrix_1.vec3.clone(center) : gl_matrix_1.vec3.clone(Camera.DEFAULT_CENTER);
        this._up = up ? gl_matrix_1.vec3.clone(up) : gl_matrix_1.vec3.clone(Camera.DEFAULT_UP);
    }
    Camera.calculateFovY = function (elementDisplayHeight, eyeToDisplayDistance) {
        return Math.atan(elementDisplayHeight * 0.5 / eyeToDisplayDistance) * 2.0;
    };
    Camera.prototype.invalidate = function (invalidateView, invalidateProjection, invalidateOnlyViewProjection) {
        if (invalidateOnlyViewProjection === void 0) { invalidateOnlyViewProjection = false; }
        if (invalidateView) {
            this._view = undefined;
            this._viewInverse = undefined;
        }
        if (invalidateProjection) {
            this._projection = undefined;
            this._projectionInverse = undefined;
        }
        if (invalidateView || invalidateProjection || invalidateOnlyViewProjection) {
            this._viewProjection = undefined;
            this._viewProjectionInverse = undefined;
        }
        this._altered = true;
    };
    Object.defineProperty(Camera.prototype, "eye", {
        get: function () {
            return this._eye;
        },
        set: function (eye) {
            if (gl_matrix_1.vec3.equals(this._eye, eye)) {
                return;
            }
            this._eye = gl_matrix_1.vec3.clone(eye);
            this.invalidate(true, false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "center", {
        get: function () {
            return this._center;
        },
        set: function (center) {
            if (gl_matrix_1.vec3.equals(this._center, center)) {
                return;
            }
            this._center = gl_matrix_1.vec3.clone(center);
            this.invalidate(true, false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "up", {
        get: function () {
            return this._up;
        },
        set: function (up) {
            if (gl_matrix_1.vec3.equals(this._up, up)) {
                return;
            }
            this._up = gl_matrix_1.vec3.clone(up);
            this.invalidate(true, false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "fovy", {
        get: function () {
            return this._fovy;
        },
        set: function (fovy) {
            if (this._fovy === fovy) {
                return;
            }
            this._fovy = fovy;
            this.invalidate(false, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "fovx", {
        set: function (fovx) {
            var horizontalAngle = fovx * auxiliaries_1.DEG2RAD;
            var verticalAngle = 2.0 * Math.atan(Math.tan(horizontalAngle / 2.0) * (1.0 / this.aspect));
            var fovy = verticalAngle * auxiliaries_1.RAD2DEG;
            if (this._fovy === fovy) {
                return;
            }
            this._fovy = fovy;
            this.invalidate(false, true);
        },
        enumerable: true,
        configurable: true
    });
    Camera.prototype.fovFromLens = function (sensorWidth, focalLength) {
        var horizontalAngle = 2.0 * Math.atan(sensorWidth / (2.0 * focalLength));
        this.fovx = horizontalAngle * auxiliaries_1.RAD2DEG;
    };
    Object.defineProperty(Camera.prototype, "near", {
        get: function () {
            return this._near;
        },
        set: function (near) {
            if (this._near === near) {
                return;
            }
            if (near >= this._far) {
                auxiliaries_1.log(auxiliaries_1.LogLevel.Warning, "near expected to be smaller than far (" + this._far + "), given " + near);
            }
            this._near = near;
            this.invalidate(false, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "far", {
        get: function () {
            return this._far;
        },
        set: function (far) {
            if (this._far === far) {
                return;
            }
            if (this._near >= far) {
                auxiliaries_1.log(auxiliaries_1.LogLevel.Warning, "far expected to be greater than near (" + this._near + "), given " + far);
            }
            this._far = far;
            this.invalidate(false, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "viewport", {
        get: function () {
            return this._viewport;
        },
        set: function (size) {
            if (this._viewport[0] === size[0] && this._viewport[1] === size[1]) {
                return;
            }
            this._viewport = tuples_1.duplicate2(size);
            this.invalidate(false, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "width", {
        get: function () {
            return this._viewport[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "height", {
        get: function () {
            return this._viewport[1];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "aspect", {
        get: function () {
            return this._aspect;
        },
        set: function (aspect) {
            if (this._aspect === aspect) {
                return;
            }
            this._aspect = aspect;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "view", {
        get: function () {
            if (this._view) {
                return this._view;
            }
            this._view = gl_matrix_1.mat4.lookAt(gl_matrix_extensions_1.m4(), this._eye, this._center, this._up);
            return this._view;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "viewInverse", {
        get: function () {
            if (this._viewInverse !== undefined) {
                return this._viewInverse;
            }
            this._viewInverse = gl_matrix_1.mat4.invert(gl_matrix_extensions_1.m4(), this.view);
            return this._viewInverse;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "projection", {
        get: function () {
            if (this._projection) {
                return this._projection;
            }
            this._projection = gl_matrix_1.mat4.perspective(gl_matrix_extensions_1.m4(), this.fovy * auxiliaries_1.DEG2RAD, this.aspect, this.near, this.far);
            return this._projection;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "projectionInverse", {
        get: function () {
            if (this._projectionInverse !== undefined) {
                return this._projectionInverse;
            }
            this._projectionInverse = gl_matrix_1.mat4.invert(gl_matrix_extensions_1.m4(), this.projection);
            return this._projectionInverse;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "viewProjection", {
        get: function () {
            if (this._viewProjection) {
                return this._viewProjection;
            }
            this._viewProjection = gl_matrix_1.mat4.multiply(gl_matrix_extensions_1.m4(), this.projection, this.view);
            this._viewProjection = gl_matrix_1.mat4.multiply(gl_matrix_extensions_1.m4(), this.postViewProjection, this._viewProjection);
            return this._viewProjection;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "viewProjectionInverse", {
        get: function () {
            if (this._viewProjectionInverse !== undefined) {
                return this._viewProjectionInverse;
            }
            this._viewProjectionInverse = gl_matrix_1.mat4.invert(gl_matrix_extensions_1.m4(), this.viewProjection);
            return this._viewProjectionInverse;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "postViewProjection", {
        get: function () {
            if (this._postViewProjection) {
                return this._postViewProjection;
            }
            else {
                return gl_matrix_1.mat4.identity(gl_matrix_extensions_1.m4());
            }
        },
        set: function (matrix) {
            this._postViewProjection = matrix;
            this.invalidate(false, false, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "altered", {
        get: function () {
            return this._altered;
        },
        set: function (status) {
            this._altered = status;
        },
        enumerable: true,
        configurable: true
    });
    Camera.DEFAULT_EYE = gl_matrix_1.vec3.fromValues(0.0, 0.0, 1.0);
    Camera.DEFAULT_CENTER = gl_matrix_1.vec3.fromValues(0.0, 0.0, 0.0);
    Camera.DEFAULT_UP = gl_matrix_1.vec3.fromValues(0.0, 1.0, 0.0);
    Camera.DEFAULT_FOVY = 45.0;
    Camera.DEFAULT_NEAR = 2.0;
    Camera.DEFAULT_FAR = 8.0;
    return Camera;
}());
exports.Camera = Camera;


/***/ }),

/***/ "./cameramodifier.ts":
/*!***************************!*\
  !*** ./cameramodifier.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var camera_1 = __webpack_require__(/*! ./camera */ "./camera.ts");
var CameraModifier = (function () {
    function CameraModifier() {
        this._camera = undefined;
        this._reference = new camera_1.Camera();
    }
    Object.defineProperty(CameraModifier.prototype, "camera", {
        set: function (camera) {
            if (this._camera === camera) {
                return;
            }
            this._camera = camera;
            if (camera === undefined) {
                return;
            }
            Object.assign(this._reference, camera);
            this.update();
        },
        enumerable: true,
        configurable: true
    });
    return CameraModifier;
}());
exports.CameraModifier = CameraModifier;


/***/ }),

/***/ "./canvas.ts":
/*!*******************!*\
  !*** ./canvas.ts ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var rxjs_1 = __webpack_require__(/*! rxjs */ "rxjs");
var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "../node_modules/gl-matrix/esm/index.js");
var gl_matrix_extensions_1 = __webpack_require__(/*! ./gl-matrix-extensions */ "./gl-matrix-extensions.ts");
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var tuples_1 = __webpack_require__(/*! ./tuples */ "./tuples.ts");
var color_1 = __webpack_require__(/*! ./color */ "./color.ts");
var context_1 = __webpack_require__(/*! ./context */ "./context.ts");
var controller_1 = __webpack_require__(/*! ./controller */ "./controller.ts");
var eyegazeeventprovider_1 = __webpack_require__(/*! ./eyegazeeventprovider */ "./eyegazeeventprovider.ts");
var mouseeventprovider_1 = __webpack_require__(/*! ./mouseeventprovider */ "./mouseeventprovider.ts");
var resizable_1 = __webpack_require__(/*! ./resizable */ "./resizable.ts");
var toucheventprovider_1 = __webpack_require__(/*! ./toucheventprovider */ "./toucheventprovider.ts");
var wizard_1 = __webpack_require__(/*! ./wizard */ "./wizard.ts");
var Canvas = (function (_super) {
    __extends(Canvas, _super);
    function Canvas(element, attributes) {
        var _this = _super.call(this) || this;
        _this._framePrecisionSubject = new rxjs_1.ReplaySubject(1);
        _this._size = [0, 0];
        _this._sizeSubject = new rxjs_1.ReplaySubject(1);
        _this._frameScaleSubject = new rxjs_1.ReplaySubject(1);
        _this._frameSizeSubject = new rxjs_1.ReplaySubject(1);
        _this._element = element instanceof HTMLCanvasElement ? element :
            document.getElementById(element);
        _this.observe(_this._element);
        _this._mouseEventProvider = new mouseeventprovider_1.MouseEventProvider(_this._element, 200);
        _this._touchEventProvider = new toucheventprovider_1.TouchEventProvider(_this._element, 200);
        var dataset = _this._element.dataset;
        _this._context = context_1.Context.request(_this._element, attributes);
        _this.configureController(dataset);
        _this.configureSizeAndScale(dataset);
        var dataClearColor;
        if (dataset.clearColor) {
            dataClearColor = gl_matrix_extensions_1.parseVec4(dataset.clearColor);
            auxiliaries_1.logIf(dataClearColor === undefined, auxiliaries_1.LogLevel.Warning, "data-clear-color could not be parsed, given '" + dataset.clearColor + "'");
        }
        _this._clearColor = dataClearColor ?
            new color_1.Color(tuples_1.tuple4(dataClearColor)) : Canvas.DEFAULT_CLEAR_COLOR;
        var dataFramePrecision = dataset.accumulationFormat ?
            dataset.accumulationFormat : Canvas.DEFAULT_FRAME_PRECISION;
        if (!(dataFramePrecision in wizard_1.Wizard.Precision)) {
            dataFramePrecision = Canvas.DEFAULT_FRAME_PRECISION;
            auxiliaries_1.log(auxiliaries_1.LogLevel.Warning, "unknown frame precision '" + dataset.accumulationFormat + "' changed to '" + dataFramePrecision + "'");
        }
        _this._framePrecision = dataFramePrecision;
        _this.framePrecisionNext();
        return _this;
    }
    Canvas.prototype.configureController = function (dataset) {
        this._controller = new controller_1.Controller();
        this._controller.block();
        var dataMFNum;
        if (dataset.multiFrameNumber) {
            dataMFNum = parseInt(dataset.multiFrameNumber, 10);
            auxiliaries_1.logIf(isNaN(dataMFNum), auxiliaries_1.LogLevel.Warning, "data-multi-frame-number could not be parsed, given '" + dataset.multiFrameNumber + "'");
        }
        var dataDFNum;
        if (dataset.debugFrameNumber) {
            dataDFNum = parseInt(dataset.debugFrameNumber, 10);
            auxiliaries_1.logIf(isNaN(dataDFNum), auxiliaries_1.LogLevel.Warning, "data-debug-frame-number could not be parsed, given '" + dataset.debugFrameNumber + "'");
        }
        this._controller.multiFrameNumber = dataMFNum ? dataMFNum : Canvas.DEFAULT_MULTI_FRAME_NUMBER;
        this._controller.debugFrameNumber = dataDFNum ? dataDFNum : 0;
        var mfNumChanged = dataMFNum ? dataMFNum !== this._controller.multiFrameNumber : false;
        auxiliaries_1.logIf(mfNumChanged, auxiliaries_1.LogLevel.Warning, "data-multi-frame-number changed to "
            + (this._controller.multiFrameNumber + ", given '" + dataset.multiFrameNumber + "'"));
        var dfNumChanged = dataDFNum ? dataDFNum !== this._controller.debugFrameNumber : false;
        auxiliaries_1.logIf(dfNumChanged, auxiliaries_1.LogLevel.Warning, "data-debug-frame-number changed to "
            + (this._controller.debugFrameNumber + ", given '" + dataset.debugFrameNumber + "'"));
    };
    Canvas.prototype.configureSizeAndScale = function (dataset) {
        var dataFrameScale;
        if (dataset.frameScale) {
            dataFrameScale = gl_matrix_extensions_1.parseVec2(dataset.frameScale);
            auxiliaries_1.logIf(dataset.frameScale !== undefined && dataFrameScale === undefined, auxiliaries_1.LogLevel.Warning, "data-frame-scale could not be parsed, given '" + dataset.frameScale + "'");
        }
        this._frameScale = dataFrameScale ? tuples_1.tuple2(dataFrameScale) : [1.0, 1.0];
        var dataFrameSize;
        if (dataset.frameSize) {
            dataFrameSize = gl_matrix_extensions_1.parseVec2(dataset.frameSize);
            auxiliaries_1.logIf(dataset.frameSize !== undefined && dataFrameSize === undefined, auxiliaries_1.LogLevel.Warning, "data-frame-size could not be parsed, given '" + dataset.frameSize + "'");
        }
        this._favorSizeOverScale = dataFrameSize !== undefined;
        this._frameSize = dataFrameSize ? tuples_1.tuple2(dataFrameSize) : [this._size[0], this._size[1]];
        this.onResize();
    };
    Canvas.prototype.retrieveSize = function () {
        var size = resizable_1.Resizable.elementSize(this._element);
        if (size === undefined) {
            this._size = [0, 0];
            return;
        }
        this._size = [size[0], size[1]];
        this.sizeNext();
    };
    Canvas.prototype.onResize = function () {
        this.retrieveSize();
        if (this._size[0] === 0 || this._size[1] === 0) {
            auxiliaries_1.log(auxiliaries_1.LogLevel.Debug, "canvas width or height is invalid, resize discarded and controller blocked");
            this._controller.block();
            return;
        }
        this._element.width = this._size[0];
        this._element.height = this._size[1];
        if (this._renderer) {
            this._controller.block();
        }
        if (this._favorSizeOverScale) {
            this.frameSize = this._frameSize;
        }
        else {
            this.frameScale = this._frameScale;
        }
        if (this._renderer) {
            this._controller.unblock();
            this._renderer.swap();
        }
    };
    Canvas.prototype.framePrecisionNext = function () {
        this._framePrecisionSubject.next(this._framePrecision);
    };
    Canvas.prototype.sizeNext = function () {
        this._sizeSubject.next(this._size);
    };
    Canvas.prototype.frameScaleNext = function () {
        this._frameScaleSubject.next(this._frameScale);
    };
    Canvas.prototype.frameSizeNext = function () {
        this._frameSizeSubject.next(this._frameSize);
    };
    Canvas.prototype.bind = function (renderer) {
        var _this = this;
        if (this._renderer === renderer) {
            return;
        }
        this.unbind();
        if (renderer === undefined) {
            return;
        }
        auxiliaries_1.assert(this._controller.blocked, "expected controller to be blocked");
        this._renderer = renderer;
        this._renderer.initialize(this.context, function (force) { return _this._controller.update(force); }, {
            mouseEventProvider: this._mouseEventProvider, touchEventProvider: this._touchEventProvider,
            eyeGazeEventProvider: this._eyeGazeEventProvider,
        });
        this._renderer.frameSize = this._frameSize;
        this._renderer.clearColor = this._clearColor.rgba;
        this._renderer.framePrecision = this._framePrecision;
        this._renderer.debugTexture = -1;
        this._controller.controllable = this._renderer;
        this._controller.unblock();
    };
    Canvas.prototype.unbind = function () {
        if (this._renderer === undefined) {
            return;
        }
        this._controller.block();
        this._controller.controllable = undefined;
        this._renderer = undefined;
    };
    Canvas.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        if (this._renderer) {
            this._renderer.uninitialize();
            this.unbind();
        }
    };
    Canvas.prototype.resize = function () {
        this.onResize();
    };
    Object.defineProperty(Canvas.prototype, "controller", {
        get: function () {
            return this._controller;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Canvas.prototype, "renderer", {
        get: function () {
            return this._renderer;
        },
        set: function (renderer) {
            this.bind(renderer);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Canvas.prototype, "frameScale", {
        get: function () {
            return this._frameScale;
        },
        set: function (frameScale) {
            if (!isFinite(frameScale[0]) || !isFinite(frameScale[1])) {
                auxiliaries_1.log(auxiliaries_1.LogLevel.Warning, "expected finite frame size, non-finite values ignored, given [" + frameScale + "]");
                return;
            }
            auxiliaries_1.logIf(frameScale[0] < 0.0 || frameScale[0] > 2.0, auxiliaries_1.LogLevel.Info, "frame width scale clamped to [0.0,2.0], given " + frameScale[0]);
            auxiliaries_1.logIf(frameScale[1] < 0.0 || frameScale[1] > 2.0, auxiliaries_1.LogLevel.Info, "frame height scale clamped to [0.0,2.0], given " + frameScale[0]);
            var scale = gl_matrix_1.vec2.create();
            gl_matrix_extensions_1.clamp2(scale, frameScale, [0.0, 0.0], [2.0, 2.0]);
            var size = gl_matrix_1.vec2.create();
            gl_matrix_1.vec2.mul(size, this._size, scale);
            gl_matrix_1.vec2.max(size, [1, 1], size);
            gl_matrix_1.vec2.round(size, size);
            gl_matrix_1.vec2.div(scale, size, this._size);
            auxiliaries_1.logIf(!gl_matrix_1.vec2.exactEquals(scale, frameScale), 2, "frame scale was adjusted to " + scale.toString() + ", given " + frameScale.toString());
            this._frameScale = tuples_1.tuple2(scale);
            this._frameSize = tuples_1.tuple2(size);
            this._favorSizeOverScale = false;
            this.frameScaleNext();
            this.frameSizeNext();
            if (this._renderer) {
                this._renderer.frameSize = this._frameSize;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Canvas.prototype, "frameScale$", {
        get: function () {
            return this._frameScaleSubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Canvas.prototype, "frameSize", {
        get: function () {
            return this._frameSize;
        },
        set: function (frameSize) {
            if (!isFinite(frameSize[0]) || !isFinite(frameSize[1])) {
                auxiliaries_1.log(auxiliaries_1.LogLevel.Warning, "expected finite frame size, non-finite values ignored, given [" + frameSize + "]");
                return;
            }
            auxiliaries_1.logIf(frameSize[0] < 1 || frameSize[0] > this._size[0], auxiliaries_1.LogLevel.Info, "frame width scale clamped to [1," + this._size[0] + "], given " + frameSize[0]);
            auxiliaries_1.logIf(frameSize[1] < 1 || frameSize[1] > this._size[1], auxiliaries_1.LogLevel.Info, "frame height scale clamped to [1, " + this._size[1] + "], given " + frameSize[1]);
            var size = gl_matrix_1.vec2.create();
            gl_matrix_extensions_1.clamp2(size, frameSize, [1.0, 1.0], this._size);
            gl_matrix_1.vec2.round(size, size);
            auxiliaries_1.logIf(!gl_matrix_1.vec2.exactEquals(size, frameSize), auxiliaries_1.LogLevel.Warning, "frame size was adjusted to " + size.toString() + ", given " + frameSize.toString());
            var scale = gl_matrix_1.vec2.create();
            gl_matrix_1.vec2.div(scale, size, this._size);
            this._frameScale = tuples_1.tuple2(scale);
            this._frameSize = tuples_1.tuple2(size);
            this._favorSizeOverScale = !gl_matrix_1.vec2.exactEquals(this._frameSize, this._size);
            this.frameScaleNext();
            this.frameSizeNext();
            if (this._renderer) {
                this._renderer.frameSize = this._frameSize;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Canvas.prototype, "frameSize$", {
        get: function () {
            return this._frameSizeSubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Canvas.prototype, "clearColor", {
        get: function () {
            return this._clearColor;
        },
        set: function (clearColor) {
            this._clearColor = clearColor;
            if (this._renderer) {
                this._renderer.clearColor = this._clearColor.rgba;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Canvas.prototype, "framePrecision", {
        get: function () {
            return this._framePrecision;
        },
        set: function (precision) {
            this._framePrecision = precision;
            if (this._renderer) {
                this._renderer.framePrecision = this._framePrecision;
                this._framePrecision = this._renderer.framePrecision;
            }
            this.framePrecisionNext();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Canvas.prototype, "framePrecision$", {
        get: function () {
            return this._framePrecisionSubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Canvas.prototype, "context", {
        get: function () {
            return this._context;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Canvas.prototype, "backend", {
        get: function () {
            return this._context.backendString;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Canvas.prototype, "size", {
        get: function () {
            return this._size;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Canvas.prototype, "size$", {
        get: function () {
            return this._sizeSubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Canvas.prototype, "width", {
        get: function () {
            return this._size[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Canvas.prototype, "height", {
        get: function () {
            return this._size[1];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Canvas.prototype, "element", {
        get: function () {
            return this._element;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Canvas.prototype, "mouseEventProvider", {
        get: function () {
            return this._mouseEventProvider;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Canvas.prototype, "touchEventProvider", {
        get: function () {
            return this._touchEventProvider;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Canvas.prototype, "eyeGazeEventProvider", {
        get: function () {
            return this._eyeGazeEventProvider;
        },
        enumerable: true,
        configurable: true
    });
    Canvas.prototype.activateEyeGazeEventProvider = function (eyeGazeDataStreams, serverAddress) {
        this._eyeGazeEventProvider = new eyegazeeventprovider_1.EyeGazeEventProvider(eyeGazeDataStreams, serverAddress);
    };
    Canvas.DEFAULT_CLEAR_COLOR = new color_1.Color([0.203, 0.227, 0.250, 1.0]);
    Canvas.DEFAULT_FRAME_PRECISION = wizard_1.Wizard.Precision.auto;
    Canvas.DEFAULT_MULTI_FRAME_NUMBER = 0;
    return Canvas;
}(resizable_1.Resizable));
exports.Canvas = Canvas;


/***/ }),

/***/ "./changelookup.ts":
/*!*************************!*\
  !*** ./changelookup.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var ChangeLookup = (function () {
    function ChangeLookup() {
    }
    ChangeLookup.alter = function (path, property) {
        auxiliaries_1.assert(property.hasOwnProperty('any'), "expected alterable object to provide 'any' key");
        property.any = true;
        var names = path.split('.');
        var name = names.shift();
        auxiliaries_1.assert(name === '' || property.hasOwnProperty(name), "expected object to have key '" + name + "' in order to capture alterations");
        if (name !== '' && typeof property[name] !== 'object') {
            property[name] = true;
            return;
        }
        if (name !== '' && names.length > 0) {
            ChangeLookup.alter(names.join('.'), property[name]);
            return;
        }
        var parent = name !== '' ? property[name] : property;
        for (var _i = 0, _a = Object.getOwnPropertyNames(parent); _i < _a.length; _i++) {
            var child = _a[_i];
            if (child === 'any') {
                continue;
            }
            ChangeLookup.alter(child, parent);
        }
    };
    ChangeLookup.reset = function (property) {
        for (var _i = 0, _a = Object.getOwnPropertyNames(property); _i < _a.length; _i++) {
            var name_1 = _a[_i];
            if (typeof property[name_1] === 'object') {
                ChangeLookup.reset(property[name_1]);
                continue;
            }
            property[name_1] = false;
        }
    };
    ChangeLookup.prototype.alter = function (path) {
        return ChangeLookup.alter(path, this);
    };
    ChangeLookup.prototype.reset = function () {
        return ChangeLookup.reset(this);
    };
    return ChangeLookup;
}());
exports.ChangeLookup = ChangeLookup;


/***/ }),

/***/ "./color.ts":
/*!******************!*\
  !*** ./color.ts ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "../node_modules/gl-matrix/esm/index.js");
var gl_matrix_extensions_1 = __webpack_require__(/*! ./gl-matrix-extensions */ "./gl-matrix-extensions.ts");
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var tuples_1 = __webpack_require__(/*! ./tuples */ "./tuples.ts");
var Color = (function () {
    function Color(rgba, alpha) {
        this._rgba = [0.0, 0.0, 0.0, Color.DEFAULT_ALPHA];
        this._altered = false;
        if (rgba === undefined) {
            return;
        }
        if (rgba.length === 3 && alpha !== undefined) {
            this.fromF32(rgba[0], rgba[1], rgba[2], alpha);
        }
        else if (rgba.length === 4) {
            this.fromF32(rgba[0], rgba[1], rgba[2], rgba[3]);
            auxiliaries_1.assert(alpha === undefined, "expected alpha to be undefined when given an 4-tuple in RGBA");
        }
        else {
            this.fromF32(rgba[0], rgba[1], rgba[2]);
        }
    }
    Color.hue2rgb = function (p, q, t) {
        auxiliaries_1.assert(t >= -1.0 && t <= 2.0, "t is expected to be between -1 and 2");
        if (t < 0.0) {
            t += 1.0;
        }
        else if (t > 1.0) {
            t -= 1.0;
        }
        if ((6.0 * t) < 1.0) {
            return p + (q - p) * 6.0 * t;
        }
        if ((2.0 * t) < 1.0) {
            return q;
        }
        if ((3.0 * t) < 2.0) {
            return p + (q - p) * 6.0 * (2.0 / 3.0 - t);
        }
        return p;
    };
    Color.to2CharHexCode = function (value) {
        return (value < 15.5 / 255.0 ? '0' : '') + Math.round(value * 255.0).toString(16);
    };
    Color.hsl2rgb = function (hsl) {
        var hslF = tuples_1.clampf3(hsl, 'HSL input');
        if (hslF[1] === 0.0) {
            return [hslF[2], hslF[2], hslF[2]];
        }
        var q = hslF[2] < 0.5 ? hslF[2] * (1.0 + hslF[1]) : (hslF[2] + hslF[1]) - (hslF[1] * hslF[2]);
        var p = 2.0 * hslF[2] - q;
        return [Color.hue2rgb(p, q, hslF[0] + (1.0 / 3.0)),
            Color.hue2rgb(p, q, hslF[0]), Color.hue2rgb(p, q, hslF[0] - (1.0 / 3.0))];
    };
    Color.rgb2hsl = function (rgb) {
        var rgbF = tuples_1.clampf3(rgb, 'RGB input');
        var hsl = [0.0, 0.0, 0.0];
        var min = Math.min(rgbF[0], rgbF[1], rgbF[2]);
        var max = Math.max(rgbF[0], rgbF[1], rgbF[2]);
        var delta = max - min;
        hsl[2] = (max + min) * 0.5;
        if (delta === 0.0) {
            return hsl;
        }
        hsl[1] = hsl[2] < 0.5 ? delta / (max + min) : delta / (2.0 - max - min);
        var deltaR = (((max - rgbF[0]) / 6.0) + (delta / 2.0)) / delta;
        var deltaG = (((max - rgbF[1]) / 6.0) + (delta / 2.0)) / delta;
        var deltaB = (((max - rgbF[2]) / 6.0) + (delta / 2.0)) / delta;
        if (rgbF[0] === max) {
            hsl[0] = deltaB - deltaG;
        }
        else if (rgbF[1] === max) {
            hsl[0] = deltaR - deltaB + (1.0 / 3.0);
        }
        else {
            hsl[0] = deltaG - deltaR + (2.0 / 3.0);
        }
        return hsl;
    };
    Color.lab2xyz = function (lab) {
        var labF = tuples_1.clampf3(lab, 'LAB input');
        var yr = (100.0 * labF[0] + 16.0) / 116.0;
        var xr = (256.0 * labF[1] - 128.0) / 500.0 + yr;
        var zr = yr - (256.0 * labF[2] - 128.0) / 200.0;
        var xr3 = Math.pow(xr, 3.0);
        var yr3 = Math.pow(yr, 3.0);
        var zr3 = Math.pow(zr, 3.0);
        var x = 0.95047 * (xr3 > 0.008856 ? xr3 : (xr - 16.0 / 116.0) / 7.787);
        var y = 1.00000 * (yr3 > 0.008856 ? yr3 : (yr - 16.0 / 116.0) / 7.787);
        var z = 1.08883 * (zr3 > 0.008856 ? zr3 : (zr - 16.0 / 116.0) / 7.787);
        return [x, y, z];
    };
    Color.xyz2lab = function (xyz) {
        var xyzF = [xyz[0] / 0.95047, xyz[1] / 1.00000, xyz[2] / 1.08883];
        var x = xyzF[0] > 0.008856 ? Math.cbrt(xyzF[0]) : (7.787 * xyzF[0] + (16.0 / 116.0));
        var y = xyzF[1] > 0.008856 ? Math.cbrt(xyzF[1]) : (7.787 * xyzF[1] + (16.0 / 116.0));
        var z = xyzF[2] > 0.008856 ? Math.cbrt(xyzF[2]) : (7.787 * xyzF[2] + (16.0 / 116.0));
        return tuples_1.clampf3([
            (116.0 * y - 16.0) / 100.0,
            (500.0 * (x - y) + 128.0) / 256.0,
            (200.0 * (y - z) + 128.0) / 256.0
        ]);
    };
    Color.xyz2rgb = function (xyz) {
        var r = xyz[0] * +2.04137 + xyz[1] * -0.56495 + xyz[2] * -0.34469;
        var g = xyz[0] * -0.96927 + xyz[1] * +1.87601 + xyz[2] * +0.04156;
        var b = xyz[0] * +0.01345 + xyz[1] * -0.11839 + xyz[2] * +1.01541;
        return tuples_1.clampf3([
            r > 0.0 ? Math.pow(r, 1.0 / 2.19921875) : 0,
            g > 0.0 ? Math.pow(g, 1.0 / 2.19921875) : 0,
            b > 0.0 ? Math.pow(b, 1.0 / 2.19921875) : 0
        ]);
    };
    Color.rgb2xyz = function (rgb) {
        var rgbF = tuples_1.clampf3(rgb, 'RGB input');
        var r = Math.pow(rgbF[0], 2.19921875);
        var g = Math.pow(rgbF[1], 2.19921875);
        var b = Math.pow(rgbF[2], 2.19921875);
        var x = r * 0.57667 + g * 0.18555 + b * 0.18819;
        var y = r * 0.29738 + g * 0.62735 + b * 0.07527;
        var z = r * 0.02703 + g * 0.07069 + b * 0.99110;
        return [x, y, z];
    };
    Color.lab2rgb = function (lab) {
        return Color.xyz2rgb(Color.lab2xyz(lab));
    };
    Color.rgb2lab = function (rgb) {
        return Color.xyz2lab(Color.rgb2xyz(rgb));
    };
    Color.cmyk2rgb = function (cmyk) {
        var cmykF = tuples_1.clampf4(cmyk, 'CMYK input');
        var k = 1.0 - cmykF[3];
        return [(1.0 - cmykF[0]) * k, (1.0 - cmykF[1]) * k, (1.0 - cmykF[2]) * k];
    };
    Color.rgb2cmyk = function (rgb) {
        var rgbF = tuples_1.clampf3(rgb, 'RGB input');
        var k1 = 1.0 - Math.max(rgbF[0], rgbF[1], rgbF[2]);
        var k2 = 1.0 - k1;
        var k3 = k2 === 0.0 ? 0.0 : 1.0 / k2;
        return [(k2 - rgbF[0]) * k3, (k2 - rgbF[1]) * k3, (k2 - rgbF[2]) * k3, k1];
    };
    Color.hex2rgba = function (hex) {
        var rgba = [0.0, 0.0, 0.0, Color.DEFAULT_ALPHA];
        if (!Color.HEX_FORMAT_REGEX.test(hex)) {
            auxiliaries_1.log(auxiliaries_1.LogLevel.Warning, "hexadecimal RGBA color string must conform to either '0x0000', '#0000', '0000', '0x00000000', '#00000000', or '00000000', given '" + hex + "'");
            return rgba;
        }
        var offset = hex.startsWith('0x') ? 2 : hex.startsWith('#') ? 1 : 0;
        var length = Math.floor((hex.length - offset) / 3);
        var stride = length - 1;
        rgba[0] = parseInt(hex[offset + 0 * length] + hex[offset + 0 * length + stride], 16) / 255.0;
        rgba[1] = parseInt(hex[offset + 1 * length] + hex[offset + 1 * length + stride], 16) / 255.0;
        rgba[2] = parseInt(hex[offset + 2 * length] + hex[offset + 2 * length + stride], 16) / 255.0;
        if ((hex.length - offset) === 4 || (hex.length - offset) === 8) {
            rgba[3] = parseInt(hex[offset + 3 * length] + hex[offset + 3 * length + stride], 16) / 255.0;
        }
        auxiliaries_1.assert(!isNaN(rgba[0]) && !isNaN(rgba[1]) && !isNaN(rgba[2]) && !isNaN(rgba[3]), "expected well formated hexadecimal RGBA string, given '" + hex + "'");
        return rgba;
    };
    Color.rgb2hex = function (rgb) {
        var rgbF = tuples_1.clampf3(rgb, 'RGB input');
        var r = Color.to2CharHexCode(rgbF[0]);
        var g = Color.to2CharHexCode(rgbF[1]);
        var b = Color.to2CharHexCode(rgbF[2]);
        return '#' + r + g + b;
    };
    Color.rgba2hex = function (rgba) {
        var rgbaF = tuples_1.clampf4(rgba, 'RGBA input');
        var r = Color.to2CharHexCode(rgbaF[0]);
        var g = Color.to2CharHexCode(rgbaF[1]);
        var b = Color.to2CharHexCode(rgbaF[2]);
        var a = Color.to2CharHexCode(rgbaF[3]);
        return '#' + r + g + b + a;
    };
    Color.lerp = function (x, y, a, space) {
        if (space === void 0) { space = Color.Space.LAB; }
        if (a <= 0.0) {
            return new Color(x.rgba);
        }
        else if (a >= 1.0) {
            return new Color(y.rgba);
        }
        var result = gl_matrix_1.vec4.create();
        switch (space) {
            case Color.Space.CMYK:
                gl_matrix_1.vec4.lerp(result, x.cmyk, y.cmyk, a);
                var alpha = gl_matrix_extensions_1.mix(x.a, y.a, a);
                return new Color().fromCMYK(result[0], result[1], result[2], result[3], alpha);
            case Color.Space.LAB:
                gl_matrix_1.vec4.lerp(result, x.laba, y.laba, a);
                return new Color().fromLAB(result[0], result[1], result[2], result[3]);
            case Color.Space.HSL:
                gl_matrix_1.vec4.lerp(result, x.hsla, y.hsla, a);
                return new Color().fromHSL(result[0], result[1], result[2], result[3]);
            case Color.Space.RGB:
                gl_matrix_1.vec4.lerp(result, x.rgba, y.rgba, a);
                return new Color().fromRGB(result[0], result[1], result[2], result[3]);
        }
    };
    Color.prototype.equals = function (other) {
        return tuples_1.equals4(this._rgba, other._rgba);
    };
    Color.prototype.fromF32 = function (red, green, blue, alpha) {
        if (alpha === void 0) { alpha = Color.DEFAULT_ALPHA; }
        var previous = tuples_1.duplicate4(this._rgba);
        this._rgba[0] = tuples_1.clampf(red, "red value");
        this._rgba[1] = tuples_1.clampf(green, "green value");
        this._rgba[2] = tuples_1.clampf(blue, "blue value");
        this._rgba[3] = tuples_1.clampf(alpha, "alpha value");
        this._altered = !tuples_1.equals4(this._rgba, previous);
        return this;
    };
    Color.prototype.fromUI8 = function (red, green, blue, alpha) {
        if (alpha === void 0) { alpha = Math.floor(Color.DEFAULT_ALPHA * 255); }
        var previous = tuples_1.duplicate4(this._rgba);
        this._rgba[0] = gl_matrix_extensions_1.clamp(red, 0, 255) / 255.0;
        this._rgba[1] = gl_matrix_extensions_1.clamp(green, 0, 255) / 255.0;
        this._rgba[2] = gl_matrix_extensions_1.clamp(blue, 0, 255) / 255.0;
        this._rgba[3] = gl_matrix_extensions_1.clamp(alpha, 0, 255) / 255.0;
        this._altered = !tuples_1.equals4(this._rgba, previous);
        return this;
    };
    Color.prototype.fromRGB = function (red, green, blue, alpha) {
        if (alpha === void 0) { alpha = Color.DEFAULT_ALPHA; }
        var previous = tuples_1.duplicate4(this._rgba);
        this._rgba = tuples_1.clampf4([red, green, blue, alpha], 'RGBA input');
        this._altered = !tuples_1.equals4(this._rgba, previous);
        return this;
    };
    Color.prototype.fromHSL = function (hue, saturation, lightness, alpha) {
        if (alpha === void 0) { alpha = Color.DEFAULT_ALPHA; }
        var previous = tuples_1.duplicate4(this._rgba);
        var rgb = Color.hsl2rgb([hue, saturation, lightness]);
        var alphaf = tuples_1.clampf(alpha, 'ALPHA input');
        this._rgba = [rgb[0], rgb[1], rgb[2], alphaf];
        this._altered = !tuples_1.equals4(this._rgba, previous);
        return this;
    };
    Color.prototype.fromLAB = function (lightness, greenRed, blueYellow, alpha) {
        if (alpha === void 0) { alpha = Color.DEFAULT_ALPHA; }
        var previous = tuples_1.duplicate4(this._rgba);
        var rgb = Color.lab2rgb([lightness, greenRed, blueYellow]);
        var alphaf = tuples_1.clampf(alpha, 'ALPHA input');
        this._rgba = [rgb[0], rgb[1], rgb[2], alphaf];
        this._altered = !tuples_1.equals4(this._rgba, previous);
        return this;
    };
    Color.prototype.fromCMYK = function (cyan, magenta, yellow, key, alpha) {
        if (alpha === void 0) { alpha = Color.DEFAULT_ALPHA; }
        var previous = tuples_1.duplicate4(this._rgba);
        var rgb = Color.cmyk2rgb([cyan, magenta, yellow, key]);
        var alphaf = tuples_1.clampf(alpha, 'ALPHA input');
        this._rgba = [rgb[0], rgb[1], rgb[2], alphaf];
        this._altered = !tuples_1.equals4(this._rgba, previous);
        return this;
    };
    Color.prototype.fromHex = function (hex) {
        var previous = tuples_1.duplicate4(this._rgba);
        this._rgba = Color.hex2rgba(hex);
        this._altered = !tuples_1.equals4(this._rgba, previous);
        return this;
    };
    Color.prototype.gray = function (algorithm) {
        if (algorithm === void 0) { algorithm = Color.GrayscaleAlgorithm.LinearLuminance; }
        switch (algorithm) {
            case Color.GrayscaleAlgorithm.Average:
                return (this._rgba[0] + this._rgba[1] + this._rgba[2]) / 3.0;
            case Color.GrayscaleAlgorithm.LeastSaturatedVariant:
                return (Math.max(this._rgba[0], this._rgba[1], this._rgba[2])
                    - Math.min(this._rgba[0], this._rgba[1], this._rgba[2])) * 0.5;
            case Color.GrayscaleAlgorithm.MinimumDecomposition:
                return Math.min(this._rgba[0], this._rgba[1], this._rgba[2]);
            case Color.GrayscaleAlgorithm.MaximumDecomposition:
                return Math.max(this._rgba[0], this._rgba[1], this._rgba[2]);
            case Color.GrayscaleAlgorithm.LinearLuminance:
                return this._rgba[0] * 0.2126 + this._rgba[1] * 0.7152 + this._rgba[2] * 0.0722;
        }
    };
    Color.prototype.tuple = function (space, alpha) {
        if (alpha === void 0) { alpha = true; }
        switch (space) {
            case Color.Space.RGB:
                return alpha ? this.rgba : this.rgb;
            case Color.Space.LAB:
                return alpha ? this.laba : this.lab;
            case Color.Space.CMYK:
                return alpha ? this.cmyka : this.cmyk;
            case Color.Space.HSL:
                return alpha ? this.hsla : this.hsl;
        }
    };
    Object.defineProperty(Color.prototype, "rgb", {
        get: function () {
            return [this._rgba[0], this._rgba[1], this._rgba[2]];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "rgbUI8", {
        get: function () {
            var ui8Array = new Uint8Array(3);
            ui8Array[0] = Math.round(this._rgba[0] * 255.0);
            ui8Array[1] = Math.round(this._rgba[1] * 255.0);
            ui8Array[2] = Math.round(this._rgba[2] * 255.0);
            return ui8Array;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "rgbF32", {
        get: function () {
            var f32Array = new Float32Array(3);
            f32Array[0] = this._rgba[0];
            f32Array[1] = this._rgba[1];
            f32Array[2] = this._rgba[2];
            return f32Array;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "rgba", {
        get: function () {
            return this._rgba;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "rgbaUI8", {
        get: function () {
            var ui8Array = new Uint8Array(4);
            ui8Array[0] = Math.round(this._rgba[0] * 255.0);
            ui8Array[1] = Math.round(this._rgba[1] * 255.0);
            ui8Array[2] = Math.round(this._rgba[2] * 255.0);
            ui8Array[3] = Math.round(this._rgba[3] * 255.0);
            return ui8Array;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "rgbaF32", {
        get: function () {
            return new Float32Array(this._rgba);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "r", {
        get: function () {
            return this._rgba[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "g", {
        get: function () {
            return this._rgba[1];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "b", {
        get: function () {
            return this._rgba[2];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "a", {
        get: function () {
            return this._rgba[3];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "hexRGB", {
        get: function () {
            return Color.rgb2hex(this.rgb);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "hexRGBA", {
        get: function () {
            return Color.rgba2hex(this._rgba);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "hsl", {
        get: function () {
            return Color.rgb2hsl(this.rgb);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "hsla", {
        get: function () {
            var hsl = Color.rgb2hsl(this.rgb);
            return [hsl[0], hsl[1], hsl[2], this._rgba[3]];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "lab", {
        get: function () {
            return Color.rgb2lab(this.rgb);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "laba", {
        get: function () {
            var lab = Color.rgb2lab(this.rgb);
            return [lab[0], lab[1], lab[2], this._rgba[3]];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "cmyk", {
        get: function () {
            return Color.rgb2cmyk(this.rgb);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "cmyka", {
        get: function () {
            var cmyk = Color.rgb2cmyk(this.rgb);
            return [cmyk[0], cmyk[1], cmyk[2], cmyk[3], this._rgba[3]];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "altered", {
        get: function () {
            return this._altered;
        },
        set: function (status) {
            this._altered = status;
        },
        enumerable: true,
        configurable: true
    });
    Color.DEFAULT_ALPHA = 1.0;
    Color.HEX_FORMAT_REGEX = new RegExp(/^(#|0x)?(([0-9a-f]{3}){1,2}|([0-9a-f]{4}){1,2})$/i);
    return Color;
}());
exports.Color = Color;
(function (Color) {
    var GrayscaleAlgorithm;
    (function (GrayscaleAlgorithm) {
        GrayscaleAlgorithm["Average"] = "average";
        GrayscaleAlgorithm["LinearLuminance"] = "linear-luminance";
        GrayscaleAlgorithm["LeastSaturatedVariant"] = "least-saturated-variant";
        GrayscaleAlgorithm["MinimumDecomposition"] = "minimum-decomposition";
        GrayscaleAlgorithm["MaximumDecomposition"] = "maximum-decomposition";
    })(GrayscaleAlgorithm = Color.GrayscaleAlgorithm || (Color.GrayscaleAlgorithm = {}));
    var Space;
    (function (Space) {
        Space["RGB"] = "rgb";
        Space["HSL"] = "hsl";
        Space["LAB"] = "lab";
        Space["CMYK"] = "cmyk";
    })(Space = Color.Space || (Color.Space = {}));
})(Color = exports.Color || (exports.Color = {}));
exports.Color = Color;


/***/ }),

/***/ "./colorscale.ts":
/*!***********************!*\
  !*** ./colorscale.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var gl_matrix_extensions_1 = __webpack_require__(/*! ./gl-matrix-extensions */ "./gl-matrix-extensions.ts");
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var color_1 = __webpack_require__(/*! ./color */ "./color.ts");
var fetch_1 = __webpack_require__(/*! ./fetch */ "./fetch.ts");
var ColorScale = (function () {
    function ColorScale() {
        this._hint = ColorScale.InterpolationHint.Linear;
        this._colors = new Array();
        this._inverted = false;
    }
    ColorScale.stride = function (type) {
        switch (type) {
            default:
            case ColorScale.ArrayType.RGB:
            case ColorScale.ArrayType.RGBf:
                return 3;
            case ColorScale.ArrayType.RGBA:
            case ColorScale.ArrayType.RGBAf:
                return 4;
        }
    };
    ColorScale.fromPreset = function (url, preset, stepCount) {
        var transform = function (data) {
            var p;
            for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
                var item = data_1[_i];
                if (item.identifier !== preset) {
                    continue;
                }
                p = item;
                break;
            }
            if (p === undefined) {
                return undefined;
            }
            var type = p.format;
            var stride = ColorScale.stride(type);
            var colorsByStepCount = p.colors;
            var index = colorsByStepCount.length - 1;
            for (var i = 0; i < colorsByStepCount.length; ++i) {
                if (colorsByStepCount[i].length !== stepCount * stride) {
                    continue;
                }
                index = i;
                break;
            }
            var colors = colorsByStepCount[index];
            var positionsByStepCount = p.positions;
            if (positionsByStepCount === undefined) {
                return ColorScale.fromArray(colors, type, stepCount, undefined);
            }
            var positions;
            for (var i = 0; i < positionsByStepCount.length; ++i) {
                if (positionsByStepCount[i].length !== colors.length) {
                    continue;
                }
                positions = positionsByStepCount[i];
            }
            return ColorScale.fromArray(colors, type, stepCount, positions);
        };
        return fetch_1.fetchJsonAsync(url, transform, ColorScale.SCHEMA.properties);
    };
    ColorScale.fromArray = function (interleavedColorComponents, type, stepCount, positions) {
        if (stepCount === 0 || interleavedColorComponents.length === 0) {
            return new ColorScale();
        }
        var array = interleavedColorComponents;
        var stride = ColorScale.stride(type);
        var size = array.length / stride;
        var colors = new Array(size);
        for (var i = 0; i < array.length; i += stride) {
            var color = new color_1.Color();
            switch (type) {
                case ColorScale.ArrayType.RGB:
                    color.fromUI8(array[i + 0], array[i + 1], array[i + 2]);
                    break;
                case ColorScale.ArrayType.RGBA:
                    color.fromUI8(array[i + 0], array[i + 1], array[i + 2], array[i + 3]);
                    break;
                case ColorScale.ArrayType.RGBf:
                    color.fromF32(array[i + 0], array[i + 1], array[i + 2]);
                    break;
                case ColorScale.ArrayType.RGBAf:
                    color.fromF32(array[i + 0], array[i + 1], array[i + 2], array[i + 3]);
                    break;
                default:
            }
            colors[i / stride] = color;
        }
        var scale = new ColorScale();
        if (positions === undefined && stepCount === size) {
            scale._colors = colors;
            return scale;
        }
        if (stepCount === 1) {
            scale._colors.push(colors[0]);
        }
        if (positions === undefined) {
            positions = new Array(size);
            positions[0] = 0.0;
            for (var i = 1; i < size; ++i) {
                positions[i] = i / (size - 1);
            }
        }
        auxiliaries_1.assert(positions.length === colors.length, "expected number of positions (" + positions.length + ") to match number of colors (" + colors.length + ")");
        var lower = 0;
        var upper = lower + 1;
        var last = size - 1;
        for (var i = 0; i < stepCount; ++i) {
            var position = i === 0 ? 0 : i / (stepCount - 1);
            if (position <= positions[lower]) {
                scale._colors.push(colors[lower]);
                continue;
            }
            else if (positions[last] <= position) {
                scale._colors.push(colors[last]);
                continue;
            }
            for (var u = lower + 1; u < size; ++u) {
                if (positions[u] < position) {
                    continue;
                }
                upper = u;
                lower = u - 1;
                break;
            }
            var a = (position - positions[lower]) / (positions[upper] - positions[lower]);
            scale._colors.push(color_1.Color.lerp(colors[lower], colors[upper], a, color_1.Color.Space.LAB));
        }
        return scale;
    };
    ColorScale.prototype.lerp = function (position, space) {
        if (space === void 0) { space = color_1.Color.Space.LAB; }
        if (this._colors.length === 0) {
            return undefined;
        }
        if (this._colors.length === 1) {
            return this._colors[0];
        }
        var clamped = gl_matrix_extensions_1.clamp(position, 0.0, 1.0);
        if (clamped <= 0.0) {
            return this._colors[0];
        }
        else if (clamped >= 1.0) {
            return this._colors[this._colors.length - 1];
        }
        var posIndex = position * this._colors.length;
        var lower = Math.floor(posIndex);
        var upper = lower + 1;
        if (upper >= this._colors.length) {
            return this._colors[this._colors.length - 1];
        }
        auxiliaries_1.assert(upper < this._colors.length, "expected upper not exceed maximum color index: " + upper + " < " + this._colors.length);
        if (this._hint === ColorScale.InterpolationHint.Nearest) {
            return this._colors[posIndex - lower <= upper - posIndex ? lower : upper];
        }
        return color_1.Color.lerp(this._colors[lower], this._colors[upper], posIndex - lower, space);
    };
    ColorScale.prototype.color = function (index) {
        if (index < 0 || index >= this._colors.length) {
            return undefined;
        }
        return this._colors[index];
    };
    Object.defineProperty(ColorScale.prototype, "colors", {
        get: function () {
            return this._colors;
        },
        set: function (colors) {
            this._colors = colors;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ColorScale.prototype, "hint", {
        get: function () {
            return this._hint;
        },
        set: function (hint) {
            this._hint = hint;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ColorScale.prototype, "length", {
        get: function () {
            return this._colors.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ColorScale.prototype, "inverted", {
        get: function () {
            return this._inverted;
        },
        enumerable: true,
        configurable: true
    });
    ColorScale.prototype.invert = function () {
        this._colors.reverse();
        this._inverted = !this._inverted;
    };
    ColorScale.prototype.bitsUI8 = function (space, alpha) {
        if (space === void 0) { space = color_1.Color.Space.RGB; }
        if (alpha === void 0) { alpha = true; }
        var size = this._colors.length;
        var stride = alpha ? 4 : 3;
        var bits = new Uint8Array(size * stride);
        for (var i = 0; i < size; ++i) {
            var color = this._colors[i].tuple(space, alpha);
            bits[i * stride + 0] = color[0] * 255;
            bits[i * stride + 1] = color[1] * 255;
            bits[i * stride + 2] = color[2] * 255;
            if (alpha && color.length === 4) {
                bits[i * stride + 3] = color[3] * 255;
            }
        }
        return bits;
    };
    ColorScale.prototype.bitsF32 = function (space, alpha) {
        if (space === void 0) { space = color_1.Color.Space.RGB; }
        if (alpha === void 0) { alpha = true; }
        var size = this._colors.length;
        var stride = alpha ? 4 : 3;
        var bits = new Float32Array(size * stride);
        for (var i = 0; i < size; ++i) {
            var color = this._colors[i].tuple(space, alpha);
            bits[i * stride + 0] = color[0];
            bits[i * stride + 1] = color[1];
            bits[i * stride + 2] = color[2];
            if (alpha && color.length === 4) {
                bits[i * stride + 3] = color[3];
            }
        }
        return bits;
    };
    ColorScale.SCHEMA = __webpack_require__(/*! ./data/colorscalepresets.schema.json */ "./data/colorscalepresets.schema.json");
    return ColorScale;
}());
exports.ColorScale = ColorScale;
(function (ColorScale) {
    var InterpolationHint;
    (function (InterpolationHint) {
        InterpolationHint["Linear"] = "linear";
        InterpolationHint["Nearest"] = "nearest";
    })(InterpolationHint = ColorScale.InterpolationHint || (ColorScale.InterpolationHint = {}));
    var ScaleType;
    (function (ScaleType) {
        ScaleType["sequential"] = "sequential";
        ScaleType["diverging"] = "diverging";
        ScaleType["qualitative"] = "qualitative";
    })(ScaleType = ColorScale.ScaleType || (ColorScale.ScaleType = {}));
    var ArrayType;
    (function (ArrayType) {
        ArrayType["RGB"] = "rgb";
        ArrayType["RGBf"] = "rgbf";
        ArrayType["RGBA"] = "rgba";
        ArrayType["RGBAf"] = "rgbaf";
    })(ArrayType = ColorScale.ArrayType || (ColorScale.ArrayType = {}));
})(ColorScale = exports.ColorScale || (exports.ColorScale = {}));
exports.ColorScale = ColorScale;


/***/ }),

/***/ "./context.ts":
/*!********************!*\
  !*** ./context.ts ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var formatbytesizes_1 = __webpack_require__(/*! ./formatbytesizes */ "./formatbytesizes.ts");
var allocationregister_1 = __webpack_require__(/*! ./allocationregister */ "./allocationregister.ts");
var contextmasquerade_1 = __webpack_require__(/*! ./contextmasquerade */ "./contextmasquerade.ts");
var extensions_1 = __webpack_require__(/*! ./extensions */ "./extensions.ts");
var extensionshash_1 = __webpack_require__(/*! ./extensionshash */ "./extensionshash.ts");
var gl2facade_1 = __webpack_require__(/*! ./gl2facade */ "./gl2facade.ts");
var Context = (function () {
    function Context(context, mask) {
        this._attributes = undefined;
        this._extensions = new Array();
        this._allocationRegister = new allocationregister_1.AllocationRegister();
        this._context = context;
        this._mask = mask;
        var contextString = context.toString();
        {
            var webgl1 = /WebGLRenderingContext/.test(contextString) ||
                /CaptureContext/.test(contextString);
            var webgl2 = /WebGL2RenderingContext/.test(contextString);
            this._backend = webgl1 ? Context.BackendType.WebGL1 : webgl2 ? Context.BackendType.WebGL2 : undefined;
        }
        auxiliaries_1.assert(this._backend !== undefined && this._backend.valueOf() !== Context.BackendType.Invalid.valueOf(), "context is neither webgl nor webgl2, given " + contextString);
        this.queryAttributes();
        this.queryExtensionSupport();
        if (this._mask && this._mask.functionsUndefine) {
            for (var func in this._mask.functionsUndefine) {
                this._context[func] = undefined;
            }
        }
        this._gl2 = new gl2facade_1.GL2Facade(this);
    }
    Context.createMasqueradeFromGETorDataAttribute = function (dataset) {
        var mask = contextmasquerade_1.ContextMasquerade.fromGET();
        if (mask) {
            return mask;
        }
        if (dataset.msqrdH) {
            return contextmasquerade_1.ContextMasquerade.fromHash(dataset.msqrdH);
        }
        if (dataset.msqrdP) {
            return contextmasquerade_1.ContextMasquerade.fromPreset(dataset.msqrdP);
        }
        return undefined;
    };
    Context.request = function (element, attributes) {
        if (attributes === void 0) { attributes = Context.DEFAULT_ATTRIBUTES; }
        var dataset = element.dataset;
        var mask = Context.createMasqueradeFromGETorDataAttribute(dataset);
        var request = mask ? mask.backend :
            dataset.backend ? dataset.backend.toLowerCase() : 'auto';
        if (!(request in Context.BackendRequestType)) {
            auxiliaries_1.log(auxiliaries_1.LogLevel.Warning, "unknown backend '" + dataset.backend + "' changed to '" + Context.BackendRequestType.auto + "'");
            request = 'auto';
        }
        switch (request) {
            case Context.BackendRequestType.webgl:
                break;
            case Context.BackendRequestType.experimental:
            case Context.BackendRequestType.webgl1:
            case Context.BackendRequestType.experimental1:
                request = Context.BackendRequestType.webgl;
                break;
            case Context.BackendRequestType.webgl2:
            case Context.BackendRequestType.experimental2:
                request = Context.BackendRequestType.webgl2;
                break;
            default:
                request = Context.BackendRequestType.auto;
        }
        var context;
        if (request !== Context.BackendRequestType.webgl) {
            context = this.requestWebGL2(element, attributes);
        }
        if (!context) {
            context = this.requestWebGL1(element, attributes);
            auxiliaries_1.logIf(context !== undefined && request === Context.BackendRequestType.webgl2, auxiliaries_1.LogLevel.Info, "backend changed to '" + Context.BackendRequestType.webgl + "', given '" + request + "'");
        }
        auxiliaries_1.assert(!!context, "creating a context failed");
        return new Context(context, mask);
    };
    Context.requestWebGL1 = function (element, attributes) {
        if (attributes === void 0) { attributes = Context.DEFAULT_ATTRIBUTES; }
        var context = element.getContext(Context.BackendRequestType.webgl, attributes);
        if (context) {
            return context;
        }
        context = element.getContext(Context.BackendRequestType.experimental, attributes);
        return context === null ? undefined : context;
    };
    Context.requestWebGL2 = function (element, attributes) {
        if (attributes === void 0) { attributes = Context.DEFAULT_ATTRIBUTES; }
        var context = element.getContext(Context.BackendRequestType.webgl2, attributes);
        if (context) {
            return context;
        }
        context = element.getContext(Context.BackendRequestType.experimental2, attributes);
        return context === null ? undefined : context;
    };
    Context.prototype.queryAttributes = function () {
        var attributes = this._context.getContextAttributes();
        if (attributes === null) {
            auxiliaries_1.log(auxiliaries_1.LogLevel.Error, "querying context attributes failed (probably blocked)");
            return;
        }
        this._attributes = attributes;
    };
    Object.defineProperty(Context.prototype, "alpha", {
        get: function () {
            return this._attributes ? this._attributes.alpha : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "antialias", {
        get: function () {
            return this._attributes ? this._attributes.antialias : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "depth", {
        get: function () {
            return this._attributes ? this._attributes.depth : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "failIfMajorPerformanceCaveat", {
        get: function () {
            return this._attributes ? this._attributes.failIfMajorPerformanceCaveat : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "premultipliedAlpha", {
        get: function () {
            return this._attributes ? this._attributes.premultipliedAlpha : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "preserveDrawingBuffer", {
        get: function () {
            return this._attributes ? this._attributes.preserveDrawingBuffer : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "stencil", {
        get: function () {
            return this._attributes ? this._attributes.stencil : false;
        },
        enumerable: true,
        configurable: true
    });
    Context.prototype.supports = function (extension) {
        if (this._mask && this._mask.extensionsConceal.indexOf(extension) > -1) {
            return false;
        }
        switch (this._backend) {
            case Context.BackendType.WebGL1:
                auxiliaries_1.assert(extensions_1.WEBGL1_EXTENSIONS.indexOf(extension) > -1, "extension " + extension + " not available to WebGL1");
                break;
            case Context.BackendType.WebGL2:
                auxiliaries_1.assert(extensions_1.WEBGL2_DEFAULT_EXTENSIONS.indexOf(extension) === -1, "extension " + extension + " supported by default in WebGL2");
                auxiliaries_1.assert(extensions_1.WEBGL2_EXTENSIONS.indexOf(extension) > -1, "extension " + extension + " not available to WebGL2");
                break;
            default:
                break;
        }
        return this._extensions.indexOf(extension) > -1;
    };
    Context.prototype.enable = function (extensions) {
        for (var _i = 0, extensions_2 = extensions; _i < extensions_2.length; _i++) {
            var extension = extensions_2[_i];
            if (this.isWebGL1 && extensions_1.WEBGL1_EXTENSIONS.indexOf(extension) === -1) {
                continue;
            }
            if (this.isWebGL2 && extensions_1.WEBGL2_EXTENSIONS.indexOf(extension) === -1) {
                continue;
            }
            if (this.supports(extension) === false) {
                continue;
            }
            this.extension(undefined, extension);
        }
    };
    Context.prototype.queryExtensionSupport = function () {
        var extensions = this._context.getSupportedExtensions();
        if (extensions === null) {
            auxiliaries_1.log(auxiliaries_1.LogLevel.Error, "querying supported extensions failed (probably blocked)");
            return;
        }
        for (var _i = 0, extensions_3 = extensions; _i < extensions_3.length; _i++) {
            var extension = extensions_3[_i];
            if (this._mask && this._mask.extensionsConceal.indexOf(extension) > -1) {
                continue;
            }
            this._extensions.push(extension);
        }
        if (this._backend === Context.BackendType.WebGL1) {
            this.ANGLE_instanced_arrays_supported = this.supports('ANGLE_instanced_arrays');
            this.EXT_blend_minmax_supported = this.supports('EXT_blend_minmax');
            this.EXT_color_buffer_half_float_supported = this.supports('EXT_color_buffer_half_float');
            this.EXT_disjoint_timer_query_supported = this.supports('EXT_disjoint_timer_query');
            this.EXT_frag_depth_supported = this.supports('EXT_frag_depth');
            this.EXT_sRGB_supported = this.supports('EXT_sRGB');
            this.EXT_shader_texture_lod_supported = this.supports('EXT_shader_texture_lod');
            this.OES_element_index_uint_supported = this.supports('OES_element_index_uint');
            this.OES_standard_derivatives_supported = this.supports('OES_standard_derivatives');
            this.OES_texture_float_supported = this.supports('OES_texture_float');
            this.OES_texture_half_float_supported = this.supports('OES_texture_half_float');
            this.OES_vertex_array_object_supported = this.supports('OES_vertex_array_object');
            this.WEBGL_color_buffer_float_supported = this.supports('WEBGL_color_buffer_float');
            this.WEBGL_depth_texture_supported = this.supports('WEBGL_depth_texture');
            this.WEBGL_draw_buffers_supported = this.supports('WEBGL_draw_buffers');
        }
        if (this._backend === Context.BackendType.WebGL2) {
            this.EXT_color_buffer_float_supported = this.supports('EXT_color_buffer_float');
            this.EXT_disjoint_timer_query_webgl2_supported = this.supports('EXT_disjoint_timer_query_webgl2');
        }
        this.EXT_texture_filter_anisotropic_supported = this.supports('EXT_texture_filter_anisotropic');
        this.OES_texture_float_linear_supported = this.supports('OES_texture_float_linear');
        this.OES_texture_half_float_linear_supported = this.supports('OES_texture_half_float_linear');
        this.WEBGL_compressed_texture_astc_supported = this.supports('WEBGL_compressed_texture_astc');
        this.WEBGL_compressed_texture_atc_supported = this.supports('WEBGL_compressed_texture_atc');
        this.WEBGL_compressed_texture_etc_supported = this.supports('WEBGL_compressed_texture_etc');
        this.WEBGL_compressed_texture_etc1_supported = this.supports('WEBGL_compressed_texture_etc1');
        this.WEBGL_compressed_texture_pvrtc_supported = this.supports('WEBGL_compressed_texture_pvrtc');
        this.WEBGL_compressed_texture_s3tc_supported = this.supports('WEBGL_compressed_texture_s3tc');
        this.WEBGL_compressed_texture_s3tc_srgb_supported = this.supports('WEBGL_compressed_texture_s3tc_srgb');
        this.WEBGL_debug_renderer_info_supported = this.supports('WEBGL_debug_renderer_info');
        this.WEBGL_debug_shaders_supported = this.supports('WEBGL_debug_shaders');
        this.WEBGL_lose_context_supported = this.supports('WEBGL_lose_context');
    };
    Context.prototype.extension = function (out, extension) {
        if (out === undefined) {
            auxiliaries_1.assert(this.supports(extension), "extension " + extension + " expected to be supported");
            out = this._context.getExtension(extension);
        }
        return out;
    };
    Object.defineProperty(Context.prototype, "allocationRegister", {
        get: function () {
            return this._allocationRegister;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "backend", {
        get: function () {
            return this._backend;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "backendString", {
        get: function () {
            switch (this._backend) {
                case Context.BackendType.WebGL1:
                    return 'WebGL';
                case Context.BackendType.WebGL2:
                    return 'WebGL2';
                default:
                    return undefined;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "extensions", {
        get: function () {
            return this._extensions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "mask", {
        get: function () {
            return this._mask;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "gl", {
        get: function () {
            return this._context;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "gl2facade", {
        get: function () {
            return this._gl2;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "isWebGL1", {
        get: function () {
            return this._backend === Context.BackendType.WebGL1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "isWebGL2", {
        get: function () {
            return this._backend === Context.BackendType.WebGL2;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "supportsInstancedArrays", {
        get: function () {
            return this.ANGLE_instanced_arrays_supported;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "instancedArrays", {
        get: function () {
            return this.extension(this.ANGLE_instanced_arrays, 'ANGLE_instanced_arrays');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "supportsBlendMinmax", {
        get: function () {
            return this.EXT_blend_minmax_supported;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "blendMinmax", {
        get: function () {
            return this.extension(this.EXT_blend_minmax, 'EXT_blend_minmax');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "supportsColorBufferHalfFloat", {
        get: function () {
            return this.EXT_color_buffer_half_float_supported;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "colorBufferHalfFloat", {
        get: function () {
            return this.extension(this.EXT_color_buffer_half_float, 'EXT_color_buffer_half_float');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "supportsDisjointTimerQuery", {
        get: function () {
            return this.EXT_disjoint_timer_query_supported;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "disjointTimerQuery", {
        get: function () {
            return this.extension(this.EXT_disjoint_timer_query, 'EXT_disjoint_timer_query');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "supportsDisjointTimerQueryWebGL2", {
        get: function () {
            return this.EXT_disjoint_timer_query_webgl2_supported;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "disjointTimerQueryWebGL2", {
        get: function () {
            return this.extension(this.EXT_disjoint_timer_query_webgl2, 'EXT_disjoint_timer_query_webgl2');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "supportsFragDepth", {
        get: function () {
            return this.EXT_frag_depth_supported;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "fragDepth", {
        get: function () {
            return this.extension(this.EXT_frag_depth, 'EXT_frag_depth');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "supportsSRGB", {
        get: function () {
            return this.EXT_sRGB_supported;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "sRGB", {
        get: function () {
            return this.extension(this.EXT_sRGB, 'EXT_sRGB');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "supportsShaderTextureLOD", {
        get: function () {
            return this.EXT_shader_texture_lod_supported;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "shaderTextureLOD", {
        get: function () {
            return this.extension(this.EXT_shader_texture_lod, 'EXT_shader_texture_lod');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "supportsTextureFilterAnisotropic", {
        get: function () {
            return this.EXT_texture_filter_anisotropic_supported;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "textureFilterAnisotropic", {
        get: function () {
            return this.extension(this.EXT_texture_filter_anisotropic, 'EXT_texture_filter_anisotropic');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "supportsElementIndexUint", {
        get: function () {
            return this.OES_element_index_uint_supported;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "elementIndexUint", {
        get: function () {
            return this.extension(this.OES_element_index_uint, 'OES_element_index_uint');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "supportsStandardDerivatives", {
        get: function () {
            return this.OES_standard_derivatives_supported;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "standardDerivatives", {
        get: function () {
            return this.extension(this.OES_standard_derivatives, 'OES_standard_derivatives');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "supportsTextureFloat", {
        get: function () {
            return this.OES_texture_float_supported;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "textureFloat", {
        get: function () {
            return this.extension(this.OES_texture_float, 'OES_texture_float');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "supportsTextureFloatLinear", {
        get: function () {
            return this.OES_texture_float_linear_supported;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "textureFloatLinear", {
        get: function () {
            return this.extension(this.OES_texture_float_linear, 'OES_texture_float_linear');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "supportsTextureHalfFloat", {
        get: function () {
            return this.OES_texture_half_float_supported;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "textureHalfFloat", {
        get: function () {
            return this.extension(this.OES_texture_half_float, 'OES_texture_half_float');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "supportsTextureHalfFloatLinear", {
        get: function () {
            return this.OES_texture_half_float_linear_supported;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "textureHalfFloatLinear", {
        get: function () {
            return this.extension(this.OES_texture_half_float_linear, 'OES_texture_half_float_linear');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "supportsVertexArrayObject", {
        get: function () {
            return this.OES_vertex_array_object_supported;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "vertexArrayObject", {
        get: function () {
            return this.extension(this.OES_vertex_array_object, 'OES_vertex_array_object');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "supportsColorBufferFloat", {
        get: function () {
            switch (this._backend) {
                case Context.BackendType.WebGL1:
                    return this.WEBGL_color_buffer_float_supported;
                case Context.BackendType.WebGL2:
                    return this.EXT_color_buffer_float_supported;
                default:
                    return undefined;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "colorBufferFloat", {
        get: function () {
            switch (this._backend) {
                case Context.BackendType.WebGL1:
                    return this.extension(this.WEBGL_color_buffer_float, 'WEBGL_color_buffer_float');
                case Context.BackendType.WebGL2:
                    return this.extension(this.EXT_color_buffer_float, 'EXT_color_buffer_float');
                default:
                    return undefined;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "supportsCompressedTextureASTC", {
        get: function () {
            return this.WEBGL_compressed_texture_astc_supported;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "compressedTextureASTC", {
        get: function () {
            return this.extension(this.WEBGL_compressed_texture_astc, 'WEBGL_compressed_texture_astc');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "supportsCompressedTextureATC", {
        get: function () {
            return this.WEBGL_compressed_texture_atc_supported;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "compressedTextureATC", {
        get: function () {
            return this.extension(this.WEBGL_compressed_texture_atc, 'WEBGL_compressed_texture_atc');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "supportsCompressedTextureETC", {
        get: function () {
            return this.WEBGL_compressed_texture_etc_supported;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "compressedTextureETC", {
        get: function () {
            return this.extension(this.WEBGL_compressed_texture_etc, 'WEBGL_compressed_texture_etc');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "supportsCompressedTextureETC1", {
        get: function () {
            return this.WEBGL_compressed_texture_etc1_supported;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "compressedTextureETC1", {
        get: function () {
            return this.extension(this.WEBGL_compressed_texture_etc1, 'WEBGL_compressed_texture_etc1');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "supportsCompressedTexturePVRTC", {
        get: function () {
            return this.WEBGL_compressed_texture_pvrtc_supported;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "compressedTexturePVRTC", {
        get: function () {
            return this.extension(this.WEBGL_compressed_texture_pvrtc, 'WEBGL_compressed_texture_pvrtc');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "supportsCompressedTextureS3TC", {
        get: function () {
            return this.WEBGL_compressed_texture_s3tc_supported;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "compressedTextureS3TC", {
        get: function () {
            return this.extension(this.WEBGL_compressed_texture_s3tc, 'WEBGL_compressed_texture_s3tc');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "supportsCompressedTextureS3TCSRGB", {
        get: function () {
            return this.WEBGL_compressed_texture_s3tc_srgb_supported;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "compressedTextureS3TCSRGB", {
        get: function () {
            return this.extension(this.WEBGL_compressed_texture_s3tc_srgb, 'WEBGL_compressed_texture_s3tc_srgb');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "supportsDebugRendererInfo", {
        get: function () {
            return this.WEBGL_debug_renderer_info_supported;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "debugRendererInfo", {
        get: function () {
            return this.extension(this.WEBGL_debug_renderer_info, 'WEBGL_debug_renderer_info');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "supportsDebugShaders", {
        get: function () {
            return this.WEBGL_debug_shaders_supported;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "debugShaders", {
        get: function () {
            return this.extension(this.WEBGL_debug_shaders, 'WEBGL_debug_shaders');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "supportsDepthTexture", {
        get: function () {
            return this.WEBGL_depth_texture_supported;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "depthTexture", {
        get: function () {
            return this.extension(this.WEBGL_depth_texture, 'WEBGL_depth_texture');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "supportsDrawBuffers", {
        get: function () {
            return this.WEBGL_draw_buffers_supported;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "drawBuffers", {
        get: function () {
            return this.extension(this.WEBGL_draw_buffers, 'WEBGL_draw_buffers');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "supportsLoseContext", {
        get: function () {
            return this.WEBGL_lose_context_supported;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "loseContext", {
        get: function () {
            return this.extension(this.WEBGL_lose_context, 'WEBGL_lose_context');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "supportsBlitFramebuffer", {
        get: function () {
            return this._context.blitFramebuffer !== undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "supportsReadBuffer", {
        get: function () {
            return this._context.readBuffer !== undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "supportsTexImage3D", {
        get: function () {
            return this._context.texImage3D !== undefined;
        },
        enumerable: true,
        configurable: true
    });
    Context.prototype.param = function (pname) {
        auxiliaries_1.assert(!!this._context, "expected context to be valid");
        return this._context.getParameter(pname);
    };
    Context.prototype.hash = function () {
        return extensionshash_1.ExtensionsHash.encode(this._backend, this._extensions);
    };
    Context.prototype.about = function () {
        var available = 'ok';
        var unavailable = 'na';
        if (this._backend === Context.BackendType.Invalid) {
            return new Array();
        }
        auxiliaries_1.assert(!!this._context, "expected context to be valid");
        var context = this._context;
        var pNamesAndValues = new Array();
        pNamesAndValues.push(['BACKEND (GLOPERATE)', this.backend]);
        pNamesAndValues.push(['CONTEXT_HASH (GLOPERATE)', this.hash()]);
        pNamesAndValues.push(['RENDERER', this.param(context.RENDERER)]);
        pNamesAndValues.push(['VENDOR', this.param(context.VENDOR)]);
        pNamesAndValues.push(['VERSION', this.param(context.VERSION)]);
        pNamesAndValues.push(['SHADING_LANGUAGE_VERSION', this.param(context.SHADING_LANGUAGE_VERSION)]);
        pNamesAndValues.push(['UNMASKED_VENDOR_WEBGL', !this.supportsDebugRendererInfo ? unavailable :
                this.param(this.debugRendererInfo.UNMASKED_VENDOR_WEBGL)]);
        pNamesAndValues.push(['UNMASKED_RENDERER_WEBGL', !this.supportsDebugRendererInfo ? unavailable :
                this.param(this.debugRendererInfo.UNMASKED_RENDERER_WEBGL)]);
        pNamesAndValues.push(['ALPHA (ATTRIBUTE)', String(this.alpha)]);
        pNamesAndValues.push(['ANTIALIAS (ATTRIBUTE)', String(this.antialias)]);
        pNamesAndValues.push(['DEPTH (ATTRIBUTE)', String(this.depth)]);
        pNamesAndValues.push(['FAIL_IF_MAJOR_PERFORMANCE_CAVEAT (ATTRIBUTE)',
            String(this.failIfMajorPerformanceCaveat)]);
        pNamesAndValues.push(['PREMULTIPLIED_ALPHA (ATTRIBUTE)', String(this.premultipliedAlpha)]);
        pNamesAndValues.push(['PRESERVE_DRAWING_BUFFER (ATTRIBUTE)', String(this.preserveDrawingBuffer)]);
        pNamesAndValues.push(['STENCIL (ATTRIBUTE)', String(this.stencil)]);
        pNamesAndValues.push(['DEVICE_PIXEL_RATIO (WINDOW)', window.devicePixelRatio]);
        pNamesAndValues.push(['APP_CODE_NAME (NAVIGATOR)', window.navigator.appCodeName]);
        pNamesAndValues.push(['APP_NAME (NAVIGATOR)', window.navigator.appName]);
        pNamesAndValues.push(['APP_VERSION (NAVIGATOR)', window.navigator.appVersion]);
        pNamesAndValues.push(['PLATFORM (NAVIGATOR)', window.navigator.platform]);
        pNamesAndValues.push(['HARDWARE_CONCURRENCY (NAVIGATOR)', window.navigator.appCodeName]);
        pNamesAndValues.push(['VENDOR (NAVIGATOR)', window.navigator.vendor]);
        pNamesAndValues.push(['VENDOR_SUB (NAVIGATOR)', window.navigator.vendorSub]);
        pNamesAndValues.push(['MAX_COMBINED_TEXTURE_IMAGE_UNITS',
            this.param(context.MAX_COMBINED_TEXTURE_IMAGE_UNITS)]);
        pNamesAndValues.push(['MAX_CUBE_MAP_TEXTURE_SIZE',
            this.param(context.MAX_CUBE_MAP_TEXTURE_SIZE)]);
        pNamesAndValues.push(['MAX_FRAGMENT_UNIFORM_VECTORS',
            this.param(context.MAX_FRAGMENT_UNIFORM_VECTORS)]);
        pNamesAndValues.push(['MAX_RENDERBUFFER_SIZE',
            this.param(context.MAX_RENDERBUFFER_SIZE)]);
        pNamesAndValues.push(['MAX_TEXTURE_IMAGE_UNITS',
            this.param(context.MAX_TEXTURE_IMAGE_UNITS)]);
        pNamesAndValues.push(['MAX_TEXTURE_SIZE',
            this.param(context.MAX_TEXTURE_SIZE)]);
        pNamesAndValues.push(['MAX_VARYING_VECTORS',
            this.param(context.MAX_VARYING_VECTORS)]);
        pNamesAndValues.push(['MAX_VERTEX_ATTRIBS',
            this.param(context.MAX_VERTEX_ATTRIBS)]);
        pNamesAndValues.push(['MAX_VERTEX_TEXTURE_IMAGE_UNITS',
            this.param(context.MAX_VERTEX_TEXTURE_IMAGE_UNITS)]);
        pNamesAndValues.push(['MAX_VERTEX_UNIFORM_VECTORS',
            this.param(context.MAX_VERTEX_UNIFORM_VECTORS)]);
        var MAX_VIEWPORT_DIMS = this.param(context.MAX_VIEWPORT_DIMS);
        pNamesAndValues.push(['MAX_VIEWPORT_DIMS (WIDTH)', MAX_VIEWPORT_DIMS ? MAX_VIEWPORT_DIMS[0] : null]);
        pNamesAndValues.push(['MAX_VIEWPORT_DIMS (HEIGHT)', MAX_VIEWPORT_DIMS ? MAX_VIEWPORT_DIMS[1] : null]);
        if (this.isWebGL2) {
            var context_1 = this._context;
            pNamesAndValues.push(['MAX_3D_TEXTURE_SIZE',
                this.param(context_1.MAX_3D_TEXTURE_SIZE)]);
            pNamesAndValues.push(['MAX_ARRAY_TEXTURE_LAYERS',
                this.param(context_1.MAX_ARRAY_TEXTURE_LAYERS)]);
            pNamesAndValues.push(['MAX_CLIENT_WAIT_TIMEOUT_WEBGL',
                this.param(context_1.MAX_CLIENT_WAIT_TIMEOUT_WEBGL)]);
            pNamesAndValues.push(['MAX_COLOR_ATTACHMENTS',
                this.param(context_1.MAX_COLOR_ATTACHMENTS)]);
            pNamesAndValues.push(['MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS',
                this.param(context_1.MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS)]);
            pNamesAndValues.push(['MAX_COMBINED_UNIFORM_BLOCKS',
                this.param(context_1.MAX_COMBINED_UNIFORM_BLOCKS)]);
            pNamesAndValues.push(['MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS',
                this.param(context_1.MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS)]);
            pNamesAndValues.push(['MAX_DRAW_BUFFERS',
                this.param(context_1.MAX_DRAW_BUFFERS)]);
            pNamesAndValues.push(['MAX_ELEMENT_INDEX',
                this.param(context_1.MAX_ELEMENT_INDEX)]);
            pNamesAndValues.push(['MAX_ELEMENTS_INDICES',
                this.param(context_1.MAX_ELEMENTS_INDICES)]);
            pNamesAndValues.push(['MAX_ELEMENTS_VERTICES',
                this.param(context_1.MAX_ELEMENTS_VERTICES)]);
            pNamesAndValues.push(['MAX_FRAGMENT_INPUT_COMPONENTS',
                this.param(context_1.MAX_FRAGMENT_INPUT_COMPONENTS)]);
            pNamesAndValues.push(['MAX_FRAGMENT_UNIFORM_BLOCKS',
                this.param(context_1.MAX_FRAGMENT_UNIFORM_BLOCKS)]);
            pNamesAndValues.push(['MAX_FRAGMENT_UNIFORM_COMPONENTS',
                this.param(context_1.MAX_FRAGMENT_UNIFORM_COMPONENTS)]);
            pNamesAndValues.push(['MAX_PROGRAM_TEXEL_OFFSET',
                this.param(context_1.MAX_PROGRAM_TEXEL_OFFSET)]);
            pNamesAndValues.push(['MAX_SAMPLES',
                this.param(context_1.MAX_SAMPLES)]);
            pNamesAndValues.push(['MAX_SERVER_WAIT_TIMEOUT',
                this.param(context_1.MAX_SERVER_WAIT_TIMEOUT)]);
            pNamesAndValues.push(['MAX_TEXTURE_LOD_BIAS',
                this.param(context_1.MAX_TEXTURE_LOD_BIAS)]);
            pNamesAndValues.push(['MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS',
                this.param(context_1.MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS)]);
            pNamesAndValues.push(['MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS',
                this.param(context_1.MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS)]);
            pNamesAndValues.push(['MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS',
                this.param(context_1.MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS)]);
            pNamesAndValues.push(['MAX_UNIFORM_BLOCK_SIZE',
                this.param(context_1.MAX_UNIFORM_BLOCK_SIZE)]);
            pNamesAndValues.push(['MAX_UNIFORM_BUFFER_BINDINGS',
                this.param(context_1.MAX_UNIFORM_BUFFER_BINDINGS)]);
            pNamesAndValues.push(['MAX_VARYING_COMPONENTS',
                this.param(context_1.MAX_VARYING_COMPONENTS)]);
            pNamesAndValues.push(['MAX_VERTEX_OUTPUT_COMPONENTS',
                this.param(context_1.MAX_VERTEX_OUTPUT_COMPONENTS)]);
            pNamesAndValues.push(['MAX_VERTEX_UNIFORM_BLOCKS',
                this.param(context_1.MAX_VERTEX_UNIFORM_BLOCKS)]);
            pNamesAndValues.push(['MAX_VERTEX_UNIFORM_COMPONENTS',
                this.param(context_1.MAX_VERTEX_UNIFORM_COMPONENTS)]);
            pNamesAndValues.push(['MIN_PROGRAM_TEXEL_OFFSET',
                this.param(context_1.MIN_PROGRAM_TEXEL_OFFSET)]);
        }
        if (this.isWebGL1) {
            for (var _i = 0, WEBGL1_EXTENSIONS_1 = extensions_1.WEBGL1_EXTENSIONS; _i < WEBGL1_EXTENSIONS_1.length; _i++) {
                var extension = WEBGL1_EXTENSIONS_1[_i];
                pNamesAndValues.push([extension, this.supports(extension) ? available : unavailable]);
            }
        }
        else if (this.isWebGL2) {
            for (var _a = 0, WEBGL2_DEFAULT_EXTENSIONS_1 = extensions_1.WEBGL2_DEFAULT_EXTENSIONS; _a < WEBGL2_DEFAULT_EXTENSIONS_1.length; _a++) {
                var extension = WEBGL2_DEFAULT_EXTENSIONS_1[_a];
                pNamesAndValues.push([extension + " (default)", available]);
            }
            for (var _b = 0, WEBGL2_EXTENSIONS_1 = extensions_1.WEBGL2_EXTENSIONS; _b < WEBGL2_EXTENSIONS_1.length; _b++) {
                var extension = WEBGL2_EXTENSIONS_1[_b];
                pNamesAndValues.push([extension, this.supports(extension) ? available : unavailable]);
            }
        }
        return pNamesAndValues;
    };
    Context.prototype.aboutString = function () {
        var about = this.about();
        var maxPNameLength = 0;
        for (var _i = 0, about_1 = about; _i < about_1.length; _i++) {
            var tuple = about_1[_i];
            maxPNameLength = Math.max(tuple[0].length, maxPNameLength);
        }
        var index = 0;
        var message = "";
        var extensionSeparator = this.isWebGL2 ? 63 + extensions_1.WEBGL2_DEFAULT_EXTENSIONS.length : -1;
        for (var _a = 0, about_2 = about; _a < about_2.length; _a++) {
            var tuple = about_2[_a];
            switch (index) {
                case 2:
                case 6:
                case 8:
                case 15:
                case 16:
                case 23:
                case 35:
                case 63:
                case extensionSeparator:
                    message += "\n";
                    break;
                default:
                    break;
            }
            message += "  " + tuple[0] + " " + '-'.repeat(maxPNameLength - tuple[0].length) + "-- " + tuple[1] + "\n";
            ++index;
        }
        message += "\n";
        return message;
    };
    Context.prototype.logAbout = function (verbosity) {
        if (verbosity === void 0) { verbosity = auxiliaries_1.LogLevel.Info; }
        auxiliaries_1.log(verbosity, "context.about\n\n" + this.aboutString());
    };
    Context.prototype.logAboutIf = function (statement, verbosity) {
        if (verbosity === void 0) { verbosity = auxiliaries_1.LogLevel.Info; }
        auxiliaries_1.logIf(statement, verbosity, "context.about\n\n" + this.aboutString());
    };
    Context.prototype.byteSizeOfFormat = function (format) {
        return formatbytesizes_1.byteSizeOfFormat(this, format);
    };
    Context.DEFAULT_ATTRIBUTES = {
        alpha: true,
        antialias: false,
        depth: true,
        failIfMajorPerformanceCaveat: false,
        premultipliedAlpha: true,
        preserveDrawingBuffer: false,
        stencil: false,
    };
    return Context;
}());
exports.Context = Context;
(function (Context) {
    var BackendType;
    (function (BackendType) {
        BackendType["Invalid"] = "invalid";
        BackendType["WebGL1"] = "webgl1";
        BackendType["WebGL2"] = "webgl2";
    })(BackendType = Context.BackendType || (Context.BackendType = {}));
    var BackendRequestType;
    (function (BackendRequestType) {
        BackendRequestType["auto"] = "auto";
        BackendRequestType["webgl"] = "webgl";
        BackendRequestType["experimental"] = "experimental-webgl";
        BackendRequestType["webgl1"] = "webgl1";
        BackendRequestType["experimental1"] = "experimental-webgl1";
        BackendRequestType["webgl2"] = "webgl2";
        BackendRequestType["experimental2"] = "experimental-webgl2";
    })(BackendRequestType = Context.BackendRequestType || (Context.BackendRequestType = {}));
})(Context = exports.Context || (exports.Context = {}));
exports.Context = Context;


/***/ }),

/***/ "./contextmasquerade.ts":
/*!******************************!*\
  !*** ./contextmasquerade.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var extensionshash_1 = __webpack_require__(/*! ./extensionshash */ "./extensionshash.ts");
var ContextMasquerade = (function () {
    function ContextMasquerade() {
        this._extensionsStrive = new Array();
        this._extensionsConceal = new Array();
        this._functionsUndefine = new Array();
    }
    ContextMasquerade.fromHash = function (hash) {
        var mask = new ContextMasquerade();
        var tuple = extensionshash_1.ExtensionsHash.decode(hash);
        mask._backend = tuple[0];
        mask._extensionsStrive = tuple[1];
        mask._extensionsConceal = extensionshash_1.ExtensionsHash.complement(mask._backend, mask._extensionsStrive);
        return mask;
    };
    ContextMasquerade.fromPreset = function (identifier) {
        var mask = new ContextMasquerade();
        var identifiers = new Array();
        var preset;
        for (var _i = 0, _a = ContextMasquerade.presets(); _i < _a.length; _i++) {
            var p = _a[_i];
            identifiers.push(p.identifier);
            if (p.identifier !== identifier) {
                continue;
            }
            preset = p;
            break;
        }
        if (preset === undefined) {
            auxiliaries_1.assert(false, "expected valid identifier, available ['" + identifiers.join('\', \'') + "'], given '" + identifier + "'");
            return mask;
        }
        preset = preset;
        if (preset.extensions_hash !== undefined) {
            var tuple = extensionshash_1.ExtensionsHash.decode(preset.extensions_hash);
            mask._backend = tuple[0];
            mask._extensionsStrive = tuple[1];
        }
        else {
            mask._backend = preset.backend;
        }
        auxiliaries_1.assert(mask._backend !== undefined, 'expected backend to be included in preset');
        if (preset.extensions_strive === undefined) {
            mask._extensionsStrive = [];
            mask._extensionsConceal = preset.extensions_conceal ? preset.extensions_conceal : [];
        }
        else {
            mask._extensionsStrive = preset.extensions_strive;
            mask._extensionsConceal = extensionshash_1.ExtensionsHash.complement(mask._backend, preset.extensions_strive);
        }
        mask._functionsUndefine = preset.functions_undefine ? preset.functions_undefine : [];
        return mask;
    };
    ContextMasquerade.fromGET = function () {
        var msqrdHash = auxiliaries_1.GETparameter('msqrd_h');
        if (msqrdHash !== undefined) {
            return ContextMasquerade.fromHash(msqrdHash);
        }
        var msqrdPreset = auxiliaries_1.GETparameter('msqrd_p');
        if (msqrdPreset !== undefined) {
            return ContextMasquerade.fromPreset(msqrdPreset);
        }
        return undefined;
    };
    ContextMasquerade.presets = function () {
        return this.MASQUERADE_JSON;
    };
    Object.defineProperty(ContextMasquerade.prototype, "backend", {
        get: function () {
            return this._backend;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ContextMasquerade.prototype, "extensionsStrive", {
        get: function () {
            return this._extensionsStrive;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ContextMasquerade.prototype, "extensionsConceal", {
        get: function () {
            return this._extensionsConceal;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ContextMasquerade.prototype, "functionsUndefine", {
        get: function () {
            return this._functionsUndefine;
        },
        enumerable: true,
        configurable: true
    });
    ContextMasquerade.MASQUERADE_JSON = __webpack_require__(/*! ./data/masquerade.json */ "./data/masquerade.json");
    return ContextMasquerade;
}());
exports.ContextMasquerade = ContextMasquerade;


/***/ }),

/***/ "./controller.ts":
/*!***********************!*\
  !*** ./controller.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var rxjs_1 = __webpack_require__(/*! rxjs */ "rxjs");
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var gl_matrix_extensions_1 = __webpack_require__(/*! ./gl-matrix-extensions */ "./gl-matrix-extensions.ts");
var Controller = (function () {
    function Controller() {
        this._batchSize = 1;
        this._multiFrameNumber = 1;
        this._multiFrameNumberSubject = new rxjs_1.ReplaySubject(1);
        this._debugFrameNumber = 0;
        this._debugFrameNumberSubject = new rxjs_1.ReplaySubject(1);
        this._frameNumber = 0;
        this._frameNumberSubject = new rxjs_1.ReplaySubject(1);
        this._multiFrameDelay = 0;
        this._animationFrameID = 0;
        this._block = false;
        this._blockedUpdates = 0;
        this._intermediateFrameCount = 0;
        this._multiFrameCount = 0;
        this._intermediateFrameTimes = new Array(2);
        this._multiTime = [0.0, 0.0];
        this._invalidated = false;
        this._force = false;
    }
    Object.defineProperty(Controller.prototype, "debug", {
        set: function (value) {
            if (value && auxiliaries_1.logVerbosity() < auxiliaries_1.LogLevel.Debug) {
                auxiliaries_1.logVerbosity(auxiliaries_1.LogLevel.Debug);
                auxiliaries_1.log(auxiliaries_1.LogLevel.Debug, "changed log verbosity to " + auxiliaries_1.LogLevel.Debug + " (debug)");
            }
            Controller._debug = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Controller.prototype, "batch", {
        set: function (size) {
            auxiliaries_1.log(auxiliaries_1.LogLevel.Warning, "(adaptive) batch multi-frame rendering is experimental for now");
            this._batchSize = Math.max(1, size);
        },
        enumerable: true,
        configurable: true
    });
    Controller.prototype.request = function (source) {
        var _this = this;
        if (source === void 0) { source = Controller.RequestType.Frame; }
        if (this._block) {
            this._blockedUpdates++;
            return;
        }
        this._animationFrameID = window.requestAnimationFrame(function () { return _this.invoke(source); });
    };
    Controller.prototype.invoke = function (source) {
        auxiliaries_1.assert(this._controllable !== undefined, "frame sequence invoked without controllable set");
        if (this._invalidated) {
            this._invalidated = false;
            var redraw = this.invokeUpdate();
            if (redraw || this._force) {
                this._force = false;
                this._frameNumber = 0;
                this.cancelWaitMultiFrame();
                this.invokePrepare();
            }
        }
        if (source === Controller.RequestType.Frame && this._frameNumber === 1) {
            if (this._timeoutID === undefined) {
                this.startWaitMultiFrame();
            }
            this._animationFrameID = 0;
            return;
        }
        if (this.isMultiFrameFinished()) {
            this._animationFrameID = 0;
            return;
        }
        this.invokeFrameAndSwap();
        this.request();
    };
    Controller.prototype.invokeUpdate = function () {
        auxiliaries_1.logIf(Controller._debug, auxiliaries_1.LogLevel.Debug, "c invoke update     | " +
            ("pending: '" + this._animationFrameID + "', mfnum: " + this._multiFrameNumber));
        var redraw = this._controllable.update(this._multiFrameNumber);
        return redraw;
    };
    Controller.prototype.invokePrepare = function () {
        auxiliaries_1.logIf(Controller._debug, auxiliaries_1.LogLevel.Debug, "c invoke prepare    |");
        this._multiFrameTime = 0.0;
        this._intermediateFrameTimes[0] = Number.MAX_VALUE;
        this._intermediateFrameTimes[1] = Number.MIN_VALUE;
        this._multiTime[0] = performance.now();
        this._controllable.prepare();
        this._multiTime[1] = performance.now();
        var updateDuration = this._multiTime[1] - this._multiTime[0];
        this._multiFrameTime = updateDuration;
        this._updateFrameTime = updateDuration;
    };
    Controller.prototype.invokeFrameAndSwap = function () {
        auxiliaries_1.logIf(Controller._debug, auxiliaries_1.LogLevel.Debug, "c invoke frame      | pending: '" + this._animationFrameID + "'");
        var debug = this._debugFrameNumber > 0;
        auxiliaries_1.assert(!debug || this._frameNumber < this._debugFrameNumber, "frame number about to exceed debug-frame number");
        var t0 = performance.now();
        var batchEnd = Math.min(this._multiFrameNumber, this._frameNumber + this._batchSize);
        if (this._debugFrameNumber > 0) {
            batchEnd = Math.min(batchEnd, this._debugFrameNumber);
        }
        for (; this._frameNumber < batchEnd; ++this._frameNumber) {
            auxiliaries_1.logIf(Controller._debug, auxiliaries_1.LogLevel.Debug, "c -> frame          | frame: " + this._frameNumber);
            this._controllable.frame(this._frameNumber);
            ++this._intermediateFrameCount;
        }
        auxiliaries_1.logIf(Controller._debug, auxiliaries_1.LogLevel.Debug, "c -> swap           |");
        this._controllable.swap();
        this._multiTime[1] = performance.now();
        var frameDuration = this._multiTime[1] - t0;
        this._multiFrameTime += frameDuration;
        this._intermediateFrameTimes[0] = Math.min(this._intermediateFrameTimes[0], frameDuration);
        this._intermediateFrameTimes[1] = Math.max(this._intermediateFrameTimes[1], frameDuration);
        this.frameNumberNext();
    };
    Controller.prototype.startWaitMultiFrame = function () {
        var _this = this;
        var startMultiFrame = function () {
            _this.request(Controller.RequestType.MultiFrame);
            _this._timeoutID = undefined;
        };
        this._timeoutID = window.setTimeout(startMultiFrame, this._multiFrameDelay);
    };
    Controller.prototype.cancelWaitMultiFrame = function () {
        if (this._timeoutID !== undefined) {
            window.clearTimeout(this._timeoutID);
            this._timeoutID = undefined;
        }
    };
    Controller.prototype.isMultiFrameFinished = function () {
        if (this._debugFrameNumber > 0) {
            return this._frameNumber === this._debugFrameNumber;
        }
        return this._frameNumber === this._multiFrameNumber;
    };
    Controller.prototype.multiFrameNumberNext = function () {
        this._multiFrameNumberSubject.next(this._multiFrameNumber);
    };
    Controller.prototype.debugFrameNumberNext = function () {
        this._debugFrameNumberSubject.next(this._debugFrameNumber);
    };
    Controller.prototype.frameNumberNext = function () {
        this._frameNumberSubject.next(this._frameNumber);
    };
    Controller.prototype.update = function (force) {
        if (force === void 0) { force = false; }
        this._invalidated = true;
        this._force = this._force || force;
        if (this._animationFrameID === 0) {
            this.request();
        }
    };
    Controller.prototype.block = function () {
        auxiliaries_1.logIf(Controller._debug, auxiliaries_1.LogLevel.Debug, "c block   " + (this._block ? '(ignored) ' : '          ') + "|");
        this._block = true;
    };
    Controller.prototype.unblock = function () {
        auxiliaries_1.logIf(Controller._debug, auxiliaries_1.LogLevel.Debug, "c unblock " + (!this._block ? '(ignored) ' : '          ') +
            ("| blocked: #" + this._blockedUpdates));
        if (!this._block) {
            return;
        }
        this._block = false;
        if (this._blockedUpdates > 0) {
            this._blockedUpdates = 0;
            this.update();
        }
    };
    Object.defineProperty(Controller.prototype, "blocked", {
        get: function () {
            return this._block;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Controller.prototype, "controllable", {
        set: function (controllable) {
            if (controllable === this._controllable) {
                return;
            }
            this._controllable = controllable;
            this.update(true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Controller.prototype, "multiFrameNumber", {
        get: function () {
            return this._multiFrameNumber;
        },
        set: function (multiFrameNumber) {
            var value = Math.max(1, isNaN(multiFrameNumber) ? 1 : multiFrameNumber);
            if (value === this._multiFrameNumber) {
                return;
            }
            this._multiFrameNumber = value;
            this.multiFrameNumberNext();
            auxiliaries_1.logIf(value !== multiFrameNumber, auxiliaries_1.LogLevel.Debug, "multi-frame number adjusted to " + value + ", given " + multiFrameNumber);
            if (this.debugFrameNumber > this.multiFrameNumber) {
                this.debugFrameNumber = this.multiFrameNumber;
            }
            else {
                this.update();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Controller.prototype, "multiFrameNumber$", {
        get: function () {
            return this._multiFrameNumberSubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Controller.prototype, "debugFrameNumber", {
        get: function () {
            return this._debugFrameNumber;
        },
        set: function (debugFrameNumber) {
            var value = gl_matrix_extensions_1.clamp(isNaN(debugFrameNumber) ? 0 : debugFrameNumber, 0, this.multiFrameNumber);
            if (value === this._debugFrameNumber) {
                return;
            }
            this._debugFrameNumber = value;
            this.debugFrameNumberNext();
            auxiliaries_1.logIf(value !== debugFrameNumber, auxiliaries_1.LogLevel.Debug, "debug-frame number adjusted to " + value + ", given " + debugFrameNumber);
            this.update(this.debugFrameNumber < this._frameNumber);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Controller.prototype, "debugFrameNumber$", {
        get: function () {
            return this._debugFrameNumberSubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Controller.prototype, "multiFrameDelay", {
        get: function () {
            return this._multiFrameDelay;
        },
        set: function (multiFrameDelay) {
            var value = Math.max(0, multiFrameDelay);
            if (value === this._multiFrameDelay) {
                return;
            }
            this._multiFrameDelay = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Controller.prototype, "frameNumber", {
        get: function () {
            return this._frameNumber;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Controller.prototype, "frameNumber$", {
        get: function () {
            return this._frameNumberSubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Controller.prototype, "intermediateFrameCount", {
        get: function () {
            return this._intermediateFrameCount;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Controller.prototype, "multiFrameCount", {
        get: function () {
            return this._multiFrameCount;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Controller.prototype, "averageFrameTime", {
        get: function () {
            return this._frameNumber === 0 ? 0.0 : this._multiFrameTime / this._frameNumber;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Controller.prototype, "updateFrameTime", {
        get: function () {
            return this._updateFrameTime;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Controller.prototype, "minimumFrameTime", {
        get: function () {
            return this._intermediateFrameTimes[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Controller.prototype, "maximumFrameTime", {
        get: function () {
            return this._intermediateFrameTimes[1];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Controller.prototype, "multiFrameTime", {
        get: function () {
            return this._frameNumber === 0 ? 0.0 : this._multiTime[1] - this._multiTime[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Controller.prototype, "framesPerSecond", {
        get: function () {
            return this._frameNumber === 0 ? 0.0 : 1000.0 / (this.multiFrameTime / this._frameNumber);
        },
        enumerable: true,
        configurable: true
    });
    Controller._debug = false;
    return Controller;
}());
exports.Controller = Controller;
(function (Controller) {
    var RequestType;
    (function (RequestType) {
        RequestType[RequestType["Frame"] = 0] = "Frame";
        RequestType[RequestType["MultiFrame"] = 1] = "MultiFrame";
    })(RequestType = Controller.RequestType || (Controller.RequestType = {}));
})(Controller = exports.Controller || (exports.Controller = {}));
exports.Controller = Controller;


/***/ }),

/***/ "./core/cuboidgeometry.ts":
/*!********************************!*\
  !*** ./core/cuboidgeometry.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "../node_modules/gl-matrix/esm/index.js");
var buffer_1 = __webpack_require__(/*! ../buffer */ "./buffer.ts");
var geometry_1 = __webpack_require__(/*! ../geometry */ "./geometry.ts");
var CuboidGeometry = (function (_super) {
    __extends(CuboidGeometry, _super);
    function CuboidGeometry(context, identifier, uvCoordinates, extent) {
        if (uvCoordinates === void 0) { uvCoordinates = false; }
        if (extent === void 0) { extent = [1.0, 1.0, 1.0]; }
        var _this = _super.call(this, context, identifier) || this;
        _this._vertexLocation = 0;
        _this._extent = gl_matrix_1.vec3.fromValues(1.0, 1.0, 1.0);
        _this._uvCoordinates = false;
        identifier = identifier !== undefined && identifier !== "" ? identifier : _this.constructor.name;
        var vertexVBO = new buffer_1.Buffer(context, identifier + 'VBO');
        _this._buffers.push(vertexVBO);
        var indexBuffer = new buffer_1.Buffer(context, identifier + "IndicesVBO");
        _this._buffers.push(indexBuffer);
        _this._extent = gl_matrix_1.vec3.clone(extent);
        _this._uvCoordinates = uvCoordinates;
        return _this;
    }
    CuboidGeometry.prototype.bindBuffers = function () {
        if (this._uvCoordinates === false) {
            this._buffers[0].attribEnable(this._vertexLocation, 3, this.context.gl.FLOAT, false, 0, 0, true, false);
        }
        else {
            this._buffers[0].attribEnable(this._vertexLocation, 3, this.context.gl.FLOAT, false, 5 * 4, 0, true, false);
            this._buffers[0].attribEnable(this._uvCoordLocation, 2, this.context.gl.FLOAT, false, 5 * 4, 3 * 4, false, false);
        }
        this._buffers[1].bind();
    };
    CuboidGeometry.prototype.unbindBuffers = function () {
        this._buffers[0].attribDisable(this._vertexLocation, true, true);
        if (this._uvCoordinates) {
            this._buffers[0].attribDisable(this._uvCoordLocation, false, true);
        }
        this._buffers[1].unbind();
    };
    CuboidGeometry.prototype.initialize = function (vertexLocation, uvCoordLocation) {
        var _this = this;
        if (vertexLocation === void 0) { vertexLocation = 0; }
        if (uvCoordLocation === void 0) { uvCoordLocation = 1; }
        this._vertexLocation = vertexLocation;
        this._uvCoordLocation = uvCoordLocation;
        var gl = this.context.gl;
        var valid = _super.prototype.initialize.call(this, [gl.ARRAY_BUFFER, gl.ELEMENT_ARRAY_BUFFER], [vertexLocation, uvCoordLocation]);
        var uv = this._uvCoordinates;
        var vertices = uv ? CuboidGeometry.VERTICES_UV : CuboidGeometry.VERTICES;
        vertices = vertices.map(function (value, index) { return value * (uv === false ? _this._extent[index % 3] * 0.5 :
            (index % 5) < 3 ? _this._extent[index % 5] * 0.5 : 1.0); });
        this._buffers[0].data(vertices, gl.STATIC_DRAW);
        this._buffers[1].data(uv ? CuboidGeometry.INDICES_UV : CuboidGeometry.INDICES, gl.STATIC_DRAW);
        this._count = uv ? CuboidGeometry.INDICES_UV.length : CuboidGeometry.INDICES.length;
        return valid;
    };
    CuboidGeometry.prototype.draw = function () {
        var gl = this.context.gl;
        gl.drawElements(gl.TRIANGLE_STRIP, this._count, gl.UNSIGNED_BYTE, 0);
    };
    Object.defineProperty(CuboidGeometry.prototype, "vertexLocation", {
        get: function () {
            return this._vertexLocation;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CuboidGeometry.prototype, "uvCoordLocation", {
        get: function () {
            return this._uvCoordLocation;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CuboidGeometry.prototype, "extent", {
        get: function () {
            return this._extent;
        },
        enumerable: true,
        configurable: true
    });
    CuboidGeometry.VERTICES = new Float32Array([
        -1, -1, +1, +1, -1, +1, -1, +1, +1, +1, +1, +1, -1, -1, -1, +1, -1, -1, -1, +1, -1, +1, +1, -1
    ]);
    CuboidGeometry.INDICES = new Uint8Array([0, 1, 2, 3, 7, 1, 5, 4, 7, 6, 2, 4, 0, 1]);
    CuboidGeometry.VERTICES_UV = new Float32Array([
        -1, -1, +1, 0, 0, +1, -1, +1, 1, 0, -1, +1, +1, 0, 1, +1, +1, +1, 1, 1,
        -1, +1, +1, 0, 0, +1, +1, +1, 1, 0, +1, +1, -1, 1, 1, +1, +1, +1, 0, 1,
        +1, -1, +1, 0, 0, +1, -1, -1, 1, 0, +1, -1, +1, 1, 1, -1, -1, -1, 0, 0,
        +1, -1, -1, 0, 0, -1, -1, -1, 1, 0, +1, +1, -1, 0, 1, -1, +1, -1, 1, 1,
        -1, +1, -1, 0, 1, -1, +1, +1, 1, 1, -1, -1, +1, 1, 0, -1, -1, +1, 0, 1,
    ]);
    CuboidGeometry.INDICES_UV = new Uint8Array([3, 2, 1, 0, 10, 19, 11, 18, 11, 17, 16, 4, 16, 5, 6,
        7, 6, 8, 9, 10, 9, 11, 12, 13, 14, 15]);
    return CuboidGeometry;
}(geometry_1.Geometry));
exports.CuboidGeometry = CuboidGeometry;


/***/ }),

/***/ "./core/geospheregeometry.ts":
/*!***********************************!*\
  !*** ./core/geospheregeometry.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var auxiliaries_1 = __webpack_require__(/*! ../auxiliaries */ "./auxiliaries.ts");
var buffer_1 = __webpack_require__(/*! ../buffer */ "./buffer.ts");
var geometry_1 = __webpack_require__(/*! ../geometry */ "./geometry.ts");
var icosahedron_1 = __webpack_require__(/*! ./icosahedron */ "./core/icosahedron.ts");
var GeosphereGeometry = (function (_super) {
    __extends(GeosphereGeometry, _super);
    function GeosphereGeometry(context, identifier, diameter, textured) {
        if (diameter === void 0) { diameter = 1.0; }
        if (textured === void 0) { textured = true; }
        var _this = _super.call(this, context, identifier) || this;
        _this._diameter = 1.0;
        _this._textured = false;
        _this._size = 0;
        identifier = identifier !== undefined && identifier !== "" ? identifier : _this.constructor.name;
        _this._diameter = diameter;
        _this._textured = textured;
        var indexBuffer = new buffer_1.Buffer(context, identifier + 'IndexBuffer');
        _this._buffers.push(indexBuffer);
        var vertexVBO = new buffer_1.Buffer(context, identifier + 'VBO');
        _this._buffers.push(vertexVBO);
        if (_this._textured) {
            var uvVBO = new buffer_1.Buffer(context, identifier + 'UV');
            _this._buffers.push(uvVBO);
        }
        return _this;
    }
    GeosphereGeometry.prototype.bindBuffers = function () {
        this._buffers[0].bind();
        this._buffers[1].attribEnable(this._vertexLocation, 3, this.context.gl.FLOAT, false, 0, 0, true, false);
        if (this._textured) {
            this._buffers[2].attribEnable(this._texCoordLocation, 2, this.context.gl.FLOAT, false, 0, 0, true, false);
        }
    };
    GeosphereGeometry.prototype.unbindBuffers = function () {
        this._buffers[0].unbind();
        this._buffers[1].attribDisable(this._vertexLocation, true, true);
        if (this._textured) {
            this._buffers[2].attribDisable(this._texCoordLocation, true, true);
        }
    };
    GeosphereGeometry.prototype.initialize = function (aVertex, aTexCoord) {
        if (aVertex === void 0) { aVertex = 0; }
        if (aTexCoord === void 0) { aTexCoord = 1; }
        var gl = this.context.gl;
        this._vertexLocation = aVertex;
        this._texCoordLocation = aTexCoord;
        var valid = _super.prototype.initialize.call(this, [gl.ELEMENT_ARRAY_BUFFER, gl.ARRAY_BUFFER, gl.ARRAY_BUFFER], [8, aVertex, aTexCoord]);
        auxiliaries_1.assert(this._buffers[0] !== undefined && this._buffers[0].object instanceof WebGLBuffer, "expected valid WebGLBuffer");
        auxiliaries_1.assert(this._buffers[1] !== undefined && this._buffers[1].object instanceof WebGLBuffer, "expected valid WebGLBuffer");
        if (this._textured) {
            auxiliaries_1.assert(this._buffers[2] !== undefined && this._buffers[2].object instanceof WebGLBuffer, "expected valid WebGLBuffer");
        }
        var icosahedron = new icosahedron_1.Icosahedron();
        icosahedron.generateGeometry(3);
        if (this._textured) {
            icosahedron.generateTextureCoordinates();
        }
        var faces = icosahedron.faces;
        var indexBuffer = new Uint16Array(faces.length * 3);
        var i = 0;
        for (var _i = 0, faces_1 = faces; _i < faces_1.length; _i++) {
            var face = faces_1[_i];
            indexBuffer[i + 0] = face[0];
            indexBuffer[i + 1] = face[1];
            indexBuffer[i + 2] = face[2];
            i += 3;
        }
        this._buffers[0].data(indexBuffer, gl.STATIC_DRAW);
        this._size = faces.length * 3;
        var vertices = icosahedron.vertices;
        var vertexBuffer = new Float32Array(vertices.length * 3);
        i = 0;
        for (var _a = 0, vertices_1 = vertices; _a < vertices_1.length; _a++) {
            var v = vertices_1[_a];
            vertexBuffer[i + 0] = v[0] * this._diameter;
            vertexBuffer[i + 1] = v[1] * this._diameter;
            vertexBuffer[i + 2] = v[2] * this._diameter;
            i += 3;
        }
        this._buffers[1].data(vertexBuffer, gl.STATIC_DRAW);
        if (this._textured) {
            var texcoords = icosahedron.texcoords;
            var uvBuffer = new Float32Array(texcoords.length * 2);
            if (texcoords && texcoords.length > 0) {
                i = 0;
                for (var _b = 0, texcoords_1 = texcoords; _b < texcoords_1.length; _b++) {
                    var uv = texcoords_1[_b];
                    uvBuffer[i + 0] = uv[0];
                    uvBuffer[i + 1] = uv[1];
                    i += 2;
                }
            }
            this._buffers[2].data(uvBuffer, gl.STATIC_DRAW);
        }
        return valid;
    };
    GeosphereGeometry.prototype.draw = function () {
        var gl = this.context.gl;
        gl.drawElements(gl.TRIANGLES, this._size, gl.UNSIGNED_SHORT, 0);
    };
    Object.defineProperty(GeosphereGeometry.prototype, "vertexLocation", {
        get: function () {
            return this._vertexLocation;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GeosphereGeometry.prototype, "texCoordLocation", {
        get: function () {
            return this._texCoordLocation;
        },
        enumerable: true,
        configurable: true
    });
    return GeosphereGeometry;
}(geometry_1.Geometry));
exports.GeosphereGeometry = GeosphereGeometry;


/***/ }),

/***/ "./core/icosahedron.ts":
/*!*****************************!*\
  !*** ./core/icosahedron.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "../node_modules/gl-matrix/esm/index.js");
var gl_matrix_extensions_1 = __webpack_require__(/*! ../gl-matrix-extensions */ "./gl-matrix-extensions.ts");
var Icosahedron = (function () {
    function Icosahedron() {
    }
    Icosahedron.prototype.baseVertices = function () {
        var t = (1.0 + Math.sqrt(5.0)) * 0.5;
        var i = 1.0 / Math.sqrt(t * t + 1.0);
        var a = t * i;
        var vertices = [
            gl_matrix_1.vec3.fromValues(-i, +a, 0),
            gl_matrix_1.vec3.fromValues(+i, +a, 0),
            gl_matrix_1.vec3.fromValues(-i, -a, 0),
            gl_matrix_1.vec3.fromValues(+i, -a, 0),
            gl_matrix_1.vec3.fromValues(0, -i, +a),
            gl_matrix_1.vec3.fromValues(0, +i, +a),
            gl_matrix_1.vec3.fromValues(0, -i, -a),
            gl_matrix_1.vec3.fromValues(0, +i, -a),
            gl_matrix_1.vec3.fromValues(+a, 0, -i),
            gl_matrix_1.vec3.fromValues(+a, 0, +i),
            gl_matrix_1.vec3.fromValues(-a, 0, -i),
            gl_matrix_1.vec3.fromValues(-a, 0, +i),
        ];
        return vertices;
    };
    Icosahedron.prototype.baseFaces = function () {
        var faces = [
            [0, 11, 5],
            [0, 5, 1],
            [0, 1, 7],
            [0, 7, 10],
            [0, 10, 11],
            [1, 5, 9],
            [5, 11, 4],
            [11, 10, 2],
            [10, 7, 6],
            [7, 1, 8],
            [3, 9, 4],
            [3, 4, 2],
            [3, 2, 6],
            [3, 6, 8],
            [3, 8, 9],
            [4, 9, 5],
            [2, 4, 11],
            [6, 2, 10],
            [8, 6, 7],
            [9, 8, 1],
        ];
        return faces;
    };
    Icosahedron.prototype.refine = function (vertices, faces, levels) {
        var cache = new Map();
        for (var i = 0; i < levels; i++) {
            var size = faces.length;
            for (var f = 0; f < size; f++) {
                var face = faces[f];
                var a = face[0];
                var b = face[1];
                var c = face[2];
                var ab = this.split(a, b, vertices, cache);
                var bc = this.split(b, c, vertices, cache);
                var ca = this.split(c, a, vertices, cache);
                faces[f] = [ab, bc, ca];
                faces.push([a, ab, ca]);
                faces.push([b, bc, ab]);
                faces.push([c, ca, bc]);
            }
        }
    };
    Icosahedron.prototype.split = function (a, b, vertices, cache) {
        var aSmaller = (a < b);
        var smaller = aSmaller ? a : b;
        var greater = aSmaller ? b : a;
        var hash = (smaller << 16) + greater;
        if (cache.has(hash)) {
            return cache.get(hash);
        }
        var pos = gl_matrix_1.vec3.add(gl_matrix_extensions_1.v3(), vertices[a], vertices[b]);
        gl_matrix_1.vec3.normalize(pos, pos);
        vertices.push(pos);
        var index = vertices.length - 1;
        cache.set(hash, index);
        return index;
    };
    Icosahedron.prototype.generateGeometry = function (levels) {
        this._vertices = this.baseVertices();
        this._faces = this.baseFaces();
        if (levels > 0) {
            this.refine(this._vertices, this._faces, Math.min(Math.max(levels, 0), 8));
        }
    };
    Icosahedron.prototype.generateTextureCoordinates = function () {
        this._texcoords = new Array();
        var ofs = 0.5;
        for (var _i = 0, _a = this._vertices; _i < _a.length; _i++) {
            var pos = _a[_i];
            var normal = gl_matrix_1.vec3.normalize(gl_matrix_extensions_1.v3(), pos);
            var uv = gl_matrix_1.vec2.fromValues(ofs - (Math.atan2(normal[2], normal[0]) / (2.0 * Math.PI)), Math.asin(normal[1]) / Math.PI + ofs);
            this._texcoords.push(uv);
        }
    };
    Object.defineProperty(Icosahedron.prototype, "faces", {
        get: function () {
            return this._faces;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Icosahedron.prototype, "vertices", {
        get: function () {
            return this._vertices;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Icosahedron.prototype, "texcoords", {
        get: function () {
            return this._texcoords;
        },
        enumerable: true,
        configurable: true
    });
    return Icosahedron;
}());
exports.Icosahedron = Icosahedron;


/***/ }),

/***/ "./core/index.ts":
/*!***********************!*\
  !*** ./core/index.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var cuboidgeometry_1 = __webpack_require__(/*! ./cuboidgeometry */ "./core/cuboidgeometry.ts");
exports.CuboidGeometry = cuboidgeometry_1.CuboidGeometry;
var icosahedron_1 = __webpack_require__(/*! ./icosahedron */ "./core/icosahedron.ts");
exports.Icosahedron = icosahedron_1.Icosahedron;
var geospheregeometry_1 = __webpack_require__(/*! ./geospheregeometry */ "./core/geospheregeometry.ts");
exports.GeosphereGeometry = geospheregeometry_1.GeosphereGeometry;
var planegeometry_1 = __webpack_require__(/*! ./planegeometry */ "./core/planegeometry.ts");
exports.PlaneGeometry = planegeometry_1.PlaneGeometry;
var resourcemanager_1 = __webpack_require__(/*! ./resourcemanager */ "./core/resourcemanager.ts");
exports.ResourceManager = resourcemanager_1.ResourceManager;


/***/ }),

/***/ "./core/planegeometry.ts":
/*!*******************************!*\
  !*** ./core/planegeometry.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "../node_modules/gl-matrix/esm/index.js");
var buffer_1 = __webpack_require__(/*! ../buffer */ "./buffer.ts");
var geometry_1 = __webpack_require__(/*! ../geometry */ "./geometry.ts");
var PlaneGeometry = (function (_super) {
    __extends(PlaneGeometry, _super);
    function PlaneGeometry(context, identifier) {
        var _this = _super.call(this, context, identifier) || this;
        _this._vertexLocation = 0;
        _this._texCoordLocation = 1;
        _this._translation = gl_matrix_1.vec3.fromValues(0, 0, 0);
        _this._scale = gl_matrix_1.vec3.fromValues(1, 1, 1);
        _this._rotation = gl_matrix_1.quat.create();
        identifier = identifier !== undefined && identifier !== "" ? identifier : _this.constructor.name;
        var vertexVBO = new buffer_1.Buffer(context, identifier + 'VertexVBO');
        var texCoordVBO = new buffer_1.Buffer(context, identifier + 'TexCoordVBO');
        var indexBuffer = new buffer_1.Buffer(context, identifier + 'IndexBuffer');
        _this._buffers.push(vertexVBO);
        _this._buffers.push(texCoordVBO);
        _this._buffers.push(indexBuffer);
        return _this;
    }
    PlaneGeometry.prototype.bindBuffers = function () {
        this._buffers[0].attribEnable(this._vertexLocation, 3, this.context.gl.FLOAT, false, 0, 0, true, false);
        this._buffers[1].attribEnable(this._texCoordLocation, 2, this.context.gl.FLOAT, false, 0, 0, true, false);
        this._buffers[2].bind();
    };
    PlaneGeometry.prototype.unbindBuffers = function () {
        this._buffers[0].attribDisable(this._vertexLocation, true, true);
        this._buffers[1].attribDisable(this._texCoordLocation, true, true);
        this._buffers[2].unbind();
    };
    PlaneGeometry.prototype.initialize = function (aVertex, aTexCoord) {
        if (aVertex === void 0) { aVertex = 0; }
        if (aTexCoord === void 0) { aTexCoord = 1; }
        var gl = this.context.gl;
        this._vertexLocation = aVertex;
        this._texCoordLocation = aTexCoord;
        var valid = _super.prototype.initialize.call(this, [gl.ARRAY_BUFFER, gl.ARRAY_BUFFER, gl.ELEMENT_ARRAY_BUFFER], [aVertex, aTexCoord, 8]);
        this._buffers[0].data(PlaneGeometry.VERTICES, gl.STATIC_DRAW);
        this._buffers[1].data(PlaneGeometry.UV, gl.STATIC_DRAW);
        this._buffers[2].data(PlaneGeometry.INDICES, gl.STATIC_DRAW);
        return valid;
    };
    PlaneGeometry.prototype.draw = function () {
        var gl = this.context.gl;
        gl.drawElements(gl.TRIANGLE_STRIP, PlaneGeometry.INDICES.length, gl.UNSIGNED_BYTE, 0);
    };
    Object.defineProperty(PlaneGeometry.prototype, "translation", {
        set: function (t) {
            this._translation = t;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PlaneGeometry.prototype, "scale", {
        set: function (s) {
            this._scale = gl_matrix_1.vec3.fromValues(s[0], 1.0, s[1]);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PlaneGeometry.prototype, "rotation", {
        set: function (q) {
            this._rotation = q;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PlaneGeometry.prototype, "transformation", {
        get: function () {
            var out = gl_matrix_1.mat4.create();
            return gl_matrix_1.mat4.fromRotationTranslationScale(out, this._rotation, this._translation, this._scale);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PlaneGeometry.prototype, "vertexLocation", {
        get: function () {
            return this._vertexLocation;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PlaneGeometry.prototype, "texCoordLocation", {
        get: function () {
            return this._texCoordLocation;
        },
        enumerable: true,
        configurable: true
    });
    PlaneGeometry.VERTICES = new Float32Array([
        -1.0, 0.0, -1.0,
        -1.0, 0.0, +1.0,
        +1.0, 0.0, -1.0,
        +1.0, 0.0, +1.0,
    ]);
    PlaneGeometry.UV = new Float32Array([
        -1.0, -1.0,
        -1.0, +1.0,
        +1.0, -1.0,
        +1.0, +1.0,
    ]);
    PlaneGeometry.INDICES = new Uint8Array([0, 1, 2, 3]);
    return PlaneGeometry;
}(geometry_1.Geometry));
exports.PlaneGeometry = PlaneGeometry;


/***/ }),

/***/ "./core/resourcemanager.ts":
/*!*********************************!*\
  !*** ./core/resourcemanager.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var auxiliaries_1 = __webpack_require__(/*! ../auxiliaries */ "./auxiliaries.ts");
var buffer_1 = __webpack_require__(/*! ../buffer */ "./buffer.ts");
var geometry_1 = __webpack_require__(/*! ../geometry */ "./geometry.ts");
var scene_1 = __webpack_require__(/*! ../scene */ "./scene/index.ts");
var texture2d_1 = __webpack_require__(/*! ../texture2d */ "./texture2d.ts");
var ResourceManager = (function () {
    function ResourceManager(context) {
        this._texture2Ds = new Map();
        this._materials = new Map();
        this._geometries = new Map();
        this._buffers = new Map();
        this._context = context;
    }
    ResourceManager.prototype.fetchTexture2D = function (identifier, url, crossOrigin) {
        if (crossOrigin === void 0) { crossOrigin = false; }
        if (this._texture2Ds.has(identifier)) {
            return undefined;
        }
        var texture = new texture2d_1.Texture2D(this._context, identifier);
        auxiliaries_1.assert(texture.identifier === identifier, "expected object identifier to be unchanged");
        this._texture2Ds.set(identifier, texture);
        return texture.fetch(url, crossOrigin);
    };
    ResourceManager.prototype.add = function (resource, identifiers) {
        var addedIdentifiers = new Array();
        if (resource instanceof texture2d_1.Texture2D) {
            var texture = resource;
            for (var _i = 0, identifiers_1 = identifiers; _i < identifiers_1.length; _i++) {
                var identifier = identifiers_1[_i];
                if (!this._texture2Ds.has(identifier)) {
                    this._texture2Ds.set(identifier, texture);
                    addedIdentifiers.push(identifier);
                }
            }
        }
        if (resource instanceof scene_1.Material) {
            var material = resource;
            for (var _a = 0, identifiers_2 = identifiers; _a < identifiers_2.length; _a++) {
                var identifier = identifiers_2[_a];
                if (!this._materials.has(identifier)) {
                    this._materials.set(identifier, material);
                    addedIdentifiers.push(identifier);
                }
            }
        }
        if (resource instanceof geometry_1.Geometry) {
            var geometry = resource;
            for (var _b = 0, identifiers_3 = identifiers; _b < identifiers_3.length; _b++) {
                var identifier = identifiers_3[_b];
                if (!this._geometries.has(identifier)) {
                    this._geometries.set(identifier, geometry);
                    addedIdentifiers.push(identifier);
                }
            }
        }
        if (resource instanceof buffer_1.Buffer) {
            var buffer = resource;
            for (var _c = 0, identifiers_4 = identifiers; _c < identifiers_4.length; _c++) {
                var identifier = identifiers_4[_c];
                if (!this._buffers.has(identifier)) {
                    this._buffers.set(identifier, buffer);
                    addedIdentifiers.push(identifier);
                }
            }
        }
        return addedIdentifiers;
    };
    ResourceManager.prototype.get = function (identifier) {
        if (this._texture2Ds.has(identifier)) {
            return this._texture2Ds.get(identifier);
        }
        if (this._materials.has(identifier)) {
            return this._materials.get(identifier);
        }
        if (this._geometries.has(identifier)) {
            return this._geometries.get(identifier);
        }
        if (this._buffers.has(identifier)) {
            return this._buffers.get(identifier);
        }
        return undefined;
    };
    ResourceManager.prototype.uninitialize = function () {
        for (var _i = 0, _a = Array.from(this._geometries.values()); _i < _a.length; _i++) {
            var geometry = _a[_i];
            if (geometry.initialized) {
                geometry.uninitialize();
            }
        }
        this._geometries.clear();
        for (var _b = 0, _c = Array.from(this._texture2Ds.values()); _b < _c.length; _b++) {
            var tex2D = _c[_b];
            if (tex2D.initialized) {
                tex2D.uninitialize();
            }
        }
        this._texture2Ds.clear();
        for (var _d = 0, _e = Array.from(this._buffers.values()); _d < _e.length; _d++) {
            var buffer = _e[_d];
            if (buffer.initialized) {
                buffer.uninitialize();
            }
        }
        this._buffers.clear();
        this._materials.clear();
    };
    return ResourceManager;
}());
exports.ResourceManager = ResourceManager;


/***/ }),

/***/ "./data/colorscalepresets.schema.json":
/*!********************************************!*\
  !*** ./data/colorscalepresets.schema.json ***!
  \********************************************/
/*! exports provided: id, title, description, type, items, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"id\":\"/ColorScalePresets\",\"title\":\"Color Scale Presets Schema\",\"description\":\"JSON schema for a color scale presets data, used in the webgl-operate module for validation.\",\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"identifier\":{\"type\":\"string\"},\"type\":{\"type\":\"string\",\"enum\":[\"sequential\",\"diverging\",\"qualitative\"]},\"format\":{\"type\":\"string\",\"enum\":[\"rgb\",\"rgbf\"]},\"colors\":{\"type\":\"array\",\"items\":{\"type\":\"array\",\"items\":{\"type\":[\"integer\",\"number\"]}}},\"positions\":{\"type\":\"array\",\"items\":{\"type\":\"array\",\"items\":{\"type\":[\"integer\",\"number\"]}}}},\"required\":[\"identifier\",\"format\",\"colors\"],\"additionalProperties\":false}}");

/***/ }),

/***/ "./data/goldenset08.json":
/*!*******************************!*\
  !*** ./data/goldenset08.json ***!
  \*******************************/
/*! exports provided: kernel, size, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"kernel\":[[[[0.201114,0.016597],[-0.090682,-0.219471],[-0.180852,0.162495],[0.055216,0.398563],[-0.41692,-0.073573],[0.291284,-0.365369],[0.437182,0.252665],[-0.32675,-0.455539]]]],\"size\":{\"depth\":1,\"height\":1,\"width\":8}}");

/***/ }),

/***/ "./data/goldenset128.json":
/*!********************************!*\
  !*** ./data/goldenset128.json ***!
  \********************************/
/*! exports provided: kernel, size, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"kernel\":[[[[-0.992216,-0.610879],[-0.975957,0.625189],[-0.965904,-0.138743],[-0.949645,-0.902675],[-0.933385,0.333393],[-0.923332,-0.430539],[-0.907073,0.805529],[-0.89702,0.0415974],[-0.88076,-0.722335],[-0.864501,0.513733],[-0.854448,-0.250199],[-0.838189,0.985869],[-0.811876,0.221937],[-0.795617,-0.541995],[-0.785564,0.694073],[-0.769305,-0.0698586],[-0.753045,-0.833791],[-0.742992,0.402277],[-0.726733,-0.361655],[-0.70042,0.874413],[-0.684161,0.110482],[-0.674108,-0.65345],[-0.657849,0.582618],[-0.631536,-0.181314],[-0.615277,-0.945246],[-0.605224,0.290822],[-0.588964,-0.47311],[-0.572705,0.762958],[-0.562652,-0.000974417],[-0.546393,-0.764906],[-0.52008,0.471162],[-0.503821,-0.29277],[-0.493768,0.943298],[-0.477509,0.179366],[-0.461249,-0.584566],[-0.451196,0.651502],[-0.434937,-0.11243],[-0.424884,-0.876362],[-0.408624,0.359706],[-0.392365,-0.404226],[-0.382312,0.831842],[-0.366053,0.0679097],[-0.33974,-0.696022],[-0.323481,0.540046],[-0.313428,-0.223886],[-0.297168,-0.987818],[-0.280909,0.24825],[-0.270856,-0.515682],[-0.254597,0.720386],[-0.228284,-0.0435462],[-0.212025,-0.807478],[-0.201972,0.42859],[-0.185713,-0.335342],[-0.169453,0.900726],[-0.1594,0.136794],[-0.143141,-0.627138],[-0.133088,0.60893],[-0.116828,-0.155002],[-0.100569,-0.918934],[-0.0905161,0.317134],[-0.0742567,-0.446798],[-0.0479443,0.78927],[-0.0316849,0.0253379],[-0.021632,-0.738594],[-0.00537252,0.497474],[0.0108869,-0.266458],[0.0209398,0.96961],[0.0371993,0.205678],[0.0635116,-0.558254],[0.079771,0.677814],[0.089824,-0.086118],[0.106083,-0.85005],[0.132396,0.386018],[0.148655,-0.377914],[0.158708,0.858154],[0.174968,0.0942221],[0.191227,-0.66971],[0.20128,0.566358],[0.217539,-0.197574],[0.243852,-0.961506],[0.260111,0.274562],[0.270164,-0.48937],[0.286423,0.746698],[0.302683,-0.0172338],[0.312736,-0.781166],[0.328995,0.454902],[0.339048,-0.30903],[0.355308,0.927038],[0.371567,0.163106],[0.38162,-0.600826],[0.397879,0.635242],[0.424192,-0.12869],[0.440451,-0.892622],[0.450504,0.343446],[0.466763,-0.420486],[0.483023,0.815582],[0.493076,0.0516503],[0.509335,-0.712282],[0.535648,0.523786],[0.551907,-0.240146],[0.56196,0.995922],[0.578219,0.23199],[0.604532,-0.531942],[0.620791,0.704126],[0.630844,-0.0598056],[0.647104,-0.823738],[0.663363,0.41233],[0.673416,-0.351602],[0.689675,0.884466],[0.715988,0.120534],[0.732247,-0.643398],[0.7423,0.59267],[0.758559,-0.171262],[0.774819,-0.935194],[0.784872,0.300874],[0.801131,-0.463058],[0.811184,0.77301],[0.827444,0.0090785],[0.843703,-0.754853],[0.853756,0.481215],[0.870015,-0.282717],[0.896328,0.953351],[0.912587,0.189419],[0.92264,-0.574513],[0.9389,0.661555],[0.955159,-0.102377],[0.965212,-0.866309],[0.981471,0.369759]]]],\"size\":{\"depth\":1,\"height\":1,\"width\":128}}");

/***/ }),

/***/ "./data/goldenset64.json":
/*!*******************************!*\
  !*** ./data/goldenset64.json ***!
  \*******************************/
/*! exports provided: kernel, size, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"kernel\":[[[[-0.058976,0.021042],[0.065636,-0.034686],[0.023064,0.111212],[-0.011378,-0.124856],[-0.122834,-0.069128],[0.155806,0.055484],[-0.170432,0.07677],[-0.101548,0.16694],[0.190248,-0.090414],[0.121364,-0.180584],[0.100078,0.201382],[-0.080262,-0.215026],[-0.247446,-0.0134],[-0.024534,0.25711],[-0.204874,-0.159298],[0.267262,-0.000244],[0.22469,0.145654],[0.031194,-0.270754],[-0.213004,0.222668],[-0.303174,0.132498],[0.245976,-0.236312],[-0.13599,0.312838],[0.177092,0.291552],[-0.157276,-0.305196],[0.31486,-0.146142],[0.04435,0.34728],[-0.337616,-0.10357],[-0.04582,-0.360924],[0.168962,-0.326482],[0.357432,0.089926],[-0.372058,0.042328],[-0.281888,-0.249468],[0.301704,0.235824],[-0.067106,0.403008],[0.40503,-0.055972],[0.078792,-0.416652],[-0.350772,0.278396],[-0.4065,-0.19374],[-0.260602,0.368566],[-0.449072,-0.047842],[-0.22616,-0.395366],[0.13452,0.43745],[0.259132,0.381722],[0.426316,0.180096],[-0.114704,-0.451094],[-0.427786,0.188226],[0.370588,-0.29204],[0.280418,-0.38221],[0.482044,0.034198],[0.447602,-0.20187],[0.009908,0.493178],[-0.358902,-0.339638],[-0.191718,0.458736],[-0.49667,0.098056],[0.391874,0.325994],[0.211534,-0.47238],[-0.483514,-0.28391],[-0.462228,0.334124],[-0.393344,0.424294],[0.336146,0.471892],[-0.31633,-0.485536],[0.41316,-0.437938],[-0.440942,-0.429808],[0.460758,0.416164]]]],\"size\":{\"depth\":1,\"height\":1,\"width\":64}}");

/***/ }),

/***/ "./data/masquerade.json":
/*!******************************!*\
  !*** ./data/masquerade.json ***!
  \******************************/
/*! exports provided: 0, 1, 2, 3, 4, 5, 6, 7, 8, default */
/***/ (function(module) {

module.exports = JSON.parse("[{\"identifier\":\"chrome-63\",\"backend\":\"webgl2\",\"extensions_strive\":[\"EXT_color_buffer_float\",\"EXT_disjoint_timer_query_webgl2\",\"EXT_texture_filter_anisotropic\",\"OES_texture_float_linear\",\"WEBGL_compressed_texture_s3tc\",\"WEBGL_compressed_texture_s3tc_srgb\",\"WEBGL_debug_renderer_info\",\"WEBGL_debug_shaders\",\"WEBGL_lose_context\"]},{\"identifier\":\"edge-41\",\"backend\":\"webgl1\",\"extensions_strive\":[\"ANGLE_instanced_arrays\",\"EXT_frag_depth\",\"EXT_texture_filter_anisotropic\",\"OES_texture_float\",\"OES_texture_float_linear\",\"OES_standard_derivatives\",\"OES_element_index_uint\",\"OES_texture_half_float\",\"OES_texture_half_float_linear\",\"WEBGL_compressed_texture_s3tc\",\"WEBGL_debug_renderer_info\",\"WEBGL_depth_texture\"]},{\"identifier\":\"ie-11\",\"backend\":\"webgl1\",\"extensions_strive\":[\"ANGLE_instanced_arrays\",\"EXT_texture_filter_anisotropic\",\"OES_texture_float\",\"OES_texture_float_linear\",\"OES_standard_derivatives\",\"OES_element_index_uint\",\"WEBGL_compressed_texture_s3tc\",\"WEBGL_debug_renderer_info\"]},{\"identifier\":\"firefox-57\",\"backend\":\"webgl2\",\"extensions_strive\":[\"EXT_color_buffer_float\",\"EXT_texture_filter_anisotropic\",\"EXT_disjoint_timer_query\",\"OES_texture_float_linear\",\"WEBGL_compressed_texture_s3tc\",\"WEBGL_debug_renderer_info\",\"WEBGL_debug_shaders\",\"WEBGL_lose_context\",\"MOZ_WEBGL_lose_context\",\"MOZ_WEBGL_compressed_texture_s3tc\"]},{\"identifier\":\"safari-10.1\",\"backend\":\"webgl1\",\"extensions_strive\":[\"compressed_texture_pvrtc\",\"compressed_texture_s3tc\",\"debug_renderer_info\",\"disjoint_timer_query\",\"draw_buffers\",\"element_index_uint\",\"frag_depth\",\"instanced_arrays\",\"lose_context\",\"sRGB\",\"shader_texture_lod\",\"standard_derivatives\",\"texture_filter_anisotropic\",\"texture_float\",\"texture_float_linear\",\"texture_half_float\",\"texture_half_float_linear\",\"vertex_array_object\"],\"functions_undefine\":[\"readBuffer\"]},{\"identifier\":\"no-WEBGL_draw_buffers\",\"backend\":\"webgl1\",\"extensions_conceal\":[\"WEBGL_draw_buffers\"]},{\"identifier\":\"no-readBuffer\",\"extensions_hash\":\"100000\",\"functions_undefine\":[\"readBuffer\"]},{\"identifier\":\"webgl1\",\"extensions_hash\":\"1+++++\"},{\"identifier\":\"webgl2\",\"extensions_hash\":\"2+++++\"}]");

/***/ }),

/***/ "./debug/index.ts":
/*!************************!*\
  !*** ./debug/index.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var debug_TestNavigation = __webpack_require__(/*! ./testnavigation */ "./debug/testnavigation.ts");
var debug_TestRenderer = __webpack_require__(/*! ./testrenderer */ "./debug/testrenderer.ts");
var debug;
(function (debug) {
    debug.TestRenderer = debug_TestRenderer.TestRenderer;
    debug.TestNavigation = debug_TestNavigation.TestNavigation;
})(debug = exports.debug || (exports.debug = {}));


/***/ }),

/***/ "./debug/testnavigation.ts":
/*!*********************************!*\
  !*** ./debug/testnavigation.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var eventhandler_1 = __webpack_require__(/*! ../eventhandler */ "./eventhandler.ts");
var TestNavigation = (function () {
    function TestNavigation(invalidate, mouseEventProvider) {
        var _this = this;
        this._altered = false;
        this._eventHandler = new eventhandler_1.EventHandler(invalidate, { mouseEventProvider: mouseEventProvider,
            touchEventProvider: undefined,
            eyeGazeEventProvider: undefined });
        this._eventHandler.pushMouseEnterHandler(function (latests, previous) {
            return _this.onMouseEnter(latests, previous);
        });
        this._eventHandler.pushMouseLeaveHandler(function (latests, previous) {
            return _this.onMouseLeave(latests, previous);
        });
    }
    TestNavigation.prototype.onMouseEnter = function (latests, previous) {
        this._altered = false;
    };
    TestNavigation.prototype.onMouseLeave = function (latests, previous) {
        this._altered = true;
    };
    TestNavigation.prototype.update = function () {
        this._eventHandler.update();
    };
    TestNavigation.prototype.reset = function () {
        this._altered = false;
    };
    Object.defineProperty(TestNavigation.prototype, "altered", {
        get: function () {
            return this._altered;
        },
        enumerable: true,
        configurable: true
    });
    return TestNavigation;
}());
exports.TestNavigation = TestNavigation;


/***/ }),

/***/ "./debug/testrenderer.frag":
/*!*********************************!*\
  !*** ./debug/testrenderer.frag ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nprecision lowp float;\n\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else \n    #define varying in\n#endif\n\n\n\n#if __VERSION__ == 100\n    #define fragColor gl_FragColor\n    #extension GL_OES_standard_derivatives : enable\n#else \n    layout(location = 0) out vec4 fragColor;\n#endif\n\nuniform int u_frameNumber;\n\nvarying vec2 v_uv;\n\n\nvoid main(void)\n{\n    vec3 color = vec3(28.0 / 255.0, 117.0 / 255.0, 188.0 / 255.0);\n    color += (vec3(0.0, v_uv) - 0.5) * 0.125;\n\n    vec2 awidth = fwidth(v_uv) * (sin(float(u_frameNumber) * 0.1) * 7.0 + 8.0);\n    vec2 cstep = abs(step(awidth, v_uv) - step(awidth, 1.0 - v_uv));\n    if(!any(bvec2(cstep))) {\n        discard;\n    }\n    fragColor = vec4(color, 1.0); \n}\n"

/***/ }),

/***/ "./debug/testrenderer.ts":
/*!*******************************!*\
  !*** ./debug/testrenderer.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var auxiliaries_1 = __webpack_require__(/*! ../auxiliaries */ "./auxiliaries.ts");
var accumulatepass_1 = __webpack_require__(/*! ../accumulatepass */ "./accumulatepass.ts");
var antialiasingkernel_1 = __webpack_require__(/*! ../antialiasingkernel */ "./antialiasingkernel.ts");
var blitpass_1 = __webpack_require__(/*! ../blitpass */ "./blitpass.ts");
var defaultframebuffer_1 = __webpack_require__(/*! ../defaultframebuffer */ "./defaultframebuffer.ts");
var framebuffer_1 = __webpack_require__(/*! ../framebuffer */ "./framebuffer.ts");
var ndcfillingtriangle_1 = __webpack_require__(/*! ../ndcfillingtriangle */ "./ndcfillingtriangle.ts");
var program_1 = __webpack_require__(/*! ../program */ "./program.ts");
var renderbuffer_1 = __webpack_require__(/*! ../renderbuffer */ "./renderbuffer.ts");
var renderer_1 = __webpack_require__(/*! ../renderer */ "./renderer.ts");
var shader_1 = __webpack_require__(/*! ../shader */ "./shader.ts");
var texture2d_1 = __webpack_require__(/*! ../texture2d */ "./texture2d.ts");
var testnavigation_1 = __webpack_require__(/*! ./testnavigation */ "./debug/testnavigation.ts");
var debug;
(function (debug) {
    var TestRenderer = (function (_super) {
        __extends(TestRenderer, _super);
        function TestRenderer() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._extensions = false;
            return _this;
        }
        TestRenderer.prototype.onInitialize = function (context, callback, eventProvider) {
            var _this = this;
            var gl = this._context.gl;
            var gl2facade = this._context.gl2facade;
            if (this._extensions === false && this._context.isWebGL1) {
                auxiliaries_1.assert(this._context.supportsStandardDerivatives, "expected OES_standard_derivatives support");
                this._context.standardDerivatives;
                this._extensions = true;
            }
            var vert = new shader_1.Shader(this._context, gl.VERTEX_SHADER, 'testrenderer.vert');
            vert.initialize(__webpack_require__(/*! ./testrenderer.vert */ "./debug/testrenderer.vert"));
            var frag = new shader_1.Shader(this._context, gl.FRAGMENT_SHADER, 'testrenderer.frag');
            frag.initialize(__webpack_require__(/*! ./testrenderer.frag */ "./debug/testrenderer.frag"));
            this._program = new program_1.Program(this._context);
            this._program.initialize([vert, frag]);
            this._uNdcOffset = this._program.uniform('u_ndcOffset');
            this._uFrameNumber = this._program.uniform('u_frameNumber');
            this._ndcTriangle = new ndcfillingtriangle_1.NdcFillingTriangle(this._context);
            var aVertex = this._program.attribute('a_vertex', 0);
            this._ndcTriangle.initialize(aVertex);
            this._ndcOffsetKernel = new antialiasingkernel_1.AntiAliasingKernel(this._multiFrameNumber);
            this._defaultFBO = new defaultframebuffer_1.DefaultFramebuffer(this._context, 'DefaultFBO');
            this._defaultFBO.initialize();
            this._colorRenderTexture = new texture2d_1.Texture2D(this._context, 'ColorRenderTexture');
            this._depthRenderbuffer = new renderbuffer_1.Renderbuffer(this._context, 'DepthRenderbuffer');
            this._intermediateFBO = new framebuffer_1.Framebuffer(this._context, 'IntermediateFBO');
            this._accumulate = new accumulatepass_1.AccumulatePass(this._context);
            this._accumulate.initialize(this._ndcTriangle);
            this._accumulate.precision = this._framePrecision;
            this._accumulate.texture = this._colorRenderTexture;
            this._blit = new blitpass_1.BlitPass(this._context);
            this._blit.initialize(this._ndcTriangle);
            this._blit.readBuffer = gl2facade.COLOR_ATTACHMENT0;
            this._blit.drawBuffer = gl.BACK;
            this._blit.target = this._defaultFBO;
            this._testNavigation = new testnavigation_1.TestNavigation(function () { return _this.invalidate(); }, eventProvider.mouseEventProvider);
            return true;
        };
        TestRenderer.prototype.onUninitialize = function () {
            _super.prototype.uninitialize.call(this);
            this._uNdcOffset = -1;
            this._uFrameNumber = -1;
            this._program.uninitialize();
            this._ndcTriangle.uninitialize();
            this._intermediateFBO.uninitialize();
            this._defaultFBO.uninitialize();
            this._colorRenderTexture.uninitialize();
            this._depthRenderbuffer.uninitialize();
            this._blit.uninitialize();
            this._accumulate.uninitialize();
        };
        TestRenderer.prototype.onUpdate = function () {
            this._testNavigation.update();
            var redraw = this._testNavigation.altered;
            this._testNavigation.reset();
            if (!redraw && !this._altered.any) {
                return false;
            }
            return redraw;
        };
        TestRenderer.prototype.onPrepare = function () {
            var gl = this._context.gl;
            var gl2facade = this._context.gl2facade;
            if (!this._intermediateFBO.initialized) {
                this._colorRenderTexture.initialize(this._frameSize[0], this._frameSize[1], this._context.isWebGL2 ? gl.RGBA8 : gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE);
                this._depthRenderbuffer.initialize(this._frameSize[0], this._frameSize[1], gl.DEPTH_COMPONENT16);
                this._intermediateFBO.initialize([[gl2facade.COLOR_ATTACHMENT0, this._colorRenderTexture],
                    [gl.DEPTH_ATTACHMENT, this._depthRenderbuffer]]);
            }
            else if (this._altered.frameSize) {
                this._intermediateFBO.resize(this._frameSize[0], this._frameSize[1]);
            }
            if (this._altered.multiFrameNumber) {
                this._ndcOffsetKernel.width = this._multiFrameNumber;
            }
            if (this._altered.framePrecision) {
                this._accumulate.precision = this._framePrecision;
            }
            if (this._altered.clearColor) {
                this._intermediateFBO.clearColor(this._clearColor);
            }
            this._accumulate.update();
            this._altered.reset();
        };
        TestRenderer.prototype.onFrame = function (frameNumber) {
            var gl = this._context.gl;
            gl.viewport(0, 0, this._frameSize[0], this._frameSize[1]);
            this._program.bind();
            var ndcOffset = this._ndcOffsetKernel.get(frameNumber);
            ndcOffset[0] = 2.0 * ndcOffset[0] / this._frameSize[0];
            ndcOffset[1] = 2.0 * ndcOffset[1] / this._frameSize[1];
            gl.uniform2fv(this._uNdcOffset, ndcOffset);
            gl.uniform1i(this._uFrameNumber, frameNumber);
            this._intermediateFBO.clear(gl.COLOR_BUFFER_BIT, true, false);
            this._ndcTriangle.bind();
            this._ndcTriangle.draw();
            this._intermediateFBO.unbind();
            this._accumulate.frame(frameNumber);
        };
        TestRenderer.prototype.onSwap = function () {
            this._blit.framebuffer = this._accumulate.framebuffer ?
                this._accumulate.framebuffer : this._blit.framebuffer = this._intermediateFBO;
            this._blit.frame();
        };
        return TestRenderer;
    }(renderer_1.Renderer));
    debug.TestRenderer = TestRenderer;
})(debug || (debug = {}));
module.exports = debug;


/***/ }),

/***/ "./debug/testrenderer.vert":
/*!*********************************!*\
  !*** ./debug/testrenderer.vert ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nprecision lowp float;\n\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else\n    #define varying out\n#endif\n\n\nvoid ndcOffset(inout vec4 vertex, in vec2 offset) {\n    vertex.xy = offset * vec2(vertex.w) + vertex.xy;\n}\n\n\n\n#if __VERSION__ == 100\n    attribute vec2 a_vertex;\n#else \n    layout(location = 0) in vec2 a_vertex;\n#endif\n\nuniform vec2 u_ndcOffset;\n\nvarying vec2 v_uv;\n\n\nvoid main(void)\n{\n    v_uv = a_vertex.xy * 0.5 + 0.5;\n\n    vec4 vertex = vec4(a_vertex, 0.0, 1.0);\n    ndcOffset(vertex, u_ndcOffset);\n\n    gl_Position = vertex;\n}\n"

/***/ }),

/***/ "./debugpass.ts":
/*!**********************!*\
  !*** ./debugpass.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var program_1 = __webpack_require__(/*! ./program */ "./program.ts");
var shader_1 = __webpack_require__(/*! ./shader */ "./shader.ts");
var blitpass_1 = __webpack_require__(/*! ./blitpass */ "./blitpass.ts");
var DebugPass = (function (_super) {
    __extends(DebugPass, _super);
    function DebugPass() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._debug = DebugPass.Mode.Depth;
        _this._near = 0.0;
        _this._far = 0.0;
        return _this;
    }
    DebugPass.prototype.createProgram = function () {
        auxiliaries_1.assert(this._program === undefined, "expected blit program to be undefined before its creation");
        var gl = this._context.gl;
        var vert = new shader_1.Shader(this._context, gl.VERTEX_SHADER, 'blit.vert (debug)');
        vert.initialize(__webpack_require__(/*! ./shaders/blit.vert */ "./shaders/blit.vert"));
        var frag = new shader_1.Shader(this._context, gl.FRAGMENT_SHADER, 'blit_debug.frag (debug)');
        frag.initialize(__webpack_require__(/*! ./shaders/blit_debug.frag */ "./shaders/blit_debug.frag"));
        this._program = new program_1.Program(this._context, 'DebugProgram');
        this._program.initialize([vert, frag]);
        if (!this._ndcTriangle.initialized) {
            this._ndcTriangle.initialize();
        }
        this._program.attribute('a_vertex', this._ndcTriangle.vertexLocation);
        this._program.link();
        this._uSrcBounds = this._program.uniform('u_srcBounds');
        this._uDstBounds = this._program.uniform('u_dstBounds');
        this._uNearest = this._program.uniform('u_nearest');
        this._uDebugMode = this._program.uniform('u_mode');
        this._uLinearize = this._program.uniform('u_linearize');
        this._program.bind();
        gl.uniform1i(this._program.uniform('u_source'), 0);
        gl.uniform1i(this._uDebugMode, this._debug);
        this._program.unbind();
        return this._program.valid;
    };
    DebugPass.prototype.initialize = function (ndcTriangle) {
        var result = _super.prototype.initialize.call(this, ndcTriangle);
        this.enforceProgramBlit = true;
        return result && this.createProgram();
    };
    DebugPass.prototype.uninitialize = function () {
        _super.prototype.uninitialize.call(this);
        this._uDebugMode = undefined;
        this._uLinearize = undefined;
    };
    Object.defineProperty(DebugPass.prototype, "debug", {
        set: function (mode) {
            this.assertInitialized();
            if (this._debug === mode) {
                return;
            }
            this._debug = mode;
            if (this._program === undefined || !this._program.valid) {
                return;
            }
            this._program.bind();
            this._context.gl.uniform1i(this._uDebugMode, this._debug);
            this._program.unbind();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DebugPass.prototype, "near", {
        set: function (near) {
            this._near = near ? near : 0.0;
            if (this._program === undefined || !this._program.valid) {
                return;
            }
            this._program.bind();
            this._context.gl.uniform2f(this._uLinearize, this._near, this._far);
            this._program.unbind();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DebugPass.prototype, "far", {
        set: function (far) {
            this._far = far ? far : 0.0;
            if (this._program === undefined || !this._program.valid) {
                return;
            }
            this._program.bind();
            this._context.gl.uniform2f(this._uLinearize, this._near, this._far);
            this._program.unbind();
        },
        enumerable: true,
        configurable: true
    });
    return DebugPass;
}(blitpass_1.BlitPass));
exports.DebugPass = DebugPass;
(function (DebugPass) {
    var Mode;
    (function (Mode) {
        Mode[Mode["Depth"] = 0] = "Depth";
        Mode[Mode["DepthLinear"] = 1] = "DepthLinear";
        Mode[Mode["DepthPacked"] = 2] = "DepthPacked";
        Mode[Mode["DepthLinearPacked"] = 3] = "DepthLinearPacked";
    })(Mode = DebugPass.Mode || (DebugPass.Mode = {}));
})(DebugPass = exports.DebugPass || (exports.DebugPass = {}));
exports.DebugPass = DebugPass;


/***/ }),

/***/ "./defaultframebuffer.ts":
/*!*******************************!*\
  !*** ./defaultframebuffer.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var framebuffer_1 = __webpack_require__(/*! ./framebuffer */ "./framebuffer.ts");
var initializable_1 = __webpack_require__(/*! ./initializable */ "./initializable.ts");
var DefaultFramebuffer = (function (_super) {
    __extends(DefaultFramebuffer, _super);
    function DefaultFramebuffer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DefaultFramebuffer.prototype.create = function () {
        this._object = framebuffer_1.Framebuffer.DEFAULT_FRAMEBUFFER;
        this._valid = true;
        this._clearColors = new Array(1);
        this._clearDepth = 1.0;
        this._clearStencil = 0;
        this.clear = this.es2Clear;
        return this._object;
    };
    DefaultFramebuffer.prototype.delete = function () {
        this._object = undefined;
        this._valid = false;
    };
    DefaultFramebuffer.prototype.hasAttachment = function (attachment) {
        return false;
    };
    DefaultFramebuffer.prototype.bind = function (target) {
        if (target === void 0) { target = this.context.gl.FRAMEBUFFER; }
        this.context.gl.bindFramebuffer(target, this._object);
    };
    DefaultFramebuffer.prototype.clearColor = function (color) {
        _super.prototype.clearColor.call(this, color);
    };
    DefaultFramebuffer.prototype.resize = function () {
        auxiliaries_1.assert(false, "the default framebuffer cannot be resized directly");
    };
    Object.defineProperty(DefaultFramebuffer.prototype, "width", {
        get: function () {
            return this.context.gl.canvas.width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultFramebuffer.prototype, "height", {
        get: function () {
            return this.context.gl.canvas.height;
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], DefaultFramebuffer.prototype, "bind", null);
    return DefaultFramebuffer;
}(framebuffer_1.Framebuffer));
exports.DefaultFramebuffer = DefaultFramebuffer;


/***/ }),

/***/ "./eventhandler.ts":
/*!*************************!*\
  !*** ./eventhandler.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "../node_modules/gl-matrix/esm/index.js");
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var eyegazeeventprovider_1 = __webpack_require__(/*! ./eyegazeeventprovider */ "./eyegazeeventprovider.ts");
var mouseeventprovider_1 = __webpack_require__(/*! ./mouseeventprovider */ "./mouseeventprovider.ts");
var toucheventprovider_1 = __webpack_require__(/*! ./toucheventprovider */ "./toucheventprovider.ts");
var EventHandler = (function () {
    function EventHandler(invalidate, eventProvider) {
        this._subscriptions = new Array();
        this._latestMouseEventsByType = new Map();
        this._previousMouseEventsByType = new Map();
        this._mouseEventHandlerByType = new Map();
        this._latestTouchEventsByType = new Map();
        this._previousTouchEventsByType = new Map();
        this._touchEventHandlerByType = new Map();
        this._latestEyeGazeEventsByType = new Map();
        this._previousEyeGazeEventsByType = new Map();
        this._eyeGazeEventHandlerByType = new Map();
        this._invalidate = invalidate;
        this._mouseEventProvider = eventProvider.mouseEventProvider;
        this._touchEventProvider = eventProvider.touchEventProvider;
        this._eyeGazeEventProvider = eventProvider.eyeGazeEventProvider;
    }
    EventHandler.prototype.invalidate = function (force) {
        if (force === void 0) { force = false; }
        if (this._invalidate) {
            this._invalidate(force);
        }
    };
    EventHandler.prototype.pushMouseEventHandler = function (type, handler) {
        var _this = this;
        if (this._mouseEventHandlerByType.has(type)) {
            this._mouseEventHandlerByType.get(type).push(handler);
            return;
        }
        this._mouseEventHandlerByType.set(type, new Array());
        this._previousMouseEventsByType.set(type, new Array());
        var latest = new Array();
        this._latestMouseEventsByType.set(type, latest);
        auxiliaries_1.assert(this._mouseEventProvider !== undefined, "expected valid mouse event provider");
        var observable = this._mouseEventProvider.observable(type);
        switch (type) {
            case mouseeventprovider_1.MouseEventProvider.Type.Wheel:
                this._subscriptions.push(observable.subscribe(function (event) { latest.push(event); _this.invalidate(); }));
                break;
            default:
                this._subscriptions.push(observable.subscribe(function (event) { latest.push(event); _this.invalidate(); }));
                break;
        }
        this._mouseEventHandlerByType.get(type).push(handler);
    };
    EventHandler.prototype.invokeMouseEventHandler = function (type) {
        var handlers = this._mouseEventHandlerByType.get(type);
        if (handlers === undefined || handlers.length === 0) {
            return;
        }
        var latest = this._latestMouseEventsByType.get(type);
        if (latest.length === 0) {
            return;
        }
        var previous = this._previousMouseEventsByType.get(type);
        handlers.forEach(function (handler) { return handler(latest, previous); });
        Object.assign(previous, latest);
        latest.length = 0;
    };
    EventHandler.prototype.pushTouchEventHandler = function (type, handler) {
        var _this = this;
        if (this._touchEventHandlerByType.has(type)) {
            this._touchEventHandlerByType.get(type).push(handler);
            return;
        }
        this._touchEventHandlerByType.set(type, new Array());
        this._previousTouchEventsByType.set(type, new Array());
        var latest = new Array();
        this._latestTouchEventsByType.set(type, latest);
        auxiliaries_1.assert(this._touchEventProvider !== undefined, "expected valid touch event provider");
        var observable = this._touchEventProvider.observable(type);
        this._subscriptions.push(observable.subscribe(function (event) { latest.push(event); _this.invalidate(); }));
        this._touchEventHandlerByType.get(type).push(handler);
    };
    EventHandler.prototype.invokeTouchEventHandler = function (type) {
        var handlers = this._touchEventHandlerByType.get(type);
        if (handlers === undefined || handlers.length === 0) {
            return;
        }
        var latest = this._latestTouchEventsByType.get(type);
        if (latest.length === 0) {
            return;
        }
        var previous = this._previousTouchEventsByType.get(type);
        handlers.forEach(function (handler) { return handler(latest, previous); });
        Object.assign(previous, latest);
        latest.length = 0;
    };
    EventHandler.prototype.pushEyeGazeEventHandler = function (type, handler) {
        var _this = this;
        if (this._eyeGazeEventHandlerByType.has(type)) {
            this._eyeGazeEventHandlerByType.get(type).push(handler);
            return;
        }
        this._eyeGazeEventHandlerByType.set(type, new Array());
        this._previousEyeGazeEventsByType.set(type, new Array());
        var latest = new Array();
        this._latestEyeGazeEventsByType.set(type, latest);
        auxiliaries_1.assert(this._eyeGazeEventProvider !== undefined, "expected valid eye gaze event provider");
        var observable = this._eyeGazeEventProvider.observable(type);
        this._subscriptions.push(observable.subscribe(function (event) { latest.push(event); _this.invalidate(); }));
        this._eyeGazeEventHandlerByType.get(type).push(handler);
    };
    EventHandler.prototype.invokeEyeGazeEventHandler = function (type) {
        var handlers = this._eyeGazeEventHandlerByType.get(type);
        if (handlers === undefined || handlers.length === 0) {
            return;
        }
        var latest = this._latestEyeGazeEventsByType.get(type);
        if (latest.length === 0) {
            return;
        }
        var previous = this._previousEyeGazeEventsByType.get(type);
        handlers.forEach(function (handler) { return handler(latest, previous); });
        Object.assign(previous, latest);
        latest.length = 0;
    };
    EventHandler.prototype.dispose = function () {
        this._latestMouseEventsByType.forEach(function (value) { return value.length = 0; });
        this._previousMouseEventsByType.forEach(function (value) { return value.length = 0; });
        this._latestTouchEventsByType.forEach(function (value) { return value.length = 0; });
        this._previousTouchEventsByType.forEach(function (value) { return value.length = 0; });
        this._previousEyeGazeEventsByType.forEach(function (value) { return value.length = 0; });
        this._latestEyeGazeEventsByType.forEach(function (value) { return value.length = 0; });
        for (var _i = 0, _a = this._subscriptions; _i < _a.length; _i++) {
            var subscription = _a[_i];
            subscription.unsubscribe();
        }
    };
    EventHandler.prototype.update = function () {
        this.invokeMouseEventHandler(mouseeventprovider_1.MouseEventProvider.Type.Click);
        this.invokeMouseEventHandler(mouseeventprovider_1.MouseEventProvider.Type.Enter);
        this.invokeMouseEventHandler(mouseeventprovider_1.MouseEventProvider.Type.Leave);
        this.invokeMouseEventHandler(mouseeventprovider_1.MouseEventProvider.Type.Down);
        this.invokeMouseEventHandler(mouseeventprovider_1.MouseEventProvider.Type.Up);
        this.invokeMouseEventHandler(mouseeventprovider_1.MouseEventProvider.Type.Move);
        this.invokeMouseEventHandler(mouseeventprovider_1.MouseEventProvider.Type.Wheel);
        this.invokeTouchEventHandler(toucheventprovider_1.TouchEventProvider.Type.Start);
        this.invokeTouchEventHandler(toucheventprovider_1.TouchEventProvider.Type.End);
        this.invokeTouchEventHandler(toucheventprovider_1.TouchEventProvider.Type.Move);
        this.invokeTouchEventHandler(toucheventprovider_1.TouchEventProvider.Type.Cancel);
        this.invokeEyeGazeEventHandler(eyegazeeventprovider_1.EyeGazeEventProvider.Type.EyeGazeData);
        this.invokeEyeGazeEventHandler(eyegazeeventprovider_1.EyeGazeEventProvider.Type.NewServerMessage);
        this.invokeEyeGazeEventHandler(eyegazeeventprovider_1.EyeGazeEventProvider.Type.ConnectionStatus);
        this.invokeEyeGazeEventHandler(eyegazeeventprovider_1.EyeGazeEventProvider.Type.BinaryMessageParsingError);
    };
    EventHandler.prototype.offsets = function (event, normalize) {
        if (normalize === void 0) { normalize = true; }
        var offsets = new Array();
        var chromeWorkaround = false;
        if (event instanceof MouseEvent) {
            var e = event;
            chromeWorkaround = (e.offsetX !== 0 && e.offsetY !== 0);
            offsets.push(chromeWorkaround ?
                gl_matrix_1.vec2.fromValues(e.offsetX, e.offsetY) :
                gl_matrix_1.vec2.fromValues(e.clientX, e.clientY));
        }
        else if (event instanceof WheelEvent) {
            var e = event;
            chromeWorkaround = (e.offsetX !== 0 && e.offsetY !== 0);
            offsets.push(chromeWorkaround ?
                gl_matrix_1.vec2.fromValues(e.offsetX, e.offsetY) :
                gl_matrix_1.vec2.fromValues(e.clientX, e.clientY));
        }
        else if (event instanceof TouchEvent) {
            var e = event;
            for (var index = 0; index < e.touches.length; ++index) {
                var touch = e.touches.item(index);
                offsets.push(gl_matrix_1.vec2.fromValues(touch.clientX, touch.clientY));
            }
        }
        if (chromeWorkaround) {
            if (normalize) {
                for (var _i = 0, offsets_1 = offsets; _i < offsets_1.length; _i++) {
                    var offset = offsets_1[_i];
                    gl_matrix_1.vec2.scale(offset, offset, window.devicePixelRatio);
                }
            }
            return offsets;
        }
        var target = event.target || event.currentTarget || event.srcElement;
        var rect = target.getBoundingClientRect();
        for (var _a = 0, offsets_2 = offsets; _a < offsets_2.length; _a++) {
            var offset = offsets_2[_a];
            offset[0] = Math.floor(offset[0] - rect.left);
            offset[1] = Math.floor(offset[1] - rect.top);
            if (normalize) {
                gl_matrix_1.vec2.scale(offset, offset, window.devicePixelRatio);
            }
        }
        return offsets;
    };
    EventHandler.prototype.pushClickHandler = function (handler) {
        this.pushMouseEventHandler(mouseeventprovider_1.MouseEventProvider.Type.Click, handler);
    };
    EventHandler.prototype.pushMouseEnterHandler = function (handler) {
        this.pushMouseEventHandler(mouseeventprovider_1.MouseEventProvider.Type.Enter, handler);
    };
    EventHandler.prototype.pushMouseLeaveHandler = function (handler) {
        this.pushMouseEventHandler(mouseeventprovider_1.MouseEventProvider.Type.Leave, handler);
    };
    EventHandler.prototype.pushMouseDownHandler = function (handler) {
        this.pushMouseEventHandler(mouseeventprovider_1.MouseEventProvider.Type.Down, handler);
    };
    EventHandler.prototype.pushMouseUpHandler = function (handler) {
        this.pushMouseEventHandler(mouseeventprovider_1.MouseEventProvider.Type.Up, handler);
    };
    EventHandler.prototype.pushMouseMoveHandler = function (handler) {
        this.pushMouseEventHandler(mouseeventprovider_1.MouseEventProvider.Type.Move, handler);
    };
    EventHandler.prototype.pushMouseWheelHandler = function (handler) {
        this.pushMouseEventHandler(mouseeventprovider_1.MouseEventProvider.Type.Wheel, handler);
    };
    EventHandler.prototype.pushTouchStartHandler = function (handler) {
        this.pushTouchEventHandler(toucheventprovider_1.TouchEventProvider.Type.Start, handler);
    };
    EventHandler.prototype.pushTouchEndHandler = function (handler) {
        this.pushTouchEventHandler(toucheventprovider_1.TouchEventProvider.Type.End, handler);
    };
    EventHandler.prototype.pushTouchMoveHandler = function (handler) {
        this.pushTouchEventHandler(toucheventprovider_1.TouchEventProvider.Type.Move, handler);
    };
    EventHandler.prototype.pushTouchCancelHandler = function (handler) {
        this.pushTouchEventHandler(toucheventprovider_1.TouchEventProvider.Type.Cancel, handler);
    };
    EventHandler.prototype.pushEyeGazeDataHandler = function (handler) {
        this.pushEyeGazeEventHandler(eyegazeeventprovider_1.EyeGazeEventProvider.Type.EyeGazeData, handler);
    };
    EventHandler.prototype.pushEyeGazeServerMessageHandler = function (handler) {
        this.pushEyeGazeEventHandler(eyegazeeventprovider_1.EyeGazeEventProvider.Type.NewServerMessage, handler);
    };
    EventHandler.prototype.pushEyeGazeConnectionStatusHandler = function (handler) {
        this.pushEyeGazeEventHandler(eyegazeeventprovider_1.EyeGazeEventProvider.Type.ConnectionStatus, handler);
    };
    EventHandler.prototype.pushEyeGazeBinaryMessageParsingErrorHandler = function (handler) {
        this.pushEyeGazeEventHandler(eyegazeeventprovider_1.EyeGazeEventProvider.Type.BinaryMessageParsingError, handler);
    };
    EventHandler.prototype.requestPointerLock = function () {
        if (this._mouseEventProvider) {
            this._mouseEventProvider.pointerLock = true;
        }
    };
    EventHandler.prototype.exitPointerLock = function () {
        if (this._mouseEventProvider) {
            this._mouseEventProvider.pointerLock = false;
        }
    };
    return EventHandler;
}());
exports.EventHandler = EventHandler;


/***/ }),

/***/ "./extensions.ts":
/*!***********************!*\
  !*** ./extensions.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var extensions;
(function (extensions) {
    extensions.WEBGL1_EXTENSIONS = [
        'ANGLE_instanced_arrays',
        'EXT_blend_minmax',
        'EXT_color_buffer_half_float',
        'EXT_disjoint_timer_query',
        'EXT_frag_depth',
        'EXT_sRGB',
        'EXT_shader_texture_lod',
        'EXT_texture_filter_anisotropic',
        'OES_element_index_uint',
        'OES_standard_derivatives',
        'OES_texture_float',
        'OES_texture_float_linear',
        'OES_texture_half_float',
        'OES_texture_half_float_linear',
        'OES_vertex_array_object',
        'WEBGL_color_buffer_float',
        'WEBGL_compressed_texture_astc',
        'WEBGL_compressed_texture_atc',
        'WEBGL_compressed_texture_etc',
        'WEBGL_compressed_texture_etc1',
        'WEBGL_compressed_texture_pvrtc',
        'WEBGL_compressed_texture_s3tc',
        'WEBGL_compressed_texture_s3tc_srgb',
        'WEBGL_debug_renderer_info',
        'WEBGL_debug_shaders',
        'WEBGL_depth_texture',
        'WEBGL_draw_buffers',
        'WEBGL_lose_context',
    ];
    extensions.WEBGL2_EXTENSIONS = [
        'EXT_color_buffer_float',
        'EXT_disjoint_timer_query_webgl2',
        'EXT_texture_filter_anisotropic',
        'OES_texture_float_linear',
        'OES_texture_half_float_linear',
        'WEBGL_compressed_texture_astc',
        'WEBGL_compressed_texture_atc',
        'WEBGL_compressed_texture_etc',
        'WEBGL_compressed_texture_etc1',
        'WEBGL_compressed_texture_pvrtc',
        'WEBGL_compressed_texture_s3tc',
        'WEBGL_compressed_texture_s3tc_srgb',
        'WEBGL_debug_renderer_info',
        'WEBGL_debug_shaders',
        'WEBGL_lose_context',
    ];
    extensions.WEBGL2_DEFAULT_EXTENSIONS = [
        'ANGLE_instanced_arrays',
        'EXT_blend_minmax',
        'EXT_frag_depth',
        'EXT_sRGB',
        'EXT_shader_texture_lod',
        'OES_element_index_uint',
        'OES_standard_derivatives',
        'OES_texture_float',
        'OES_texture_half_float',
        'OES_vertex_array_object',
        'WEBGL_depth_texture',
        'WEBGL_draw_buffers',
    ];
})(extensions || (extensions = {}));
module.exports = extensions;


/***/ }),

/***/ "./extensionshash.ts":
/*!***************************!*\
  !*** ./extensionshash.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var extensions_1 = __webpack_require__(/*! ./extensions */ "./extensions.ts");
var ExtensionsHash = (function () {
    function ExtensionsHash() {
    }
    ExtensionsHash.encode64 = function (bitfield) {
        auxiliaries_1.assert(bitfield >= 0 && bitfield <= 63, "expected bitfield in range [ 0b000000, 0b111111 ], given " + bitfield);
        return ExtensionsHash.BASE64_ALPHABET[bitfield];
    };
    ExtensionsHash.decode64 = function (base64) {
        auxiliaries_1.assert(base64.length === 1, "expected single base64 character, given '" + base64 + "'");
        var bitfield = ExtensionsHash.BASE64_ALPHABET.indexOf(base64);
        auxiliaries_1.assert(bitfield > -1, "unknown base64 character, given '" + base64 + "'");
        return bitfield;
    };
    ExtensionsHash.encode = function (backend, supported) {
        var version = ExtensionsHash.LATEST_VERSION;
        var extensions = ExtensionsHash.EXTENSIONS_BY_VERSION.get(version);
        var backendIndex = ExtensionsHash.WEBGL_BACKENDS.indexOf(backend);
        auxiliaries_1.assert(backendIndex > -1, "expected valid backend " + ExtensionsHash.WEBGL_BACKENDS + ", given " + backend + " ");
        var hash = ExtensionsHash.encode64((version << 3) | (backendIndex + 1));
        if (supported.length === 0) {
            return hash;
        }
        var support = 0;
        for (var i = 0; i < extensions.length; ++i) {
            support |= (supported.indexOf(extensions[i]) > -1 ? 32 >> (i % 6) : 0);
            if (i % 6 < 5 && i < extensions.length - 1) {
                continue;
            }
            hash += ExtensionsHash.encode64(support);
            support = 0;
        }
        return hash;
    };
    ExtensionsHash.decode = function (hash) {
        var hashHead = ExtensionsHash.decode64(hash[0]);
        var version = hashHead >> 3;
        var backendIndex = (hashHead & 7) - 1;
        auxiliaries_1.assert(backendIndex < ExtensionsHash.WEBGL_BACKENDS.length, "expected valid backend index, given " + backendIndex);
        var backend = ExtensionsHash.WEBGL_BACKENDS[backendIndex];
        auxiliaries_1.assert(ExtensionsHash.EXTENSIONS_BY_VERSION.has(version), "expected valid hash version, given " + version);
        var extensions = ExtensionsHash.EXTENSIONS_BY_VERSION.get(version);
        var expectedHashLength = Math.ceil(extensions.length / 6) + 1;
        auxiliaries_1.assert(hash.length === expectedHashLength, "expected hash of version " + version + " to have a length of " + expectedHashLength + ", given " + hash);
        var strived = new Array();
        for (var i = 1; i < hash.length; ++i) {
            var bitfield = ExtensionsHash.decode64(hash[i]);
            var offset = (i - 1) * 6;
            if (bitfield & 32) {
                strived.push(extensions[offset + 0]);
            }
            if (bitfield & 16) {
                strived.push(extensions[offset + 1]);
            }
            if (bitfield & 8) {
                strived.push(extensions[offset + 2]);
            }
            if (bitfield & 4) {
                strived.push(extensions[offset + 3]);
            }
            if (bitfield & 2) {
                strived.push(extensions[offset + 4]);
            }
            if (bitfield & 1) {
                strived.push(extensions[offset + 5]);
            }
        }
        return [backend, strived];
    };
    ExtensionsHash.complement = function (backend, extensions) {
        var backendIndex = ExtensionsHash.WEBGL_BACKENDS.indexOf(backend);
        auxiliaries_1.assert(backendIndex > -1, "expected valid backend " + ExtensionsHash.WEBGL_BACKENDS + ", given " + backend + " ");
        var webglExtensions = ExtensionsHash.WEBGL_EXTENSIONS_BY_BACKEND.get(backendIndex);
        return webglExtensions.filter(function (ext) { return extensions.indexOf(ext) < 0; });
    };
    ExtensionsHash.WEBGL_BACKENDS = ['webgl1', 'webgl2'];
    ExtensionsHash.WEBGL_EXTENSIONS_BY_BACKEND = new Map([
        [0, extensions_1.WEBGL1_EXTENSIONS],
        [1, extensions_1.WEBGL2_EXTENSIONS],
    ]);
    ExtensionsHash.EXTENSIONS_BY_VERSION = new Map([[
            0, [
                'ANGLE_instanced_arrays',
                'EXT_blend_minmax',
                'EXT_color_buffer_float',
                'EXT_color_buffer_half_float',
                'EXT_disjoint_timer_query',
                'EXT_disjoint_timer_query_webgl2',
                'EXT_frag_depth',
                'EXT_shader_texture_lod',
                'EXT_sRGB',
                'EXT_texture_filter_anisotropic',
                'OES_element_index_uint',
                'OES_standard_derivatives',
                'OES_texture_float',
                'OES_texture_float_linear',
                'OES_texture_half_float',
                'OES_texture_half_float_linear',
                'OES_vertex_array_object',
                'WEBGL_color_buffer_float',
                'WEBGL_compressed_texture_astc',
                'WEBGL_compressed_texture_atc',
                'WEBGL_compressed_texture_etc',
                'WEBGL_compressed_texture_etc1',
                'WEBGL_compressed_texture_pvrtc',
                'WEBGL_compressed_texture_s3tc',
                'WEBGL_compressed_texture_s3tc_srgb',
                'WEBGL_debug_renderer_info',
                'WEBGL_debug_shaders',
                'WEBGL_depth_texture',
                'WEBGL_draw_buffers',
                'WEBGL_lose_context',
            ]
        ],
    ]);
    ExtensionsHash.LATEST_VERSION = 0;
    ExtensionsHash.BASE64_ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-+';
    return ExtensionsHash;
}());
exports.ExtensionsHash = ExtensionsHash;


/***/ }),

/***/ "./eyegazedatastream.ts":
/*!******************************!*\
  !*** ./eyegazedatastream.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var eyegazeevent_1 = __webpack_require__(/*! ./eyegazeevent */ "./eyegazeevent.ts");
var EyeGazeEventTarget = (function (_super) {
    __extends(EyeGazeEventTarget, _super);
    function EyeGazeEventTarget() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return EyeGazeEventTarget;
}(EventTarget));
exports.EyeGazeEventTarget = EyeGazeEventTarget;
var EyeGazeDataStream = (function () {
    function EyeGazeDataStream() {
        this._eyeGazeDataStreams = new EyeGazeDataStreams();
        this._eyeGazeEventTarget = new EventTarget();
    }
    EyeGazeDataStream.prototype.generateStreamConfigByte = function () {
        var configByte = Uint8Array.from([0]);
        if (this._eyeGazeDataStreams.gazePosition) {
            configByte[0] = configByte[0] | 1;
        }
        if (this._eyeGazeDataStreams.gazeOrigin) {
            configByte[0] = configByte[0] | 2;
        }
        if (this._eyeGazeDataStreams.eyePositionNormalized) {
            configByte[0] = configByte[0] | 4;
        }
        if (this._eyeGazeDataStreams.headPositionAndRotation) {
            configByte[0] = configByte[0] | 8;
        }
        if (this._eyeGazeDataStreams.userPresence) {
            configByte[0] = configByte[0] | 16;
        }
        return configByte;
    };
    EyeGazeDataStream.prototype.performHandshake = function () {
        this._eyeGazeDataStreams.recalculateNumberOfFloats();
        var configByte = this.generateStreamConfigByte();
        this._webSocket.send(configByte);
    };
    EyeGazeDataStream.prototype.parseEyeTrackingData = function (data) {
        if (data.length < this._eyeGazeDataStreams.expectedNumberOfFloats) {
            return new CustomEvent(EyeGazeDataStream.BINARY_MESSAGE_PARSING_ERROR);
        }
        var currentIndexPosition = 0;
        var eyeGazeData = new eyegazeevent_1.EyeGazeData();
        if (this._eyeGazeDataStreams.gazePosition) {
            eyeGazeData.gazePositionXY[0] = data[currentIndexPosition++];
            eyeGazeData.gazePositionXY[1] = data[currentIndexPosition++];
        }
        if (this._eyeGazeDataStreams.gazeOrigin) {
            eyeGazeData.gazeOriginRightXYZ[0] = data[currentIndexPosition++];
            eyeGazeData.gazeOriginRightXYZ[1] = data[currentIndexPosition++];
            eyeGazeData.gazeOriginRightXYZ[2] = data[currentIndexPosition++];
            eyeGazeData.gazeOriginLeftXYZ[0] = data[currentIndexPosition++];
            eyeGazeData.gazeOriginLeftXYZ[1] = data[currentIndexPosition++];
            eyeGazeData.gazeOriginLeftXYZ[2] = data[currentIndexPosition++];
        }
        if (this._eyeGazeDataStreams.eyePositionNormalized) {
            eyeGazeData.eyePositionRightNormalizedXYZ[0] = data[currentIndexPosition++];
            eyeGazeData.eyePositionRightNormalizedXYZ[1] = data[currentIndexPosition++];
            eyeGazeData.eyePositionRightNormalizedXYZ[2] = data[currentIndexPosition++];
            eyeGazeData.eyePositionLeftNormalizedXYZ[0] = data[currentIndexPosition++];
            eyeGazeData.eyePositionLeftNormalizedXYZ[1] = data[currentIndexPosition++];
            eyeGazeData.eyePositionLeftNormalizedXYZ[2] = data[currentIndexPosition++];
        }
        if (this._eyeGazeDataStreams.headPositionAndRotation) {
            eyeGazeData.headPositionXYZ[0] = data[currentIndexPosition++];
            eyeGazeData.headPositionXYZ[1] = data[currentIndexPosition++];
            eyeGazeData.headPositionXYZ[2] = data[currentIndexPosition++];
            eyeGazeData.headRotationXYZ[0] = data[currentIndexPosition++];
            eyeGazeData.headRotationXYZ[1] = data[currentIndexPosition++];
            eyeGazeData.headRotationXYZ[2] = data[currentIndexPosition++];
        }
        if (this._eyeGazeDataStreams.userPresence) {
            eyeGazeData.userPresence = data[currentIndexPosition] === 0.0 ? false : true;
        }
        return new CustomEvent(EyeGazeDataStream.EYE_GAZE_DATA, { detail: { eyeGazeData: eyeGazeData } });
    };
    EyeGazeDataStream.prototype.onOpen = function (event) {
        this.dispatchEvent(new CustomEvent(EyeGazeDataStream.CONNECTION_STATUS, {
            detail: { message: EyeGazeDataStream.SUCCESSFULLY_CONNECTED_TO_SERVER, event: event },
        }));
        this.performHandshake();
    };
    EyeGazeDataStream.prototype.onClose = function (event) {
        this.dispatchEvent(new CustomEvent(EyeGazeDataStream.CONNECTION_STATUS, {
            detail: { message: EyeGazeDataStream.DISCONNECTED_TO_SERVER, event: event },
        }));
    };
    EyeGazeDataStream.prototype.onError = function (event) {
        this.dispatchEvent(new CustomEvent(EyeGazeDataStream.CONNECTION_STATUS, {
            detail: { message: EyeGazeDataStream.CONNECTION_ERROR, event: event },
        }));
    };
    EyeGazeDataStream.prototype.onMessage = function (event) {
        return __awaiter(this, void 0, void 0, function () {
            var arrayBuffer, floatData;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(typeof event.data !== 'string')) return [3, 2];
                        return [4, event.data.arrayBuffer()];
                    case 1:
                        arrayBuffer = _a.sent();
                        floatData = new Float32Array(arrayBuffer);
                        this.dispatchEvent(this.parseEyeTrackingData(floatData));
                        return [3, 3];
                    case 2:
                        this.dispatchEvent(new CustomEvent(EyeGazeDataStream.NEW_SERVER_MESSAGE, {
                            detail: { message: event.data },
                        }));
                        _a.label = 3;
                    case 3: return [2];
                }
            });
        });
    };
    EyeGazeDataStream.prototype.connect = function (serverAddress) {
        var _this = this;
        this._webSocket = new WebSocket(serverAddress);
        this._webSocket.onopen = function (event) {
            _this.onOpen(event);
        };
        this._webSocket.onclose = function (event) {
            _this.onClose(event);
        };
        this._webSocket.onerror = function (event) {
            _this.onError(event);
        };
        this._webSocket.onmessage = function (event) {
            _this.onMessage(event);
        };
    };
    EyeGazeDataStream.prototype.addEventListener = function (type, listener, options) {
        this._eyeGazeEventTarget.addEventListener(type, listener, options);
    };
    EyeGazeDataStream.prototype.dispatchEvent = function (event) {
        return this._eyeGazeEventTarget.dispatchEvent(event);
    };
    EyeGazeDataStream.prototype.removeEventListener = function (type, callback, options) {
        this._eyeGazeEventTarget.removeEventListener(type, callback, options);
    };
    Object.defineProperty(EyeGazeDataStream.prototype, "connectionState", {
        get: function () {
            return this._webSocket.readyState;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EyeGazeDataStream.prototype, "eyeGazeDataStreams", {
        get: function () {
            return this._eyeGazeDataStreams;
        },
        set: function (eyeGazeDataStreams) {
            if (this._eyeGazeDataStreams !== eyeGazeDataStreams) {
                this._eyeGazeDataStreams = eyeGazeDataStreams;
            }
        },
        enumerable: true,
        configurable: true
    });
    EyeGazeDataStream.EYE_GAZE_DATA = 'eyegazedata';
    EyeGazeDataStream.NEW_SERVER_MESSAGE = 'newservermessage';
    EyeGazeDataStream.CONNECTION_STATUS = 'connectionstatus';
    EyeGazeDataStream.BINARY_MESSAGE_PARSING_ERROR = 'binarymessageparsingerror';
    EyeGazeDataStream.SUCCESSFULLY_CONNECTED_TO_SERVER = 'successfully connected to server';
    EyeGazeDataStream.DISCONNECTED_TO_SERVER = 'disconnected to server';
    EyeGazeDataStream.CONNECTION_ERROR = 'connection error with server';
    return EyeGazeDataStream;
}());
exports.EyeGazeDataStream = EyeGazeDataStream;
var EyeGazeDataStreams = (function () {
    function EyeGazeDataStreams() {
        this.gazePosition = false;
        this.gazeOrigin = false;
        this.eyePositionNormalized = false;
        this.headPositionAndRotation = false;
        this.userPresence = false;
        this.expectedNumberOfFloats = 0;
    }
    EyeGazeDataStreams.prototype.recalculateNumberOfFloats = function () {
        var newNumberOfFloats = 0;
        if (this.gazePosition) {
            newNumberOfFloats += 2;
        }
        if (this.gazeOrigin) {
            newNumberOfFloats += 6;
        }
        if (this.eyePositionNormalized) {
            newNumberOfFloats += 6;
        }
        if (this.headPositionAndRotation) {
            newNumberOfFloats += 6;
        }
        if (this.userPresence) {
            newNumberOfFloats += 1;
        }
        this.expectedNumberOfFloats = newNumberOfFloats;
    };
    return EyeGazeDataStreams;
}());
exports.EyeGazeDataStreams = EyeGazeDataStreams;


/***/ }),

/***/ "./eyegazeevent.ts":
/*!*************************!*\
  !*** ./eyegazeevent.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var EyeGazeData = (function () {
    function EyeGazeData() {
        this.gazePositionXY = [0, 0];
        this.gazeOriginRightXYZ = [0, 0, 0];
        this.gazeOriginLeftXYZ = [0, 0, 0];
        this.eyePositionRightNormalizedXYZ = [0, 0, 0];
        this.eyePositionLeftNormalizedXYZ = [0, 0, 0];
        this.headPositionXYZ = [0, 0, 0];
        this.headRotationXYZ = [0, 0, 0];
        this.userPresence = false;
    }
    EyeGazeData.prototype.toString = function () {
        var message = '';
        message += "Gaze Position: " + this.gazePositionXY + "\n";
        message += "Gaze Origin Right: " + this.gazeOriginRightXYZ + "\n";
        message += "Gaze Origin Left: " + this.gazeOriginLeftXYZ + "\n";
        message += "Eye Position Normalized Right: " + this.eyePositionRightNormalizedXYZ + "\n";
        message += "Eye Position Normalized Left: " + this.eyePositionLeftNormalizedXYZ + "\n";
        message += "Head Position: " + this.headPositionXYZ + "\n";
        message += "Head Rotation: " + this.headRotationXYZ + "\n";
        message += "User Presence: " + this.userPresence + "\n";
        return message;
    };
    return EyeGazeData;
}());
exports.EyeGazeData = EyeGazeData;


/***/ }),

/***/ "./eyegazeeventprovider.ts":
/*!*********************************!*\
  !*** ./eyegazeeventprovider.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var rxjs_1 = __webpack_require__(/*! rxjs */ "rxjs");
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var eyegazedatastream_1 = __webpack_require__(/*! ./eyegazedatastream */ "./eyegazedatastream.ts");
var EyeGazeEventProvider = (function () {
    function EyeGazeEventProvider(eyeGazeDataStreams, serverAddress) {
        auxiliaries_1.assert(eyeGazeDataStreams !== undefined, "expected a valid eye gaze data streams object on initialization, given " + eyeGazeDataStreams + ".");
        this._eyeGazeDataStream = new eyegazedatastream_1.EyeGazeDataStream();
        this._eyeGazeDataStream.eyeGazeDataStreams = eyeGazeDataStreams;
        this._eyeGazeDataStream.connect(serverAddress);
    }
    EyeGazeEventProvider.prototype.preventDefaultOnEvent = function (type, event) {
        if (auxiliaries_1.bitInBitfield(this._preventDefaultMask, type)) {
            event.preventDefault();
        }
    };
    EyeGazeEventProvider.prototype.allowDefault = function () {
        var types = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            types[_i] = arguments[_i];
        }
        for (var _a = 0, types_1 = types; _a < types_1.length; _a++) {
            var type = types_1[_a];
            if (auxiliaries_1.bitInBitfield(this._preventDefaultMask, type)) {
                this._preventDefaultMask &= ~type;
            }
        }
    };
    EyeGazeEventProvider.prototype.preventDefault = function () {
        var types = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            types[_i] = arguments[_i];
        }
        for (var _a = 0, types_2 = types; _a < types_2.length; _a++) {
            var type = types_2[_a];
            if (!auxiliaries_1.bitInBitfield(this._preventDefaultMask, type)) {
                this._preventDefaultMask |= type;
            }
        }
    };
    EyeGazeEventProvider.prototype.observable = function (type) {
        switch (type) {
            case EyeGazeEventProvider.Type.EyeGazeData:
                return this.EyeGazeData$;
            case EyeGazeEventProvider.Type.NewServerMessage:
                return this.NewServerMessage$;
            case EyeGazeEventProvider.Type.ConnectionStatus:
                return this.ConnectionStatus$;
            case EyeGazeEventProvider.Type.BinaryMessageParsingError:
                return this.BinaryMessageParsingError$;
            default:
                return undefined;
        }
    };
    Object.defineProperty(EyeGazeEventProvider.prototype, "EyeGazeData$", {
        get: function () {
            var _this = this;
            if (this._eyeGazeDataSubject === undefined) {
                this._eyeGazeDataSubject = new rxjs_1.ReplaySubject(undefined, this._timeframe);
                this._eyeGazeDataListener = function (event) {
                    _this.preventDefaultOnEvent(EyeGazeEventProvider.Type.EyeGazeData, event);
                    _this._eyeGazeDataSubject.next(event);
                };
                this._eyeGazeDataStream.addEventListener(eyegazedatastream_1.EyeGazeDataStream.EYE_GAZE_DATA, this._eyeGazeDataListener);
            }
            return this._eyeGazeDataSubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EyeGazeEventProvider.prototype, "NewServerMessage$", {
        get: function () {
            var _this = this;
            if (this._newServerMessageSubject === undefined) {
                this._newServerMessageSubject = new rxjs_1.ReplaySubject(undefined, this._timeframe);
                this._newServerMessageListener = function (event) {
                    _this.preventDefaultOnEvent(EyeGazeEventProvider.Type.NewServerMessage, event);
                    _this._newServerMessageSubject.next(event);
                };
                this._eyeGazeDataStream.addEventListener(eyegazedatastream_1.EyeGazeDataStream.NEW_SERVER_MESSAGE, this._newServerMessageListener);
            }
            return this._newServerMessageSubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EyeGazeEventProvider.prototype, "ConnectionStatus$", {
        get: function () {
            var _this = this;
            if (this._connectionStatusSubject === undefined) {
                this._connectionStatusSubject = new rxjs_1.ReplaySubject(undefined, this._timeframe);
                this._connectionStatusListener = function (event) {
                    _this.preventDefaultOnEvent(EyeGazeEventProvider.Type.ConnectionStatus, event);
                    _this._connectionStatusSubject.next(event);
                };
                this._eyeGazeDataStream.addEventListener(eyegazedatastream_1.EyeGazeDataStream.CONNECTION_STATUS, this._connectionStatusListener);
            }
            return this._connectionStatusSubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EyeGazeEventProvider.prototype, "BinaryMessageParsingError$", {
        get: function () {
            var _this = this;
            if (this._binaryMessageParsingErrorSubject === undefined) {
                this._binaryMessageParsingErrorSubject = new rxjs_1.ReplaySubject(undefined, this._timeframe);
                this._binaryMessageParsingErrorListener = function (event) {
                    _this.preventDefaultOnEvent(EyeGazeEventProvider.Type.BinaryMessageParsingError, event);
                    _this._binaryMessageParsingErrorSubject.next(event);
                };
                this._eyeGazeDataStream.addEventListener(eyegazedatastream_1.EyeGazeDataStream.BINARY_MESSAGE_PARSING_ERROR, this._binaryMessageParsingErrorListener);
            }
            return this._eyeGazeDataSubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    return EyeGazeEventProvider;
}());
exports.EyeGazeEventProvider = EyeGazeEventProvider;
(function (EyeGazeEventProvider) {
    var Type;
    (function (Type) {
        Type[Type["EyeGazeData"] = 1] = "EyeGazeData";
        Type[Type["NewServerMessage"] = 2] = "NewServerMessage";
        Type[Type["ConnectionStatus"] = 4] = "ConnectionStatus";
        Type[Type["BinaryMessageParsingError"] = 8] = "BinaryMessageParsingError";
    })(Type = EyeGazeEventProvider.Type || (EyeGazeEventProvider.Type = {}));
})(EyeGazeEventProvider = exports.EyeGazeEventProvider || (exports.EyeGazeEventProvider = {}));
exports.EyeGazeEventProvider = EyeGazeEventProvider;


/***/ }),

/***/ "./fetch.ts":
/*!******************!*\
  !*** ./fetch.ts ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var properties_1 = __webpack_require__(/*! ./properties */ "./properties.ts");
var fetch;
(function (fetch) {
    var failed = function (url, request) {
        return "fetching '" + url + "' failed (" + request.status + "): " + request.statusText;
    };
    function fetchAsync(url, type) {
        var response = new Promise(function (resolve, reject) {
            var request = new XMLHttpRequest();
            request.open('GET', url, true);
            request.responseType = type;
            request.onload = function () {
                if (request.status < 200 || request.status >= 300) {
                    reject(failed(url, request));
                    return;
                }
                resolve(request.response);
            };
            request.onerror = function () { return reject(failed(url, request)); };
            request.ontimeout = function () { return reject(failed(url, request)); };
            request.send();
        });
        return response;
    }
    fetch.fetchAsync = fetchAsync;
    function fetchJsonAsync(url, transform, schema) {
        var response = new Promise(function (resolve, reject) {
            var request = new XMLHttpRequest();
            request.open('GET', url, true);
            request.onload = function () {
                if (request.status < 200 || request.status >= 300) {
                    reject(failed(url, request));
                    return;
                }
                var json = request.responseText;
                if (schema !== undefined && !properties_1.validate(json, schema)) {
                    return;
                }
                var data;
                try {
                    data = JSON.parse(json);
                }
                catch (error) {
                    reject("fetching '" + url + "' failed (" + error.name + "): " + error.message);
                    return;
                }
                var object = transform(data);
                if (object === undefined) {
                    reject("fetching '" + url + "' failed (TransformError): transforming the object failed.");
                    return;
                }
                resolve(object);
            };
            request.onerror = function () { return reject(failed(url, request)); };
            request.ontimeout = function () { return reject(failed(url, request)); };
            request.send();
        });
        return response;
    }
    fetch.fetchJsonAsync = fetchJsonAsync;
})(fetch || (fetch = {}));
module.exports = fetch;


/***/ }),

/***/ "./firstpersonmodifier.ts":
/*!********************************!*\
  !*** ./firstpersonmodifier.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "../node_modules/gl-matrix/esm/index.js");
var gl_matrix_extensions_1 = __webpack_require__(/*! ./gl-matrix-extensions */ "./gl-matrix-extensions.ts");
var cameramodifier_1 = __webpack_require__(/*! ./cameramodifier */ "./cameramodifier.ts");
var FirstPersonModifier = (function (_super) {
    __extends(FirstPersonModifier, _super);
    function FirstPersonModifier() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._rotation = gl_matrix_1.mat4.create();
        _this._sensitivity = FirstPersonModifier.DEFAULT_SENSITIVITY;
        return _this;
    }
    FirstPersonModifier.prototype.initiate = function (point) {
        Object.assign(this._reference, this._camera);
        this._initialPoint = point;
    };
    FirstPersonModifier.prototype.process = function (point, movement) {
        this._currentPoint = point;
        var magnitudes = gl_matrix_1.vec2.create();
        if (movement === undefined) {
            gl_matrix_1.vec2.subtract(magnitudes, this._initialPoint, this._currentPoint);
        }
        else {
            gl_matrix_1.vec2.copy(magnitudes, movement);
        }
        gl_matrix_1.vec2.scale(magnitudes, magnitudes, window.devicePixelRatio * this._sensitivity);
        gl_matrix_1.vec2.copy(this._initialPoint, this._currentPoint);
        var centerToEye = gl_matrix_1.vec3.sub(gl_matrix_extensions_1.v3(), this._reference.eye, this._reference.center);
        gl_matrix_1.vec3.normalize(centerToEye, centerToEye);
        var strafe = gl_matrix_1.vec3.cross(gl_matrix_extensions_1.v3(), centerToEye, this._reference.up);
        var yaw = gl_matrix_1.mat4.fromRotation(gl_matrix_extensions_1.m4(), -magnitudes[0], this._reference.up);
        var pitch = gl_matrix_1.mat4.fromRotation(gl_matrix_extensions_1.m4(), magnitudes[1], strafe);
        gl_matrix_1.mat4.mul(this._rotation, pitch, yaw);
        this.update();
    };
    FirstPersonModifier.prototype.update = function () {
        if (this._camera === undefined) {
            return;
        }
        var T = gl_matrix_1.mat4.fromTranslation(gl_matrix_extensions_1.m4(), this._reference.eye);
        gl_matrix_1.mat4.multiply(T, T, this._rotation);
        gl_matrix_1.mat4.translate(T, T, gl_matrix_1.vec3.negate(gl_matrix_extensions_1.v3(), this._reference.eye));
        var center = gl_matrix_1.vec3.transformMat4(gl_matrix_extensions_1.v3(), this._reference.center, T);
        this._camera.center = center;
        Object.assign(this._reference, this._camera);
    };
    Object.defineProperty(FirstPersonModifier.prototype, "sensitivity", {
        get: function () {
            return this._sensitivity;
        },
        set: function (sensitivity) {
            this._sensitivity = sensitivity;
        },
        enumerable: true,
        configurable: true
    });
    FirstPersonModifier.DEFAULT_SENSITIVITY = 0.0008;
    return FirstPersonModifier;
}(cameramodifier_1.CameraModifier));
exports.FirstPersonModifier = FirstPersonModifier;


/***/ }),

/***/ "./formatbytesizes.ts":
/*!****************************!*\
  !*** ./formatbytesizes.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
function byteSizeOfFormat(context, format) {
    var gl = context.gl;
    var gl2facade = context.gl2facade;
    var UNSIGNED_INT_24_8_WEBGL = context.supportsDepthTexture ?
        context.depthTexture.UNSIGNED_INT_24_8_WEBGL : undefined;
    switch (format) {
        case undefined:
            break;
        default:
            break;
        case gl.UNSIGNED_BYTE:
        case gl.UNSIGNED_SHORT_5_6_5:
        case gl.UNSIGNED_SHORT_4_4_4_4:
        case gl.UNSIGNED_SHORT_5_5_5_1:
        case gl.UNSIGNED_SHORT:
        case gl.UNSIGNED_INT:
        case UNSIGNED_INT_24_8_WEBGL:
        case gl.FLOAT:
        case gl2facade.HALF_FLOAT:
        case gl.BYTE:
        case gl.UNSIGNED_SHORT:
        case gl.SHORT:
        case gl.UNSIGNED_INT:
        case gl.INT:
        case gl.HALF_FLOAT:
        case gl.FLOAT:
        case gl.UNSIGNED_INT_2_10_10_10_REV:
        case gl.UNSIGNED_INT_10F_11F_11F_REV:
        case gl.UNSIGNED_INT_5_9_9_9_REV:
        case gl.UNSIGNED_INT_24_8:
        case gl.FLOAT_32_UNSIGNED_INT_24_8_REV:
            auxiliaries_1.assert(false, "expected format instead of type " + format);
            return 0;
    }
    var SRGB8_ALPHA8_EXT = context.supportsSRGB ? context.sRGB.SRGB8_ALPHA8_EXT : undefined;
    var SRGB_EXT = context.supportsSRGB ? context.sRGB.SRGB_EXT : undefined;
    var SRGB_ALPHA_EXT = context.supportsSRGB ? context.sRGB.SRGB_ALPHA_EXT : undefined;
    var RGB32F_EXT = context.supportsColorBufferFloat ? context.colorBufferFloat.RGB32F_EXT : undefined;
    var RGBA32F_EXT = context.supportsColorBufferFloat ? context.colorBufferFloat.RGBA32F_EXT : undefined;
    switch (format) {
        case undefined:
        default:
            auxiliaries_1.assert(false, "size of format " + format + " is unknown");
            return 0;
        case gl.ALPHA:
        case gl.LUMINANCE:
        case gl.R8:
        case gl.R8I:
        case gl.R8UI:
        case gl.STENCIL_INDEX8:
            return 1;
        case gl.DEPTH_COMPONENT16:
        case gl.LUMINANCE_ALPHA:
        case gl.R16F:
        case gl.R16I:
        case gl.R16UI:
        case gl.RG8:
        case gl.RG8I:
        case gl.RG8UI:
        case gl.RGB565:
        case gl.RGB5_A1:
        case gl.RGBA4:
            return 2;
        case gl.DEPTH_COMPONENT24:
        case gl.RGB:
        case gl.RGB8:
        case gl.RGB8UI:
        case gl.SRGB:
        case SRGB_EXT:
        case gl.SRGB8:
            return 3;
        case gl.DEPTH_STENCIL:
        case gl.DEPTH24_STENCIL8:
        case gl.DEPTH_COMPONENT32F:
        case gl.R11F_G11F_B10F:
        case gl.R32F:
        case gl.R32I:
        case gl.R32UI:
        case gl.RG16F:
        case gl.RG16I:
        case gl.RG16UI:
        case gl.RGB10_A2:
        case gl.RGB10_A2UI:
        case gl.RGB9_E5:
        case gl.RGBA:
        case gl.RGBA8:
        case gl.RGBA8I:
        case gl.RGBA8UI:
        case gl.SRGB8_ALPHA8:
        case SRGB8_ALPHA8_EXT:
        case gl.SRGB_ALPHA:
        case SRGB_ALPHA_EXT:
        case gl.SRGB_ALPHA8:
        case gl.SRGB_APLHA8:
            return 4;
        case gl.DEPTH32F_STENCIL8:
            return 5;
        case gl.RGB16F:
            return 6;
        case gl.RG32F:
        case gl.RG32I:
        case gl.RG32UI:
        case gl.RGBA16F:
        case gl.RGBA16I:
        case gl.RGBA16UI:
            return 8;
        case gl.RGB32F:
        case gl.RGB32F:
        case RGB32F_EXT:
            return 12;
        case gl.RGBA32F:
        case RGBA32F_EXT:
        case gl.RGBA32I:
        case gl.RGBA32UI:
            return 16;
        case gl.DEPTH_COMPONENT:
        case gl.DEPTH_STENCIL:
            auxiliaries_1.assert(false, "byte size of DEPTH_COMPONENT or DEPTH_STENCIL formats depends on active render buffer");
            return 0;
    }
}
exports.byteSizeOfFormat = byteSizeOfFormat;


/***/ }),

/***/ "./framebuffer.ts":
/*!************************!*\
  !*** ./framebuffer.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var initializable_1 = __webpack_require__(/*! ./initializable */ "./initializable.ts");
var object_1 = __webpack_require__(/*! ./object */ "./object.ts");
var renderbuffer_1 = __webpack_require__(/*! ./renderbuffer */ "./renderbuffer.ts");
var texture2d_1 = __webpack_require__(/*! ./texture2d */ "./texture2d.ts");
var Framebuffer = (function (_super) {
    __extends(Framebuffer, _super);
    function Framebuffer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._buffersByAttachment = new Map();
        _this._texturesByAttachment = new Map();
        _this._colorClearQueue = new Array();
        _this._drawBuffers = new Array();
        _this._drawBuffersChanged = false;
        return _this;
    }
    Framebuffer.statusString = function (context, status) {
        var gl = context.gl;
        switch (status) {
            case gl.FRAMEBUFFER_COMPLETE:
                return 'the framebuffer is ready to display (COMPLETE)';
            case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                return 'the attachment types are mismatched or not all framebuffer attachment points are ' +
                    'framebuffer attachment complete (INCOMPLETE_ATTACHMENT)';
            case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                return 'there is no attachment (INCOMPLETE_MISSING_ATTACHMENT)';
            case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                return 'height and width of the attachment are not the same (INCOMPLETE_DIMENSIONS)';
            case gl.FRAMEBUFFER_UNSUPPORTED:
                return 'the format of the attachment is not supported or if depth and stencil attachments are not ' +
                    'the same renderbuffer (UNSUPPORTED)';
            case gl.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE:
                return 'the values of gl.RENDERBUFFER_SAMPLES are different among attached renderbuffers, or are ' +
                    'non-zero if the attached images are a mix of renderbuffers and textures (INCOMPLETE_MULTISAMPLE)';
            default:
                auxiliaries_1.assert(false, "expected known framebuffer status, given " + status);
                return '';
        }
    };
    Framebuffer.prototype.create = function (attachments) {
        var gl = this._context.gl;
        var gl2facade = this.context.gl2facade;
        this._object = gl.createFramebuffer();
        this._clearColors = new Array(gl2facade.COLOR_ATTACHMENT_MAX - gl2facade.COLOR_ATTACHMENT0);
        this._clearDepth = 1.0;
        this._clearStencil = 0;
        this.clear = this.context.isWebGL1 ? this.es2Clear : this.es3Clear;
        for (var _i = 0, attachments_1 = attachments; _i < attachments_1.length; _i++) {
            var tuple = attachments_1[_i];
            var attachment = tuple[0];
            var bufferOrTexture = tuple[1];
            if (bufferOrTexture instanceof renderbuffer_1.Renderbuffer) {
                this._buffersByAttachment.set(attachment, bufferOrTexture);
            }
            else if (bufferOrTexture instanceof texture2d_1.Texture2D) {
                this._texturesByAttachment.set(attachment, bufferOrTexture);
            }
            if (attachment < gl2facade.COLOR_ATTACHMENT_MIN || attachment > gl2facade.COLOR_ATTACHMENT_MAX) {
                continue;
            }
            this._drawBuffers.push(attachment);
            var index = attachment - gl.COLOR_ATTACHMENT0;
            this._colorClearQueue.push(index);
            this._clearColors[index] = [0.0, 0.0, 0.0, 0.0];
        }
        this._drawBuffersChanged = true;
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._object);
        this._buffersByAttachment.forEach(function (buffer, attachment) {
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, buffer.object);
        });
        this._texturesByAttachment.forEach(function (texture, attachment) {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, texture.object, 0);
        });
        if (gl2facade.drawBuffers) {
            gl2facade.drawBuffers(this._drawBuffers);
        }
        var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
        this._valid = gl.isFramebuffer(this._object) && (status === gl.FRAMEBUFFER_COMPLETE);
        auxiliaries_1.logIf(!this._valid, auxiliaries_1.LogLevel.Warning, Framebuffer.statusString(this.context, status));
        gl.bindFramebuffer(gl.FRAMEBUFFER, Framebuffer.DEFAULT_FRAMEBUFFER);
        return this._object;
    };
    Framebuffer.prototype.delete = function () {
        auxiliaries_1.assert(this._object instanceof WebGLFramebuffer, "expected WebGLFramebuffer object");
        this.context.gl.deleteFramebuffer(this._object);
        this._object = undefined;
        this._valid = false;
    };
    Framebuffer.prototype.es2Clear = function (mask, bind, unbind) {
        if (bind === void 0) { bind = true; }
        if (unbind === void 0) { unbind = true; }
        var gl = this.context.gl;
        var clearDepth = auxiliaries_1.bitInBitfield(mask, gl.DEPTH_BUFFER_BIT);
        var clearStencil = auxiliaries_1.bitInBitfield(mask, gl.STENCIL_BUFFER_BIT);
        var clearColor = auxiliaries_1.bitInBitfield(mask, gl.COLOR_BUFFER_BIT);
        if (!clearColor && !clearDepth && !clearStencil) {
            return;
        }
        if (bind) {
            this.bind();
        }
        if (clearColor && this._clearColors[0] !== undefined) {
            var color = this._clearColors[0];
            gl.clearColor(color[0], color[1], color[2], color[3]);
        }
        if (clearDepth && this._clearDepth !== undefined) {
            gl.clearDepth(this._clearDepth);
        }
        if (clearStencil && this._clearStencil !== undefined) {
            gl.clearStencil(this._clearStencil);
        }
        gl.clear(mask);
        if (unbind) {
            this.unbind();
        }
    };
    Framebuffer.prototype.es3Clear = function (mask, bind, unbind, colorClearQueue) {
        if (bind === void 0) { bind = true; }
        if (unbind === void 0) { unbind = true; }
        var gl = this.context.gl;
        var clearDepth = auxiliaries_1.bitInBitfield(mask, gl.DEPTH_BUFFER_BIT);
        var clearStencil = auxiliaries_1.bitInBitfield(mask, gl.STENCIL_BUFFER_BIT);
        var clearColor = auxiliaries_1.bitInBitfield(mask, gl.COLOR_BUFFER_BIT);
        if (!clearColor && !clearDepth && !clearStencil) {
            return;
        }
        if (bind) {
            this.bind();
        }
        if (clearColor) {
            var isChrome = !!window['chrome'] &&
                (!!window['chrome']['webstore'] || !!window['chrome']['runtime']);
            if (isChrome) {
                var color = this._clearColors[0] ? this._clearColors[0] : [0.0, 0.0, 0.0, 1.0];
                gl.clearColor(color[0], color[1], color[2], color[3]);
                gl.clear(gl.COLOR_BUFFER_BIT);
            }
            for (var _i = 0, _a = colorClearQueue ? colorClearQueue : this._colorClearQueue; _i < _a.length; _i++) {
                var drawBuffer = _a[_i];
                gl.clearBufferfv(gl.COLOR, drawBuffer, this._clearColors[drawBuffer]);
            }
        }
        if (clearDepth && clearStencil) {
            gl.clearStencil(this._clearStencil);
            gl.clearDepth(this._clearDepth);
            gl.clear(gl.STENCIL_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        }
        else if (clearDepth) {
            gl.clearBufferfv(gl.DEPTH, 0, [this._clearDepth]);
        }
        else if (clearStencil) {
            gl.clearStencil(this._clearStencil);
            gl.clear(gl.STENCIL_BUFFER_BIT);
        }
        if (unbind) {
            this.unbind();
        }
    };
    Framebuffer.prototype.hasAttachment = function (attachment) {
        return this._texturesByAttachment.has(attachment) || this._buffersByAttachment.has(attachment);
    };
    Framebuffer.prototype.bind = function (target) {
        if (target === void 0) { target = this.context.gl.FRAMEBUFFER; }
        this.context.gl.bindFramebuffer(target, this._object);
        if (this._drawBuffersChanged && this.context.gl2facade.drawBuffers) {
            this.context.gl2facade.drawBuffers(this._drawBuffers);
            this._drawBuffersChanged = false;
        }
    };
    Framebuffer.prototype.unbind = function (target) {
        if (target === void 0) { target = this.context.gl.FRAMEBUFFER; }
        this.context.gl.bindFramebuffer(target, Framebuffer.DEFAULT_FRAMEBUFFER);
    };
    Framebuffer.prototype.clearColor = function (color, drawBuffer) {
        auxiliaries_1.assert(drawBuffer === undefined || drawBuffer === 0 || this.context.isWebGL2 ||
            this.context.supportsDrawBuffers, "WebGL2 context expected for clearing multiple color attachments.");
        var alphaIssue = color[3] < 1.0 && !this.context.alpha;
        auxiliaries_1.logIf(alphaIssue, auxiliaries_1.LogLevel.Warning, "context has alpha disabled, clear color alpha is ignored");
        var color2 = [color[0], color[1], color[2], alphaIssue ? 1.0 : color[3]];
        if (this.context.premultipliedAlpha && !alphaIssue) {
            color2[0] *= color2[3];
            color2[1] *= color2[3];
            color2[2] *= color2[3];
        }
        if (drawBuffer !== undefined) {
            this._clearColors[drawBuffer] = color2;
        }
        else {
            for (var i = 0; i < this._clearColors.length; ++i) {
                this._clearColors[i] = color2;
            }
        }
    };
    Framebuffer.prototype.clearDepth = function (depth) {
        this._clearDepth = depth;
    };
    Framebuffer.prototype.clearStencil = function (stencil) {
        this._clearStencil = stencil;
    };
    Framebuffer.prototype.texture = function (attachment) {
        return this._texturesByAttachment.get(attachment);
    };
    Framebuffer.prototype.resize = function (width, height, bind, unbind) {
        if (bind === void 0) { bind = true; }
        if (unbind === void 0) { unbind = true; }
        this._buffersByAttachment.forEach(function (buffer) {
            buffer.resize(width, height, bind, unbind);
        });
        this._texturesByAttachment.forEach(function (texture) {
            texture.resize(width, height, bind, unbind);
        });
    };
    Object.defineProperty(Framebuffer.prototype, "width", {
        get: function () {
            this.assertInitialized();
            var width = NaN;
            this._buffersByAttachment.forEach(function (buffer) {
                if (isNaN(width) || buffer.width < width) {
                    width = buffer.width;
                }
            });
            this._texturesByAttachment.forEach(function (texture) {
                if (isNaN(width) || texture.width < width) {
                    width = texture.width;
                }
            });
            return width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Framebuffer.prototype, "height", {
        get: function () {
            this.assertInitialized();
            var height = NaN;
            this._buffersByAttachment.forEach(function (buffer) {
                if (isNaN(height) || buffer.height < height) {
                    height = buffer.height;
                }
            });
            this._texturesByAttachment.forEach(function (texture) {
                if (isNaN(height) || texture.height < height) {
                    height = texture.height;
                }
            });
            return height;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Framebuffer.prototype, "size", {
        get: function () {
            return [this.width, this.height];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Framebuffer.prototype, "drawBuffers", {
        get: function () {
            this.assertInitialized();
            return this._drawBuffers;
        },
        set: function (attachments) {
            this.assertInitialized();
            var gl2facade = this.context.gl2facade;
            for (var _i = 0, attachments_2 = attachments; _i < attachments_2.length; _i++) {
                var attachment = attachments_2[_i];
                auxiliaries_1.assert(this.hasAttachment(attachment), "valid attachment expected for draw buffer, given " + attachment);
                auxiliaries_1.assert(attachment >= gl2facade.COLOR_ATTACHMENT_MIN && attachment <= gl2facade.COLOR_ATTACHMENT_MAX, "color attachment expected for draw buffer, given " + attachment);
                this._drawBuffersChanged = this._drawBuffersChanged || this._drawBuffers.indexOf(attachment) === -1;
            }
            this._drawBuffersChanged = this._drawBuffersChanged || attachments.length !== this._drawBuffers.length;
            if (this._drawBuffersChanged) {
                this._drawBuffers = attachments;
            }
        },
        enumerable: true,
        configurable: true
    });
    Framebuffer.DEFAULT_FRAMEBUFFER = undefined;
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Framebuffer.prototype, "es2Clear", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Framebuffer.prototype, "es3Clear", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Framebuffer.prototype, "bind", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Framebuffer.prototype, "unbind", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Framebuffer.prototype, "clearColor", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Framebuffer.prototype, "clearDepth", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Framebuffer.prototype, "clearStencil", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Framebuffer.prototype, "texture", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Framebuffer.prototype, "resize", null);
    return Framebuffer;
}(object_1.AbstractObject));
exports.Framebuffer = Framebuffer;


/***/ }),

/***/ "./gaussfilter.ts":
/*!************************!*\
  !*** ./gaussfilter.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "../node_modules/gl-matrix/esm/index.js");
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var gl_matrix_extensions_1 = __webpack_require__(/*! ./gl-matrix-extensions */ "./gl-matrix-extensions.ts");
var initializable_1 = __webpack_require__(/*! ./initializable */ "./initializable.ts");
var ndcfillingtriangle_1 = __webpack_require__(/*! ./ndcfillingtriangle */ "./ndcfillingtriangle.ts");
var program_1 = __webpack_require__(/*! ./program */ "./program.ts");
var shader_1 = __webpack_require__(/*! ./shader */ "./shader.ts");
var GaussFilter = (function (_super) {
    __extends(GaussFilter, _super);
    function GaussFilter(context) {
        var _this = _super.call(this) || this;
        _this._kernelSize = 7;
        _this._standardDeviation = 1.0;
        _this._redistribute = true;
        _this._ndcTriangleShared = false;
        _this._context = context;
        return _this;
    }
    GaussFilter.prototype.recalculateWeights = function () {
        if (this._weights) {
            return false;
        }
        var first = 1.0 / Math.sqrt(2.0 * Math.PI) * this._standardDeviation;
        var second = 2.0 * this._standardDeviation * this._standardDeviation;
        this._weights = [
            0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        ];
        var summedWeight = 0.0;
        for (var i = 0; i <= Math.floor(this._kernelSize / 2); i++) {
            this._weights[i] = first * Math.pow(Math.E, -(Math.pow(i, 2.0) / second));
            summedWeight += i > 0 ? 2.0 * this._weights[i] : this._weights[i];
        }
        if (this._redistribute) {
            var remainder = 1.0 - summedWeight;
            for (var i = 0; i <= Math.floor(this._kernelSize / 2); i++) {
                this._weights[i] += this._weights[i] / summedWeight * remainder;
            }
        }
        return true;
    };
    Object.defineProperty(GaussFilter.prototype, "kernelSize", {
        get: function () {
            return this._kernelSize;
        },
        set: function (kernelSize) {
            auxiliaries_1.assert(kernelSize > 0, 'Kernel size has to be positive.');
            auxiliaries_1.assert(kernelSize <= (GaussFilter._MAXKERNELSIZEHALF - 1) * 2 + 1, 'Kernel size has to be smaller than ' + ((GaussFilter._MAXKERNELSIZEHALF - 1) * 2 + 2) + '.');
            auxiliaries_1.assert(Number.isInteger(kernelSize), 'Kernel size has to be an integer.');
            auxiliaries_1.assert(kernelSize % 2 === 1, 'Kernel size has to be odd.');
            this._kernelSize = kernelSize;
            this._weights = undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GaussFilter.prototype, "standardDeviation", {
        get: function () {
            return this._standardDeviation;
        },
        set: function (standardDeviation) {
            auxiliaries_1.assert(standardDeviation > 0.0, 'Standard deviation has to be positive.');
            this._standardDeviation = standardDeviation;
            this._weights = undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GaussFilter.prototype, "redistribute", {
        get: function () {
            return this._redistribute;
        },
        set: function (redistribute) {
            this._redistribute = redistribute;
            this._weights = undefined;
        },
        enumerable: true,
        configurable: true
    });
    GaussFilter.prototype.initialize = function (ndcTriangle) {
        var gl = this._context.gl;
        var vert = new shader_1.Shader(this._context, gl.VERTEX_SHADER, 'gauss.vert');
        vert.initialize(__webpack_require__(/*! ./shaders/gaussfilter.vert */ "./shaders/gaussfilter.vert"));
        this._fragmentShader = new shader_1.Shader(this._context, gl.FRAGMENT_SHADER, 'gauss.frag');
        this._fragmentShader.replace('$KERNEL_HALF_SIZE', "" + Math.floor(this.kernelSize / 2));
        this._fragmentShader.initialize(__webpack_require__(/*! ./shaders/gaussfilter.frag */ "./shaders/gaussfilter.frag"));
        this._program = new program_1.Program(this._context);
        this._program.initialize([vert, this._fragmentShader]);
        this._uDelta = this._program.uniform('u_delta');
        this._uWeights = this._program.uniform('u_weights');
        var aVertex = this._program.attribute('a_vertex', 0);
        if (ndcTriangle === undefined) {
            this._ndcTriangle = new ndcfillingtriangle_1.NdcFillingTriangle(this._context, 'GaussFilterQuad');
        }
        else {
            this._ndcTriangle = ndcTriangle;
            this._ndcTriangleShared = true;
        }
        this._ndcTriangle.initialize(aVertex);
        return true;
    };
    GaussFilter.prototype.uninitialize = function () {
        this._program.uninitialize();
        if (!this._ndcTriangleShared) {
            this._ndcTriangle.uninitialize();
        }
    };
    GaussFilter.prototype.filter = function (texture, direction) {
        var gl = this._context.gl;
        var directionVectors = [gl_matrix_1.vec2.fromValues(1.0, 0.0), gl_matrix_1.vec2.fromValues(0.0, 1.0)];
        var recalculatedWeights = this.recalculateWeights();
        if (recalculatedWeights) {
            this._fragmentShader.replace('$KERNEL_HALF_SIZE', "" + Math.floor(this.kernelSize / 2));
            this._fragmentShader.compile();
            this._program.link();
            this._uDelta = this._program.uniform('u_delta');
            this._uWeights = this._program.uniform('u_weights');
            this._program.bind();
            gl.uniform1fv(this._uWeights, this._weights);
        }
        this._program.bind();
        texture.bind(gl.TEXTURE0);
        gl.uniform2fv(this._uDelta, gl_matrix_1.vec2.divide(gl_matrix_extensions_1.v2(), directionVectors[direction], texture.size));
        this._ndcTriangle.bind();
        this._ndcTriangle.draw();
        this._ndcTriangle.unbind();
        texture.unbind(gl.TEXTURE0);
        this._program.unbind();
    };
    GaussFilter._MAXKERNELSIZEHALF = 32;
    __decorate([
        initializable_1.Initializable.initialize()
    ], GaussFilter.prototype, "initialize", null);
    __decorate([
        initializable_1.Initializable.uninitialize()
    ], GaussFilter.prototype, "uninitialize", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], GaussFilter.prototype, "filter", null);
    return GaussFilter;
}(initializable_1.Initializable));
exports.GaussFilter = GaussFilter;
(function (GaussFilter) {
    var Direction;
    (function (Direction) {
        Direction[Direction["Horizontal"] = 0] = "Horizontal";
        Direction[Direction["Vertical"] = 1] = "Vertical";
    })(Direction = GaussFilter.Direction || (GaussFilter.Direction = {}));
})(GaussFilter = exports.GaussFilter || (exports.GaussFilter = {}));
exports.GaussFilter = GaussFilter;


/***/ }),

/***/ "./geometry.ts":
/*!*********************!*\
  !*** ./geometry.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var initializable_1 = __webpack_require__(/*! ./initializable */ "./initializable.ts");
var vertexarray_1 = __webpack_require__(/*! ./vertexarray */ "./vertexarray.ts");
var Geometry = (function (_super) {
    __extends(Geometry, _super);
    function Geometry(context, identifier) {
        var _this = _super.call(this) || this;
        _this._buffers = new Array();
        identifier = identifier !== undefined && identifier !== "" ? identifier : _this.constructor.name;
        _this._vertexArray = new vertexarray_1.VertexArray(context, identifier + "VAO");
        return _this;
    }
    Geometry.prototype.initialize = function () {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var targets = args[0];
        var indices = args[1];
        var valid = true;
        for (var i = 0; i < this._buffers.length; ++i) {
            valid = this._buffers[i].initialize(targets[i]) && valid;
        }
        this._vertexArray.initialize(function () { return _this.bindBuffers(indices); }, function () { return _this.unbindBuffers(indices); });
        return this._vertexArray.valid && valid;
    };
    Geometry.prototype.uninitialize = function () {
        this._vertexArray.uninitialize();
        this._buffers.forEach(function (buffer) { return buffer.uninitialize(); });
    };
    Geometry.prototype.bind = function () {
        this._vertexArray.bind();
    };
    Geometry.prototype.unbind = function () {
        this._vertexArray.unbind();
    };
    Object.defineProperty(Geometry.prototype, "buffers", {
        get: function () {
            return this._buffers;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Geometry.prototype, "context", {
        get: function () {
            return this._vertexArray.context;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Geometry.prototype, "vertexArray", {
        get: function () {
            return this._vertexArray;
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        initializable_1.Initializable.initialize()
    ], Geometry.prototype, "initialize", null);
    __decorate([
        initializable_1.Initializable.uninitialize()
    ], Geometry.prototype, "uninitialize", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Geometry.prototype, "bind", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Geometry.prototype, "unbind", null);
    return Geometry;
}(initializable_1.Initializable));
exports.Geometry = Geometry;


/***/ }),

/***/ "./gl-matrix-extensions.ts":
/*!*********************************!*\
  !*** ./gl-matrix-extensions.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "../node_modules/gl-matrix/esm/index.js");
var gl_matrix_extensions;
(function (gl_matrix_extensions) {
    function sign(x) {
        return x > 0.0 ? 1.0 : x < 0.0 ? -1.0 : 0.0;
    }
    gl_matrix_extensions.sign = sign;
    function clamp(x, min, max) {
        return Math.max(min, Math.min(max, x));
    }
    gl_matrix_extensions.clamp = clamp;
    function fract(x) {
        return x > 0 ? x - Math.floor(x) : x - Math.ceil(x);
    }
    gl_matrix_extensions.fract = fract;
    function v2() {
        return gl_matrix_1.vec2.create();
    }
    gl_matrix_extensions.v2 = v2;
    function clamp2(out, x, min, max) {
        out[0] = Math.max(min[0], Math.min(max[0], x[0]));
        out[1] = Math.max(min[1], Math.min(max[1], x[1]));
        return out;
    }
    gl_matrix_extensions.clamp2 = clamp2;
    function abs2(out, x) {
        out[0] = Math.abs(x[0]);
        out[1] = Math.abs(x[1]);
        return out;
    }
    gl_matrix_extensions.abs2 = abs2;
    function v3() {
        return gl_matrix_1.vec3.create();
    }
    gl_matrix_extensions.v3 = v3;
    function clamp3(out, x, min, max) {
        out[0] = Math.max(min[0], Math.min(max[0], x[0]));
        out[1] = Math.max(min[1], Math.min(max[1], x[1]));
        out[2] = Math.max(min[2], Math.min(max[2], x[2]));
        return out;
    }
    gl_matrix_extensions.clamp3 = clamp3;
    function abs3(out, x) {
        out[0] = Math.abs(x[0]);
        out[1] = Math.abs(x[1]);
        out[2] = Math.abs(x[2]);
        return out;
    }
    gl_matrix_extensions.abs3 = abs3;
    var one256ths = 1.0 / 256.0;
    function encode_float24x1_to_uint8x3(out, x) {
        out[0] = Math.floor(x * 256.0);
        out[1] = Math.floor(fract(x * 256.0) * 256.0);
        out[2] = Math.floor(fract(x * 65536.0) * 256.0);
        return out;
    }
    gl_matrix_extensions.encode_float24x1_to_uint8x3 = encode_float24x1_to_uint8x3;
    function decode_float24x1_from_uint8x3(x) {
        return (x[0] + (x[1] + x[2] * one256ths) * one256ths) * one256ths;
    }
    gl_matrix_extensions.decode_float24x1_from_uint8x3 = decode_float24x1_from_uint8x3;
    function encode_uint24_to_rgb8(out, x) {
        out[0] = (x >> 0) & 0xFF;
        out[1] = (x >> 8) & 0xFF;
        out[2] = (x >> 16) & 0xFF;
        return out;
    }
    gl_matrix_extensions.encode_uint24_to_rgb8 = encode_uint24_to_rgb8;
    function encode_uint32_to_rgba8(out, x) {
        out[0] = (x >> 0) & 0xFF;
        out[1] = (x >> 8) & 0xFF;
        out[2] = (x >> 16) & 0xFF;
        out[3] = (x >> 24) & 0xFF;
        return out;
    }
    gl_matrix_extensions.encode_uint32_to_rgba8 = encode_uint32_to_rgba8;
    function decode_uint24_from_rgb8(x) {
        return x[0] + (x[1] << 8) + (x[2] << 16);
    }
    gl_matrix_extensions.decode_uint24_from_rgb8 = decode_uint24_from_rgb8;
    function decode_uint32_from_rgba8(x) {
        return x[0] + (x[1] << 8) + (x[2] << 16) + (x[3] << 24);
    }
    gl_matrix_extensions.decode_uint32_from_rgba8 = decode_uint32_from_rgba8;
    function fromVec4(x) {
        if (x[3] === 0) {
            return gl_matrix_1.vec3.fromValues(x[0], x[1], x[2]);
        }
        return gl_matrix_1.vec3.fromValues(x[0] / x[3], x[1] / x[3], x[2] / x[3]);
    }
    gl_matrix_extensions.fromVec4 = fromVec4;
    function v4() {
        return gl_matrix_1.vec4.create();
    }
    gl_matrix_extensions.v4 = v4;
    function clamp4(out, x, min, max) {
        out[0] = Math.max(min[0], Math.min(max[0], x[0]));
        out[1] = Math.max(min[1], Math.min(max[1], x[1]));
        out[2] = Math.max(min[2], Math.min(max[2], x[2]));
        out[3] = Math.max(min[3], Math.min(max[3], x[3]));
        return out;
    }
    gl_matrix_extensions.clamp4 = clamp4;
    function abs4(out, x) {
        out[0] = Math.abs(x[0]);
        out[1] = Math.abs(x[1]);
        out[2] = Math.abs(x[2]);
        out[3] = Math.abs(x[3]);
        return out;
    }
    gl_matrix_extensions.abs4 = abs4;
    function fromVec3(x) {
        return gl_matrix_1.vec4.fromValues(x[0], x[1], x[2], 1.0);
    }
    gl_matrix_extensions.fromVec3 = fromVec3;
    function parseVec2(v2str) {
        if (v2str === undefined || v2str === '') {
            return undefined;
        }
        var numbers = [];
        try {
            numbers = JSON.parse("[" + v2str + "]");
        }
        catch (error) {
            return undefined;
        }
        return numbers.length !== 2 || isNaN(numbers[0]) || isNaN(numbers[1]) ?
            undefined : gl_matrix_1.vec2.clone(numbers);
    }
    gl_matrix_extensions.parseVec2 = parseVec2;
    function parseVec3(v3str) {
        if (v3str === undefined || v3str === '') {
            return undefined;
        }
        var numbers = [];
        try {
            numbers = JSON.parse("[" + v3str + "]");
        }
        catch (error) {
            return undefined;
        }
        return numbers.length !== 3 || isNaN(numbers[0]) || isNaN(numbers[1]) || isNaN(numbers[2]) ?
            undefined : gl_matrix_1.vec3.clone(numbers);
    }
    gl_matrix_extensions.parseVec3 = parseVec3;
    function parseVec4(v4str) {
        if (v4str === undefined || v4str === '') {
            return undefined;
        }
        var numbers = [];
        try {
            numbers = JSON.parse("[" + v4str + "]");
        }
        catch (error) {
            return undefined;
        }
        return numbers.length !== 4 || isNaN(numbers[0]) || isNaN(numbers[1]) ||
            isNaN(numbers[2]) || isNaN(numbers[3]) ?
            undefined : gl_matrix_1.vec4.clone(numbers);
    }
    gl_matrix_extensions.parseVec4 = parseVec4;
    function mix(value1, value2, interpolation) {
        return value1 * (1.0 - interpolation) + value2 * interpolation;
    }
    gl_matrix_extensions.mix = mix;
    function m2() {
        return gl_matrix_1.mat2.create();
    }
    gl_matrix_extensions.m2 = m2;
    function m3() {
        return gl_matrix_1.mat3.create();
    }
    gl_matrix_extensions.m3 = m3;
    function m4() {
        return gl_matrix_1.mat4.create();
    }
    gl_matrix_extensions.m4 = m4;
})(gl_matrix_extensions || (gl_matrix_extensions = {}));
module.exports = gl_matrix_extensions;


/***/ }),

/***/ "./gl2facade.ts":
/*!**********************!*\
  !*** ./gl2facade.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var context_1 = __webpack_require__(/*! ./context */ "./context.ts");
var GL2Facade = (function () {
    function GL2Facade(context) {
        this.drawBuffers = undefined;
        auxiliaries_1.assert(context !== undefined, "gl2 facade expects a valid WebGL context");
        this.queryHalfFloatSupport(context);
        this.queryColorAttachments(context);
        this.queryInstancedArraySupport(context);
        this.queryDrawBuffersSupport(context);
        this.queryVertexArrayObjectSupport(context);
        this.queryMaxUniformVec3Components(context);
        this.queryBufferSubDataInterface(context);
        this.queryTexImageInterface(context);
    }
    Object.defineProperty(GL2Facade.prototype, "HALF_FLOAT", {
        get: function () {
            return this._halfFloat;
        },
        enumerable: true,
        configurable: true
    });
    GL2Facade.prototype.queryHalfFloatSupport = function (context) {
        switch (context.backend) {
            case context_1.Context.BackendType.WebGL1:
                this._halfFloat = context.supportsTextureHalfFloat && context.textureHalfFloat ?
                    context.textureHalfFloat.HALF_FLOAT_OES : undefined;
                break;
            case context_1.Context.BackendType.WebGL2:
            default:
                this._halfFloat = context.gl.HALF_FLOAT;
                break;
        }
    };
    Object.defineProperty(GL2Facade.prototype, "COLOR_ATTACHMENT_MIN", {
        get: function () {
            return this._colorAttachmentMin;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GL2Facade.prototype, "COLOR_ATTACHMENT_MAX", {
        get: function () {
            return this._colorAttachmentMax;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GL2Facade.prototype, "COLOR_ATTACHMENT0", {
        get: function () {
            return this._colorAttachments[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GL2Facade.prototype, "COLOR_ATTACHMENT1", {
        get: function () {
            return this._colorAttachments[1];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GL2Facade.prototype, "COLOR_ATTACHMENT2", {
        get: function () {
            return this._colorAttachments[2];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GL2Facade.prototype, "COLOR_ATTACHMENT3", {
        get: function () {
            return this._colorAttachments[3];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GL2Facade.prototype, "COLOR_ATTACHMENT4", {
        get: function () {
            return this._colorAttachments[4];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GL2Facade.prototype, "COLOR_ATTACHMENT5", {
        get: function () {
            return this._colorAttachments[5];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GL2Facade.prototype, "COLOR_ATTACHMENT6", {
        get: function () {
            return this._colorAttachments[6];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GL2Facade.prototype, "COLOR_ATTACHMENT7", {
        get: function () {
            return this._colorAttachments[7];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GL2Facade.prototype, "COLOR_ATTACHMENT8", {
        get: function () {
            return this._colorAttachments[8];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GL2Facade.prototype, "COLOR_ATTACHMENT9", {
        get: function () {
            return this._colorAttachments[9];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GL2Facade.prototype, "COLOR_ATTACHMENT10", {
        get: function () {
            return this._colorAttachments[10];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GL2Facade.prototype, "COLOR_ATTACHMENT11", {
        get: function () {
            return this._colorAttachments[11];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GL2Facade.prototype, "COLOR_ATTACHMENT12", {
        get: function () {
            return this._colorAttachments[12];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GL2Facade.prototype, "COLOR_ATTACHMENT13", {
        get: function () {
            return this._colorAttachments[13];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GL2Facade.prototype, "COLOR_ATTACHMENT14", {
        get: function () {
            return this._colorAttachments[14];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GL2Facade.prototype, "COLOR_ATTACHMENT15", {
        get: function () {
            return this._colorAttachments[15];
        },
        enumerable: true,
        configurable: true
    });
    GL2Facade.prototype.queryColorAttachments = function (context) {
        var gl = context.gl;
        this._colorAttachments = new Array(16);
        this._colorAttachments[0] = gl.COLOR_ATTACHMENT0;
        switch (context.backend) {
            case context_1.Context.BackendType.WebGL1:
                var drawBuffers = context.supportsDrawBuffers ? context.drawBuffers : undefined;
                this._colorAttachmentMin = this._colorAttachments[0];
                this._colorAttachmentMax = this._colorAttachmentMin + (drawBuffers ?
                    gl.getParameter(drawBuffers.MAX_COLOR_ATTACHMENTS_WEBGL) : 0);
                this._colorAttachments[0] = drawBuffers ? drawBuffers.COLOR_ATTACHMENT0_WEBGL : gl.COLOR_ATTACHMENT0;
                if (!drawBuffers) {
                    break;
                }
                for (var i = 1; i < 16; ++i) {
                    this._colorAttachments[i] = drawBuffers.COLOR_ATTACHMENT0_WEBGL + i;
                }
                break;
            case context_1.Context.BackendType.WebGL2:
            default:
                this._colorAttachmentMin = context.gl.COLOR_ATTACHMENT0;
                this._colorAttachmentMax = context.gl.COLOR_ATTACHMENT0
                    + gl.getParameter(gl.MAX_COLOR_ATTACHMENTS);
                for (var i = 0; i < 16; ++i) {
                    this._colorAttachments[i] = gl.COLOR_ATTACHMENT0 + i;
                }
                break;
        }
    };
    GL2Facade.prototype.queryInstancedArraySupport = function (context) {
        if (!context.isWebGL2 && !context.supportsInstancedArrays) {
            return;
        }
        this.drawArraysInstanced = context.isWebGL2 ?
            function (mode, first, count, instanceCount) {
                return context.gl.drawArraysInstanced(mode, first, count, instanceCount);
            } :
            function (mode, first, count, instanceCount) {
                return context.instancedArrays.drawArraysInstancedANGLE(mode, first, count, instanceCount);
            };
        this.drawElementsInstanced = context.isWebGL2 ?
            function (mode, count, type, offset, primcount) {
                return context.gl.drawElementsInstanced(mode, count, type, offset, primcount);
            } :
            function (mode, count, type, offset, primcount) {
                return context.instancedArrays.drawElementsInstancedANGLE(mode, count, type, offset, primcount);
            };
        this.vertexAttribDivisor = context.isWebGL2 ?
            function (index, divisor) { return context.gl.vertexAttribDivisor(index, divisor); } :
            function (index, divisor) { return context.instancedArrays.vertexAttribDivisorANGLE(index, divisor); };
    };
    Object.defineProperty(GL2Facade.prototype, "MAX_DRAW_BUFFERS", {
        get: function () {
            return this._maxDrawBuffers;
        },
        enumerable: true,
        configurable: true
    });
    GL2Facade.prototype.queryDrawBuffersSupport = function (context) {
        if (!context.isWebGL2 && !context.supportsDrawBuffers) {
            return;
        }
        this.drawBuffers = context.isWebGL2 ?
            function (buffers) { return context.gl.drawBuffers(buffers); } :
            function (buffers) { return context.drawBuffers.drawBuffersWEBGL(buffers); };
        this._maxDrawBuffers = context.isWebGL2 ?
            context.gl.MAX_DRAW_BUFFERS :
            context.drawBuffers.MAX_DRAW_BUFFERS_WEBGL;
    };
    GL2Facade.prototype.queryVertexArrayObjectSupport = function (context) {
        if (!context.isWebGL2 && !context.supportsVertexArrayObject) {
            return;
        }
        this.createVertexArray = context.isWebGL2 ?
            function () { return context.gl.createVertexArray(); } :
            function () { return context.vertexArrayObject.createVertexArrayOES(); };
        this.deleteVertexArray = context.isWebGL2 ?
            function (arrayObject) { return context.gl.deleteVertexArray(arrayObject); } :
            function (arrayObject) { return context.vertexArrayObject.deleteVertexArrayOES(arrayObject); };
        this.isVertexArray = context.isWebGL2 ?
            function (arrayObject) { return context.gl.isVertexArray(arrayObject); } :
            function (arrayObject) { return context.vertexArrayObject.isVertexArrayOES(arrayObject); };
        this.bindVertexArray = context.isWebGL2 ?
            function (arrayObject) { return context.gl.bindVertexArray(arrayObject); } :
            function (arrayObject) { return context.vertexArrayObject.bindVertexArrayOES(arrayObject); };
    };
    Object.defineProperty(GL2Facade.prototype, "maxUniformVec3Components", {
        get: function () {
            return this._maxUniformVec3Components;
        },
        enumerable: true,
        configurable: true
    });
    GL2Facade.prototype.queryMaxUniformVec3Components = function (context) {
        var gl = context.gl;
        this._maxUniformVec3Components = context.isWebGL2
            ? gl.getParameter(gl.MAX_VERTEX_UNIFORM_COMPONENTS)
            : gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS) * 3;
    };
    GL2Facade.prototype.queryBufferSubDataInterface = function (context) {
        var gl = context.gl;
        if (context.isWebGL2) {
            this.bufferSubData = function (target, dstByteOffset, srcData, srcOffset, length) {
                if (length === void 0) { length = 0; }
                return gl.bufferSubData(target, dstByteOffset, srcData, srcOffset, length);
            };
        }
        else {
            this.bufferSubData = function (target, dstByteOffset, srcData, srcOffset, length) {
                if (srcOffset === void 0) { srcOffset = 0; }
                if (length === void 0) { length = 0; }
                auxiliaries_1.logIf(srcOffset !== 0, auxiliaries_1.LogLevel.Warning, "srcOffset ignored (not supported in WebGL)");
                auxiliaries_1.logIf(length !== 0, auxiliaries_1.LogLevel.Warning, "length ignored (not supported in WebGL)");
                return gl.bufferSubData(target, dstByteOffset, srcData);
            };
        }
    };
    GL2Facade.prototype.queryTexImageInterface = function (context) {
        var gl = context.gl;
        if (context.isWebGL2) {
            this.texImage2D = function (target, level, internalformat, width, height, border, format, type, source, offset) {
                if (source instanceof ArrayBuffer) {
                    return gl.texImage2D(target, level, internalformat, width, height, border, format, type, source === undefined ? null : source, offset);
                }
                auxiliaries_1.assert(offset === undefined, "offset expected to be undefined for non ArrayBuffer source");
                return gl.texImage2D(target, level, internalformat, width, height, border, format, type, source === undefined ? null : source);
            };
        }
        else {
            this.texImage2D = function (target, level, internalformat, width, height, border, format, type, source, offset) {
                if (source === undefined) {
                    return gl.texImage2D(target, level, internalformat, width, height, border, format, type, null);
                }
                if (source instanceof Int8Array ||
                    source instanceof Uint8Array ||
                    source instanceof Uint8ClampedArray ||
                    source instanceof Int16Array ||
                    source instanceof Uint16Array ||
                    source instanceof Int32Array ||
                    source instanceof Uint32Array ||
                    source instanceof Float32Array ||
                    source instanceof Float64Array ||
                    source instanceof DataView) {
                    return gl.texImage2D(target, level, internalformat, width, height, border, format, type, source);
                }
                return gl.texImage2D(target, level, internalformat, format, type, source);
            };
        }
        if (context.supportsTexImage3D) {
            this.texImage3D = function (target, level, internalformat, width, height, depth, border, format, type, source, offset) {
                if (source instanceof ArrayBuffer) {
                    return gl.texImage3D(target, level, internalformat, width, height, depth, border, format, type, source === undefined ? null : source, offset);
                }
                auxiliaries_1.assert(offset === undefined, "offset expected to be undefined for non ArrayBuffer source");
                return gl.texImage3D(target, level, internalformat, width, height, depth, border, format, type, source === undefined ? null : source);
            };
        }
        else {
            this.texImage3D = function (target, level, internalformat, width, height, depth, border, format, type, source, offset) {
                return auxiliaries_1.assert(false, 'texImage3D not supported on this context');
            };
        }
    };
    return GL2Facade;
}());
exports.GL2Facade = GL2Facade;


/***/ }),

/***/ "./gltf/gltfhelper.ts":
/*!****************************!*\
  !*** ./gltf/gltfhelper.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var auxiliaries_1 = __webpack_require__(/*! ../auxiliaries */ "./auxiliaries.ts");
var GLTFHelper = (function () {
    function GLTFHelper() {
    }
    GLTFHelper.modeToEnum = function (gl, mode) {
        if (mode < 0 || mode > 6) {
            auxiliaries_1.log(auxiliaries_1.LogLevel.Error, "Specified draw mode is " + mode + " but is required to be between 0 and 6");
        }
        if (mode === 0) {
            return gl.POINTS;
        }
        if (mode === 1) {
            return gl.LINES;
        }
        if (mode === 2) {
            return gl.LINE_LOOP;
        }
        if (mode === 3) {
            return gl.LINE_STRIP;
        }
        if (mode === 4) {
            return gl.TRIANGLES;
        }
        if (mode === 5) {
            return gl.TRIANGLE_STRIP;
        }
        if (mode === 6) {
            return gl.TRIANGLE_FAN;
        }
        return gl.TRIANGLES;
    };
    GLTFHelper.nameToAttributeIndex = function (name) {
        if (name === 'POSITION') {
            return 0;
        }
        if (name === 'NORMAL') {
            return 1;
        }
        if (name === 'TANGENT') {
            return 2;
        }
        if (name === 'TEXCOORD_0') {
            return 3;
        }
        if (name === 'TEXCOORD_1') {
            return 4;
        }
        if (name === 'TEXCOORD_2') {
            return 5;
        }
        if (name === 'JOINTS_0') {
            return 6;
        }
        if (name === 'WEIGHTS_0') {
            return 7;
        }
        if (name === 'COLOR_0') {
            return 8;
        }
        auxiliaries_1.log(auxiliaries_1.LogLevel.Warning, "Unknown attribute name '" + name + "' encountered.             Possibly this model uses an unsupported extension.");
        return -1;
    };
    return GLTFHelper;
}());
exports.GLTFHelper = GLTFHelper;


/***/ }),

/***/ "./gltf/gltfloader.ts":
/*!****************************!*\
  !*** ./gltf/gltfloader.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "../node_modules/gl-matrix/esm/index.js");
var auxiliaries_1 = __webpack_require__(/*! ../auxiliaries */ "./auxiliaries.ts");
var gltf_loader_ts_1 = __webpack_require__(/*! gltf-loader-ts */ "../node_modules/gltf-loader-ts/lib/gltf-loader.js");
var gltfhelper_1 = __webpack_require__(/*! ./gltfhelper */ "./gltf/gltfhelper.ts");
var gltfmesh_1 = __webpack_require__(/*! ./gltfmesh */ "./gltf/gltfmesh.ts");
var gltfpbrmaterial_1 = __webpack_require__(/*! ./gltfpbrmaterial */ "./gltf/gltfpbrmaterial.ts");
var gltfprimitive_1 = __webpack_require__(/*! ./gltfprimitive */ "./gltf/gltfprimitive.ts");
var buffer_1 = __webpack_require__(/*! ../buffer */ "./buffer.ts");
var core_1 = __webpack_require__(/*! ../core */ "./core/index.ts");
var program_1 = __webpack_require__(/*! ../program */ "./program.ts");
var scene_1 = __webpack_require__(/*! ../scene */ "./scene/index.ts");
var scenenode_1 = __webpack_require__(/*! ../scene/scenenode */ "./scene/scenenode.ts");
var shader_1 = __webpack_require__(/*! ../shader */ "./shader.ts");
var texture2d_1 = __webpack_require__(/*! ../texture2d */ "./texture2d.ts");
var GLTFLoader = (function () {
    function GLTFLoader(context) {
        this._context = context;
        var gl = this._context.gl;
        this._resourceManager = new core_1.ResourceManager(this._context);
        this._scenes = new Array();
        var vert = new shader_1.Shader(this._context, gl.VERTEX_SHADER, 'gltf_default.vert');
        vert.initialize(__webpack_require__(/*! ./shaders/gltf_default.vert */ "./gltf/shaders/gltf_default.vert"));
        var frag = new shader_1.Shader(this._context, gl.FRAGMENT_SHADER, 'gltf_default.frag');
        frag.initialize(__webpack_require__(/*! ./shaders/gltf_default.frag */ "./gltf/shaders/gltf_default.frag"));
        this._pbrProgram = new program_1.Program(this._context, 'GLTFPbrProgram');
        this._pbrProgram.initialize([vert, frag]);
    }
    GLTFLoader.prototype.loadTextures = function (asset) {
        return __awaiter(this, void 0, void 0, function () {
            var gl, textures, images, samplers, textureId, _i, textures_1, textureInfo, imageId, image, identifier, name_1, data, canvas, ctx, texture, sampler;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        gl = this._context.gl;
                        textures = asset.gltf.textures;
                        images = asset.gltf.images;
                        samplers = asset.gltf.samplers;
                        if (!textures || !images) {
                            return [2];
                        }
                        textureId = 0;
                        _i = 0, textures_1 = textures;
                        _a.label = 1;
                    case 1:
                        if (!(_i < textures_1.length)) return [3, 4];
                        textureInfo = textures_1[_i];
                        if (textureInfo.source === undefined) {
                            auxiliaries_1.log(auxiliaries_1.LogLevel.Warning, "The GLTF model does not specify a texture source. Possibly it uses an unsupported extension.");
                            textureId++;
                            return [3, 3];
                        }
                        imageId = textureInfo.source;
                        image = images[imageId];
                        identifier = this._sceneName + '_texture_' + textureId;
                        name_1 = image.name === undefined ? image.uri : image.name;
                        return [4, asset.imageData.get(imageId)];
                    case 2:
                        data = _a.sent();
                        if (!auxiliaries_1.isPowerOfTwo(data.width) || !auxiliaries_1.isPowerOfTwo(data.height)) {
                            canvas = document.createElement('canvas');
                            canvas.width = auxiliaries_1.upperPowerOfTwo(data.width);
                            canvas.height = auxiliaries_1.upperPowerOfTwo(data.height);
                            ctx = canvas.getContext('2d');
                            if (ctx === undefined) {
                                auxiliaries_1.log(auxiliaries_1.LogLevel.Error, 'Failed to create context while trying to resize non power of two texture');
                            }
                            ctx.drawImage(data, 0, 0, canvas.width, canvas.height);
                            data = canvas;
                        }
                        texture = new texture2d_1.Texture2D(this._context, name_1);
                        texture.initialize(data.width, data.height, gl.RGBA8, gl.RGBA, gl.UNSIGNED_BYTE);
                        texture.data(data);
                        if (samplers === undefined || textureInfo.sampler === undefined) {
                            texture.wrap(gl.REPEAT, gl.REPEAT);
                            texture.filter(gl.LINEAR, gl.LINEAR);
                        }
                        else {
                            sampler = samplers[textureInfo.sampler];
                            texture.wrap(sampler.wrapS || gl.REPEAT, sampler.wrapT || gl.REPEAT);
                            texture.filter(sampler.magFilter || gl.LINEAR, sampler.minFilter || gl.LINEAR);
                            if (sampler.minFilter === gl.NEAREST_MIPMAP_NEAREST ||
                                sampler.minFilter === gl.LINEAR_MIPMAP_NEAREST ||
                                sampler.minFilter === gl.NEAREST_MIPMAP_LINEAR ||
                                sampler.minFilter === gl.LINEAR_MIPMAP_LINEAR) {
                                texture.generateMipMap();
                            }
                        }
                        this._resourceManager.add(texture, [name_1, identifier]);
                        textureId++;
                        _a.label = 3;
                    case 3:
                        _i++;
                        return [3, 1];
                    case 4: return [2];
                }
            });
        });
    };
    GLTFLoader.prototype.getTexture = function (index) {
        var identifier = this._sceneName + '_texture_' + index;
        var texture = this._resourceManager.get(identifier);
        if (texture === undefined) {
            auxiliaries_1.log(auxiliaries_1.LogLevel.Warning, "Texture with index " + index + " could not be located.");
            return;
        }
        return texture;
    };
    GLTFLoader.prototype.loadMaterials = function (asset) {
        return __awaiter(this, void 0, void 0, function () {
            var materials, materialId, _i, materials_1, materialInfo, identifier, material, normalTexture, occlusionTexture, emissiveTexture, pbrInfo, baseColorTexture, metallicRoughnessTexture;
            return __generator(this, function (_a) {
                this._pbrDefaultMaterial = new gltfpbrmaterial_1.GLTFPbrMaterial(this._context, 'DefaultMaterial');
                this._resourceManager.add(this._pbrDefaultMaterial, [this._pbrDefaultMaterial.name]);
                materials = asset.gltf.materials;
                if (!materials) {
                    return [2];
                }
                materialId = 0;
                for (_i = 0, materials_1 = materials; _i < materials_1.length; _i++) {
                    materialInfo = materials_1[_i];
                    identifier = this._sceneName + '_material_' + materialId;
                    material = new gltfpbrmaterial_1.GLTFPbrMaterial(this._context, materialInfo.name);
                    normalTexture = materialInfo.normalTexture;
                    if (normalTexture !== undefined) {
                        material.normalTexture = this.getTexture(normalTexture.index);
                        material.normalTexCoord = normalTexture.texCoord || 0;
                        material.normalScale = normalTexture.scale || 1;
                    }
                    occlusionTexture = materialInfo.occlusionTexture;
                    if (occlusionTexture !== undefined) {
                        material.occlusionTexture = this.getTexture(occlusionTexture.index);
                        material.occlusionTexCoord = occlusionTexture.texCoord || 0;
                    }
                    emissiveTexture = materialInfo.emissiveTexture;
                    if (emissiveTexture !== undefined) {
                        material.emissiveTexture = this.getTexture(emissiveTexture.index);
                        material.emissiveTexCoord = emissiveTexture.texCoord || 0;
                    }
                    material.emissiveFactor = gl_matrix_1.vec3.fromValues(0, 0, 0);
                    if (materialInfo.emissiveFactor !== undefined) {
                        material.emissiveFactor = gl_matrix_1.vec3.fromValues.apply(undefined, materialInfo.emissiveFactor);
                    }
                    material.alphaMode = gltfpbrmaterial_1.GLTFAlphaMode.OPAQUE;
                    if (materialInfo.alphaMode === 'MASK') {
                        material.alphaMode = gltfpbrmaterial_1.GLTFAlphaMode.MASK;
                        if (materialInfo.alphaCutoff === undefined) {
                            material.alphaCutoff = 0.5;
                        }
                        else {
                            material.alphaCutoff = materialInfo.alphaCutoff;
                        }
                    }
                    else if (materialInfo.alphaMode === 'BLEND') {
                        material.alphaMode = gltfpbrmaterial_1.GLTFAlphaMode.BLEND;
                        material.isTransparent = true;
                    }
                    material.isDoubleSided = materialInfo.doubleSided || false;
                    pbrInfo = materialInfo.pbrMetallicRoughness;
                    if (pbrInfo === undefined) {
                        auxiliaries_1.log(auxiliaries_1.LogLevel.Warning, 'Model contains a material without PBR information');
                    }
                    baseColorTexture = pbrInfo.baseColorTexture;
                    if (baseColorTexture !== undefined) {
                        material.baseColorTexture = this.getTexture(baseColorTexture.index);
                        material.baseColorTexCoord = baseColorTexture.texCoord || 0;
                    }
                    metallicRoughnessTexture = pbrInfo.metallicRoughnessTexture;
                    if (metallicRoughnessTexture !== undefined) {
                        material.metallicRoughnessTexture = this.getTexture(metallicRoughnessTexture.index);
                        material.metallicRoughnessTexCoord = metallicRoughnessTexture.texCoord || 0;
                    }
                    material.baseColorFactor = gl_matrix_1.vec4.fromValues(1, 1, 1, 1);
                    if (pbrInfo.baseColorFactor !== undefined) {
                        material.baseColorFactor = gl_matrix_1.vec4.fromValues.apply(undefined, pbrInfo.baseColorFactor);
                    }
                    material.metallicFactor = 1.0;
                    if (pbrInfo.metallicFactor !== undefined) {
                        material.metallicFactor = pbrInfo.metallicFactor;
                    }
                    material.roughnessFactor = 1.0;
                    if (pbrInfo.roughnessFactor !== undefined) {
                        material.roughnessFactor = pbrInfo.roughnessFactor;
                    }
                    this._resourceManager.add(material, [materialInfo.name, identifier]);
                    materialId++;
                }
                return [2];
            });
        });
    };
    GLTFLoader.prototype.inferBufferUsage = function (asset, bufferViewId) {
        var gl = this._context.gl;
        var meshes = asset.gltf.meshes;
        var accessors = asset.gltf.accessors;
        if (meshes === undefined || accessors === undefined) {
            auxiliaries_1.log(auxiliaries_1.LogLevel.Error, "Asset does not include any meshes or accessors");
            return gl.ARRAY_BUFFER;
        }
        for (var _i = 0, _a = meshes; _i < _a.length; _i++) {
            var meshInfo = _a[_i];
            for (var _b = 0, _c = meshInfo.primitives; _b < _c.length; _b++) {
                var primitive = _c[_b];
                var indexAccessorId = primitive.indices;
                if (indexAccessorId === undefined) {
                    continue;
                }
                var accessor = accessors[indexAccessorId];
                var indexBufferViewId = accessor.bufferView;
                if (indexBufferViewId === undefined) {
                    continue;
                }
                else if (indexBufferViewId === bufferViewId) {
                    return gl.ELEMENT_ARRAY_BUFFER;
                }
            }
        }
        return gl.ARRAY_BUFFER;
    };
    GLTFLoader.prototype.loadBuffers = function (asset) {
        return __awaiter(this, void 0, void 0, function () {
            var gl, bufferViews, accessors, bufferViewId, _i, bufferViews_1, bufferViewInfo, identifier, data, target, buffer, accessorId, _a, accessors_1, accessorInfo, bufferViewIndex, sparseInfo, identifier, buffer, data;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        gl = this._context.gl;
                        bufferViews = asset.gltf.bufferViews;
                        accessors = asset.gltf.accessors;
                        if (!bufferViews) {
                            auxiliaries_1.log(auxiliaries_1.LogLevel.Warning, 'The asset does not include any buffer view information.');
                            return [2];
                        }
                        if (!accessors) {
                            auxiliaries_1.log(auxiliaries_1.LogLevel.Warning, 'The asset does not include any accessor information.');
                            return [2];
                        }
                        bufferViewId = 0;
                        _i = 0, bufferViews_1 = bufferViews;
                        _b.label = 1;
                    case 1:
                        if (!(_i < bufferViews_1.length)) return [3, 4];
                        bufferViewInfo = bufferViews_1[_i];
                        identifier = this._sceneName + '_bufferView_' + bufferViewId;
                        return [4, asset.bufferViewData(bufferViewId)];
                    case 2:
                        data = _b.sent();
                        target = bufferViewInfo.target;
                        if (target === undefined) {
                            target = this.inferBufferUsage(asset, bufferViewId);
                        }
                        buffer = new buffer_1.Buffer(this._context, identifier);
                        buffer.initialize(target);
                        buffer.data(data, gl.STATIC_DRAW);
                        this._resourceManager.add(buffer, [identifier]);
                        bufferViewId++;
                        _b.label = 3;
                    case 3:
                        _i++;
                        return [3, 1];
                    case 4:
                        accessorId = 0;
                        _a = 0, accessors_1 = accessors;
                        _b.label = 5;
                    case 5:
                        if (!(_a < accessors_1.length)) return [3, 9];
                        accessorInfo = accessors_1[_a];
                        bufferViewIndex = accessorInfo.bufferView;
                        sparseInfo = accessorInfo.sparse;
                        if (!(bufferViewIndex === undefined || sparseInfo !== undefined)) return [3, 7];
                        identifier = this._sceneName + '_accessor_' + accessorId;
                        buffer = new buffer_1.Buffer(this._context, identifier);
                        return [4, asset.accessorData(accessorId)];
                    case 6:
                        data = _b.sent();
                        buffer.initialize(gl.ARRAY_BUFFER);
                        buffer.data(data, gl.STATIC_DRAW);
                        this._resourceManager.add(buffer, [identifier]);
                        _b.label = 7;
                    case 7:
                        accessorId++;
                        _b.label = 8;
                    case 8:
                        _a++;
                        return [3, 5];
                    case 9: return [2];
                }
            });
        });
    };
    GLTFLoader.prototype.loadMeshes = function (asset) {
        return __awaiter(this, void 0, void 0, function () {
            var result, meshes, primitiveId, _i, meshes_1, meshInfo, mesh, _a, _b, primitiveInfo, primitive;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        result = new Array();
                        meshes = asset.gltf.meshes;
                        if (meshes === undefined) {
                            auxiliaries_1.log(auxiliaries_1.LogLevel.Warning, 'The asset does not contain any mesh information');
                            return [2, result];
                        }
                        primitiveId = 0;
                        _i = 0, meshes_1 = meshes;
                        _c.label = 1;
                    case 1:
                        if (!(_i < meshes_1.length)) return [3, 7];
                        meshInfo = meshes_1[_i];
                        mesh = new gltfmesh_1.GLTFMesh();
                        _a = 0, _b = meshInfo.primitives;
                        _c.label = 2;
                    case 2:
                        if (!(_a < _b.length)) return [3, 5];
                        primitiveInfo = _b[_a];
                        return [4, this.loadPrimitive(asset, primitiveInfo, primitiveId)];
                    case 3:
                        primitive = _c.sent();
                        if (primitive !== undefined) {
                            mesh.addPrimitive(primitive);
                        }
                        primitiveId++;
                        _c.label = 4;
                    case 4:
                        _a++;
                        return [3, 2];
                    case 5:
                        result.push(mesh);
                        _c.label = 6;
                    case 6:
                        _i++;
                        return [3, 1];
                    case 7: return [2, result];
                }
            });
        });
    };
    GLTFLoader.prototype.loadPrimitive = function (asset, primitiveInfo, id) {
        return __awaiter(this, void 0, void 0, function () {
            var gl, accessors, bufferViews, modeNumber, identifier, drawMode, bindings, material, materialIdentifier, fetchedMaterial, geometryFlags, semantic, attributeIndex, accessorIndex, accessorInfo, bufferViewIndex, sparseInfo, buffer, stride, accessorIdentifier, bufferViewInfo, bufferViewIdentifier, binding, indexBinding, accessorInfo, bufferViewIndex, bufferViewIdentifier, buffer, primitive;
            return __generator(this, function (_a) {
                gl = this._context.gl;
                accessors = asset.gltf.accessors;
                bufferViews = asset.gltf.bufferViews;
                if (accessors === undefined) {
                    auxiliaries_1.log(auxiliaries_1.LogLevel.Error, 'GLTF asset does not have any accessors.');
                    return [2];
                }
                if (bufferViews === undefined) {
                    auxiliaries_1.log(auxiliaries_1.LogLevel.Error, 'GLTF asset does not have any buffer views.');
                    return [2];
                }
                modeNumber = primitiveInfo.mode;
                identifier = this._sceneName + '_primitive_' + id;
                if (!modeNumber) {
                    modeNumber = 4;
                }
                drawMode = gltfhelper_1.GLTFHelper.modeToEnum(gl, modeNumber);
                bindings = new Array();
                material = this._pbrDefaultMaterial;
                if (primitiveInfo.material !== undefined) {
                    materialIdentifier = this._sceneName + '_material_' + primitiveInfo.material;
                    fetchedMaterial = this._resourceManager.get(materialIdentifier);
                    if (fetchedMaterial !== undefined) {
                        material = fetchedMaterial;
                    }
                    else {
                        auxiliaries_1.log(auxiliaries_1.LogLevel.Warning, "Material " + materialIdentifier + " could not be found.");
                    }
                }
                geometryFlags = 0;
                for (semantic in primitiveInfo.attributes) {
                    attributeIndex = gltfhelper_1.GLTFHelper.nameToAttributeIndex(semantic);
                    if (semantic === 'NORMAL') {
                        geometryFlags |= gltfpbrmaterial_1.GLTFShaderFlags.HAS_NORMALS;
                    }
                    if (semantic === 'TANGENT') {
                        geometryFlags |= gltfpbrmaterial_1.GLTFShaderFlags.HAS_TANGENTS;
                    }
                    if (semantic === 'COLOR_0') {
                        geometryFlags |= gltfpbrmaterial_1.GLTFShaderFlags.HAS_COLORS;
                    }
                    if (semantic === 'TEXCOORD_0' || semantic === 'TEXCOORD_1' || semantic === 'TEXCOORD_2') {
                        geometryFlags |= gltfpbrmaterial_1.GLTFShaderFlags.HAS_UV;
                    }
                    accessorIndex = primitiveInfo.attributes[semantic];
                    accessorInfo = accessors[accessorIndex];
                    bufferViewIndex = accessorInfo.bufferView;
                    sparseInfo = accessorInfo.sparse;
                    buffer = void 0;
                    stride = 0;
                    if (bufferViewIndex === undefined || sparseInfo !== undefined) {
                        accessorIdentifier = this._sceneName + '_accessor_' + accessorIndex;
                        buffer = this._resourceManager.get(accessorIdentifier);
                    }
                    else {
                        bufferViewInfo = bufferViews[bufferViewIndex];
                        bufferViewIdentifier = this._sceneName + '_bufferView_' + bufferViewIndex;
                        buffer = this._resourceManager.get(bufferViewIdentifier);
                        stride = bufferViewInfo.byteStride || 0;
                    }
                    binding = new gltfprimitive_1.VertexBinding();
                    binding.buffer = buffer;
                    binding.attributeIndex = attributeIndex;
                    binding.numVertices = accessorInfo.count;
                    binding.normalized = accessorInfo.normalized || false;
                    binding.size = gltf_loader_ts_1.GLTF_ELEMENTS_PER_TYPE[accessorInfo.type];
                    binding.offset = accessorInfo.byteOffset || 0;
                    binding.stride = stride;
                    binding.type = accessorInfo.componentType;
                    bindings.push(binding);
                }
                if (primitiveInfo.indices !== undefined) {
                    accessorInfo = accessors[primitiveInfo.indices];
                    bufferViewIndex = accessorInfo.bufferView;
                    if (!bufferViewIndex === undefined) {
                        auxiliaries_1.log(auxiliaries_1.LogLevel.Error, 'Accessor does not reference a BufferView.');
                    }
                    bufferViewIdentifier = this._sceneName + '_bufferView_' + bufferViewIndex;
                    buffer = this._resourceManager.get(bufferViewIdentifier);
                    indexBinding = new gltfprimitive_1.IndexBinding();
                    indexBinding.buffer = buffer;
                    indexBinding.numIndices = accessorInfo.count;
                    indexBinding.offset = accessorInfo.byteOffset || 0;
                    indexBinding.type = accessorInfo.componentType;
                }
                primitive = new gltfprimitive_1.GLTFPrimitive(this._context, bindings, indexBinding, drawMode, material, geometryFlags);
                primitive.initialize();
                this._resourceManager.add(primitive, [identifier]);
                return [2, primitive];
            });
        });
    };
    GLTFLoader.prototype.generateScenes = function (asset, meshes) {
        return __awaiter(this, void 0, void 0, function () {
            var nodes, scenes, idToNode, nodeId, _i, nodes_1, node, name_2, sceneNode, matrix, transformComponent, rotation, translation, scale, matrix, transformComponent, mesh, _a, _b, primitive, geometryComponent, _c, nodes_2, node, sceneNode, _d, _e, childId, childNode, sceneId, _f, scenes_1, scene, name_3, sceneNode, _g, _h, nodeId_1, node, defaultSceneId;
            return __generator(this, function (_j) {
                nodes = asset.gltf.nodes;
                scenes = asset.gltf.scenes;
                if (!nodes || !scenes) {
                    auxiliaries_1.log(auxiliaries_1.LogLevel.Warning, 'The asset does not contain any nodes or scene information.');
                    return [2];
                }
                idToNode = new Map();
                nodeId = 0;
                for (_i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
                    node = nodes_1[_i];
                    name_2 = node.name || 'node_' + nodeId;
                    sceneNode = new scenenode_1.SceneNode(name_2);
                    idToNode.set(nodeId, sceneNode);
                    if (node.matrix) {
                        matrix = gl_matrix_1.mat4.fromValues.apply(undefined, node.matrix);
                        transformComponent = new scene_1.TransformComponent(matrix);
                        sceneNode.addComponent(transformComponent);
                    }
                    else if (node.translation || node.rotation || node.scale) {
                        rotation = gl_matrix_1.quat.create();
                        if (node.rotation) {
                            rotation = gl_matrix_1.quat.fromValues.apply(undefined, node.rotation);
                        }
                        translation = gl_matrix_1.vec3.create();
                        if (node.translation) {
                            translation = gl_matrix_1.vec3.fromValues.apply(undefined, node.translation);
                        }
                        scale = gl_matrix_1.vec3.fromValues(1, 1, 1);
                        if (node.scale) {
                            scale = gl_matrix_1.vec3.fromValues.apply(undefined, node.scale);
                        }
                        matrix = gl_matrix_1.mat4.fromRotationTranslationScale(gl_matrix_1.mat4.create(), rotation, translation, scale);
                        transformComponent = new scene_1.TransformComponent(matrix);
                        sceneNode.addComponent(transformComponent);
                    }
                    if (node.mesh !== undefined) {
                        mesh = meshes[node.mesh];
                        for (_a = 0, _b = mesh.primitives; _a < _b.length; _a++) {
                            primitive = _b[_a];
                            geometryComponent = new scene_1.GeometryComponent();
                            geometryComponent.material = primitive.material;
                            geometryComponent.geometry = primitive;
                            sceneNode.addComponent(geometryComponent);
                        }
                    }
                    if (node.skin || node.weights) {
                        auxiliaries_1.log(auxiliaries_1.LogLevel.Info, 'Imported GLTF assets uses skins, which are not supported yet.');
                    }
                    nodeId++;
                }
                nodeId = 0;
                for (_c = 0, nodes_2 = nodes; _c < nodes_2.length; _c++) {
                    node = nodes_2[_c];
                    sceneNode = idToNode.get(nodeId);
                    auxiliaries_1.assert(sceneNode !== undefined, 'Scene node could not be found.');
                    if (node.children) {
                        for (_d = 0, _e = node.children; _d < _e.length; _d++) {
                            childId = _e[_d];
                            childNode = idToNode.get(childId);
                            if (!childNode) {
                                auxiliaries_1.log(auxiliaries_1.LogLevel.Error, 'Model references a node that does not exist.');
                            }
                            sceneNode.addNode(childNode);
                        }
                    }
                    nodeId++;
                }
                sceneId = 0;
                for (_f = 0, scenes_1 = scenes; _f < scenes_1.length; _f++) {
                    scene = scenes_1[_f];
                    name_3 = scene.name || 'scene_' + sceneId;
                    sceneNode = new scenenode_1.SceneNode(name_3);
                    if (scene.nodes) {
                        for (_g = 0, _h = scene.nodes; _g < _h.length; _g++) {
                            nodeId_1 = _h[_g];
                            node = idToNode.get(nodeId_1);
                            if (!node) {
                                auxiliaries_1.log(auxiliaries_1.LogLevel.Error, 'Scene references a node that does not exist.');
                            }
                            sceneNode.addNode(node);
                        }
                    }
                    else {
                        auxiliaries_1.log(auxiliaries_1.LogLevel.Warning, "Scene " + name_3 + " does not contain any nodes.");
                    }
                    this._scenes.push(sceneNode);
                    sceneId++;
                }
                defaultSceneId = asset.gltf.scene;
                if (defaultSceneId !== undefined) {
                    this._defaultScene = this._scenes[defaultSceneId];
                }
                return [2];
            });
        });
    };
    GLTFLoader.prototype.loadAsset = function (uri) {
        return __awaiter(this, void 0, void 0, function () {
            var loader, asset, gltf;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        loader = new gltf_loader_ts_1.GltfLoader();
                        return [4, loader.load(uri)];
                    case 1:
                        asset = _a.sent();
                        gltf = asset.gltf;
                        this._sceneName = 'scene';
                        if (gltf.scenes && gltf.scene && gltf.scenes[gltf.scene].name) {
                            this._sceneName = gltf.scenes[gltf.scene].name;
                        }
                        return [4, this.loadTextures(asset)
                                .then(function () { return _this.loadMaterials(asset); })
                                .then(function () { return _this.loadBuffers(asset); })
                                .then(function () { return _this.loadMeshes(asset); })
                                .then(function (meshes) { return _this.generateScenes(asset, meshes); })];
                    case 2:
                        _a.sent();
                        return [2];
                }
            });
        });
    };
    GLTFLoader.prototype.uninitialize = function () {
        this._scenes = [];
        this._defaultScene = undefined;
        this._resourceManager.uninitialize();
    };
    Object.defineProperty(GLTFLoader.prototype, "pbrProgram", {
        get: function () {
            return this._pbrProgram;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GLTFLoader.prototype, "scenes", {
        get: function () {
            return this._scenes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GLTFLoader.prototype, "defaultScene", {
        get: function () {
            if (this._defaultScene !== undefined) {
                return this._defaultScene;
            }
            else if (this._scenes !== undefined && this._scenes.length > 0) {
                return this._scenes[0];
            }
            else {
                auxiliaries_1.log(auxiliaries_1.LogLevel.Warning, 'Default scene was requested, but none is available.');
                return new scenenode_1.SceneNode('EmptyScene');
            }
        },
        enumerable: true,
        configurable: true
    });
    return GLTFLoader;
}());
exports.GLTFLoader = GLTFLoader;


/***/ }),

/***/ "./gltf/gltfmesh.ts":
/*!**************************!*\
  !*** ./gltf/gltfmesh.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var GLTFMesh = (function () {
    function GLTFMesh() {
        this._primitives = new Array();
    }
    Object.defineProperty(GLTFMesh.prototype, "primitives", {
        get: function () {
            return this._primitives;
        },
        enumerable: true,
        configurable: true
    });
    GLTFMesh.prototype.addPrimitive = function (primitive) {
        this._primitives.push(primitive);
    };
    return GLTFMesh;
}());
exports.GLTFMesh = GLTFMesh;


/***/ }),

/***/ "./gltf/gltfpbrmaterial.ts":
/*!*********************************!*\
  !*** ./gltf/gltfpbrmaterial.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "../node_modules/gl-matrix/esm/index.js");
var scene_1 = __webpack_require__(/*! ../scene */ "./scene/index.ts");
var GLTFShaderFlags;
(function (GLTFShaderFlags) {
    GLTFShaderFlags[GLTFShaderFlags["HAS_NORMALS"] = 1] = "HAS_NORMALS";
    GLTFShaderFlags[GLTFShaderFlags["HAS_TANGENTS"] = 2] = "HAS_TANGENTS";
    GLTFShaderFlags[GLTFShaderFlags["HAS_UV"] = 4] = "HAS_UV";
    GLTFShaderFlags[GLTFShaderFlags["HAS_COLORS"] = 8] = "HAS_COLORS";
    GLTFShaderFlags[GLTFShaderFlags["USE_IBL"] = 16] = "USE_IBL";
    GLTFShaderFlags[GLTFShaderFlags["HAS_BASECOLORMAP"] = 32] = "HAS_BASECOLORMAP";
    GLTFShaderFlags[GLTFShaderFlags["HAS_NORMALMAP"] = 64] = "HAS_NORMALMAP";
    GLTFShaderFlags[GLTFShaderFlags["HAS_EMISSIVEMAP"] = 128] = "HAS_EMISSIVEMAP";
    GLTFShaderFlags[GLTFShaderFlags["HAS_METALROUGHNESSMAP"] = 256] = "HAS_METALROUGHNESSMAP";
    GLTFShaderFlags[GLTFShaderFlags["HAS_OCCLUSIONMAP"] = 512] = "HAS_OCCLUSIONMAP";
    GLTFShaderFlags[GLTFShaderFlags["USE_TEX_LOD"] = 1024] = "USE_TEX_LOD";
})(GLTFShaderFlags = exports.GLTFShaderFlags || (exports.GLTFShaderFlags = {}));
var GLTFAlphaMode;
(function (GLTFAlphaMode) {
    GLTFAlphaMode[GLTFAlphaMode["OPAQUE"] = 0] = "OPAQUE";
    GLTFAlphaMode[GLTFAlphaMode["MASK"] = 1] = "MASK";
    GLTFAlphaMode[GLTFAlphaMode["BLEND"] = 2] = "BLEND";
})(GLTFAlphaMode = exports.GLTFAlphaMode || (exports.GLTFAlphaMode = {}));
var GLTFPbrMaterial = (function (_super) {
    __extends(GLTFPbrMaterial, _super);
    function GLTFPbrMaterial(context, name) {
        var _this = _super.call(this, context, name) || this;
        _this.baseColorTexCoord = 0;
        _this.metallicRoughnessTexCoord = 0;
        _this.normalTexCoord = 0;
        _this.occlusionTexCoord = 0;
        _this.emissiveTexCoord = 0;
        _this._alphaMode = GLTFAlphaMode.OPAQUE;
        _this._alphaCutoff = 1.0;
        _this._baseColorFactor = gl_matrix_1.vec4.fromValues(1, 1, 1, 1);
        _this._metallicFactor = 1;
        _this._roughnessFactor = 1;
        _this._emissiveFactor = gl_matrix_1.vec3.fromValues(0, 0, 0);
        _this._isDoubleSided = false;
        _this._normalScale = 1;
        return _this;
    }
    Object.defineProperty(GLTFPbrMaterial.prototype, "baseColorTexture", {
        get: function () {
            return this._baseColorTexture;
        },
        set: function (texture) {
            this._baseColorTexture = texture;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GLTFPbrMaterial.prototype, "metallicRoughnessTexture", {
        get: function () {
            return this._metallicRoughnessTexture;
        },
        set: function (texture) {
            this._metallicRoughnessTexture = texture;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GLTFPbrMaterial.prototype, "normalTexture", {
        get: function () {
            return this._normalTexture;
        },
        set: function (texture) {
            this._normalTexture = texture;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GLTFPbrMaterial.prototype, "occlusionTexture", {
        get: function () {
            return this._occlusionTexture;
        },
        set: function (texture) {
            this._occlusionTexture = texture;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GLTFPbrMaterial.prototype, "emissiveTexture", {
        get: function () {
            return this._emissiveTexture;
        },
        set: function (texture) {
            this._emissiveTexture = texture;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GLTFPbrMaterial.prototype, "emissiveFactor", {
        get: function () {
            return this._emissiveFactor;
        },
        set: function (factor) {
            this._emissiveFactor = factor;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GLTFPbrMaterial.prototype, "baseColorFactor", {
        get: function () {
            return this._baseColorFactor;
        },
        set: function (factor) {
            this._baseColorFactor = factor;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GLTFPbrMaterial.prototype, "metallicFactor", {
        get: function () {
            return this._metallicFactor;
        },
        set: function (factor) {
            this._metallicFactor = factor;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GLTFPbrMaterial.prototype, "roughnessFactor", {
        get: function () {
            return this._roughnessFactor;
        },
        set: function (factor) {
            this._roughnessFactor = factor;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GLTFPbrMaterial.prototype, "normalScale", {
        get: function () {
            return this._normalScale;
        },
        set: function (normalScale) {
            this._normalScale = normalScale;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GLTFPbrMaterial.prototype, "isDoubleSided", {
        get: function () {
            return this._isDoubleSided;
        },
        set: function (val) {
            this._isDoubleSided = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GLTFPbrMaterial.prototype, "alphaMode", {
        get: function () {
            return this._alphaMode;
        },
        set: function (alphaMode) {
            this._alphaMode = alphaMode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GLTFPbrMaterial.prototype, "alphaCutoff", {
        get: function () {
            return this._alphaCutoff;
        },
        set: function (val) {
            this._alphaCutoff = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GLTFPbrMaterial.prototype, "flags", {
        get: function () {
            var pbrFlags = 0;
            if (this.baseColorTexture !== undefined) {
                pbrFlags |= GLTFShaderFlags.HAS_BASECOLORMAP;
            }
            if (this.metallicRoughnessTexture !== undefined) {
                pbrFlags |= GLTFShaderFlags.HAS_METALROUGHNESSMAP;
            }
            if (this.normalTexture !== undefined) {
                pbrFlags |= GLTFShaderFlags.HAS_NORMALMAP;
            }
            if (this.occlusionTexture !== undefined) {
                pbrFlags |= GLTFShaderFlags.HAS_OCCLUSIONMAP;
            }
            if (this.emissiveTexture !== undefined) {
                pbrFlags |= GLTFShaderFlags.HAS_EMISSIVEMAP;
            }
            return pbrFlags;
        },
        enumerable: true,
        configurable: true
    });
    return GLTFPbrMaterial;
}(scene_1.Material));
exports.GLTFPbrMaterial = GLTFPbrMaterial;


/***/ }),

/***/ "./gltf/gltfprimitive.ts":
/*!*******************************!*\
  !*** ./gltf/gltfprimitive.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var geometry_1 = __webpack_require__(/*! ../geometry */ "./geometry.ts");
var IndexBinding = (function () {
    function IndexBinding() {
    }
    return IndexBinding;
}());
exports.IndexBinding = IndexBinding;
var VertexBinding = (function () {
    function VertexBinding() {
    }
    return VertexBinding;
}());
exports.VertexBinding = VertexBinding;
var GLTFPrimitive = (function (_super) {
    __extends(GLTFPrimitive, _super);
    function GLTFPrimitive(context, bindings, indexBinding, drawMode, material, flags, identifier) {
        var _this = _super.call(this, context, identifier) || this;
        _this._bindings = bindings;
        _this._indexBinding = indexBinding;
        _this._material = material;
        _this._geometryFlags = flags;
        _this._drawMode = drawMode;
        return _this;
    }
    GLTFPrimitive.prototype.bindBuffers = function () {
        if (this._indexBinding) {
            this._indexBinding.buffer.bind();
        }
        for (var _i = 0, _a = this._bindings; _i < _a.length; _i++) {
            var vertexBinding = _a[_i];
            vertexBinding.buffer.attribEnable(vertexBinding.attributeIndex, vertexBinding.size, vertexBinding.type, vertexBinding.normalized, vertexBinding.stride, vertexBinding.offset, true, true);
        }
    };
    GLTFPrimitive.prototype.unbindBuffers = function () {
        if (this._indexBinding) {
            this._indexBinding.buffer.unbind();
        }
        for (var _i = 0, _a = this._bindings; _i < _a.length; _i++) {
            var vertexBinding = _a[_i];
            vertexBinding.buffer.attribDisable(vertexBinding.attributeIndex, true, true);
        }
    };
    GLTFPrimitive.prototype.draw = function () {
        var gl = this.context.gl;
        if (this._indexBinding) {
            gl.drawElements(this._drawMode, this._indexBinding.numIndices, this._indexBinding.type, this._indexBinding.offset);
        }
        else {
            gl.drawArrays(this._drawMode, 0, this._bindings[0].numVertices);
        }
    };
    Object.defineProperty(GLTFPrimitive.prototype, "material", {
        get: function () {
            return this._material;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GLTFPrimitive.prototype, "flags", {
        get: function () {
            return this._geometryFlags;
        },
        enumerable: true,
        configurable: true
    });
    return GLTFPrimitive;
}(geometry_1.Geometry));
exports.GLTFPrimitive = GLTFPrimitive;


/***/ }),

/***/ "./gltf/index.ts":
/*!***********************!*\
  !*** ./gltf/index.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var gltfloader_1 = __webpack_require__(/*! ./gltfloader */ "./gltf/gltfloader.ts");
exports.GLTFLoader = gltfloader_1.GLTFLoader;
var gltfpbrmaterial_1 = __webpack_require__(/*! ./gltfpbrmaterial */ "./gltf/gltfpbrmaterial.ts");
exports.GLTFAlphaMode = gltfpbrmaterial_1.GLTFAlphaMode;
exports.GLTFPbrMaterial = gltfpbrmaterial_1.GLTFPbrMaterial;
exports.GLTFShaderFlags = gltfpbrmaterial_1.GLTFShaderFlags;
var gltfprimitive_1 = __webpack_require__(/*! ./gltfprimitive */ "./gltf/gltfprimitive.ts");
exports.GLTFPrimitive = gltfprimitive_1.GLTFPrimitive;
var gltfmesh_1 = __webpack_require__(/*! ./gltfmesh */ "./gltf/gltfmesh.ts");
exports.GLTFMesh = gltfmesh_1.GLTFMesh;


/***/ }),

/***/ "./gltf/shaders/gltf_default.frag":
/*!****************************************!*\
  !*** ./gltf/shaders/gltf_default.frag ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision highp float;\n\n// Adapted from https://github.com/KhronosGroup/glTF-WebGL-PBR\n// References:\n// [1] Real Shading in Unreal Engine 4\n//     http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n// [2] Physically Based Shading at Disney\n//     http://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf\n// [3] README.md - Environment Maps\n//     https://github.com/KhronosGroup/glTF-WebGL-PBR/#environment-maps\n// [4] \"An Inexpensive BRDF Model for Physically based Rendering\" by Christophe Schlick\n//     https://www.cs.virginia.edu/~jdl/bib/appearance/analytic%20models/schlick94b.pdf\n\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else \n    #define varying in\n#endif\n\n\n#if __VERSION__ == 100\n    #define fragColor gl_FragColor\n#else\n    layout(location = 0) out vec4 fragColor;\n#endif\n\nconst int HAS_NORMALS           = 1;\nconst int HAS_TANGENTS          = 1 << 1;\nconst int HAS_UV                = 1 << 2;\nconst int HAS_COLORS            = 1 << 3;\nconst int USE_IBL               = 1 << 4;\nconst int HAS_BASECOLORMAP      = 1 << 5;\nconst int HAS_NORMALMAP         = 1 << 6;\nconst int HAS_EMISSIVEMAP       = 1 << 7;\nconst int HAS_METALROUGHNESSMAP = 1 << 8;\nconst int HAS_OCCLUSIONMAP      = 1 << 9;\nconst int USE_TEX_LOD           = 1 << 10;\n\nconst vec3 u_LightDirection = vec3(0.2, 1.0, 0.2);\nconst vec3 u_LightColor = vec3(1, 1, 1);\n\nconst float M_PI = 3.141592653589793;\nconst float c_MinRoughness = 0.04;\n\nuniform sampler2D u_baseColor;\nuniform sampler2D u_metallicRoughness;\nuniform sampler2D u_normal;\nuniform sampler2D u_emissive;\nuniform sampler2D u_occlusion;\n\nuniform samplerCube u_specularEnvironment;\nuniform sampler2D u_brdfLUT;\n\nuniform int u_baseColorTexCoord;\nuniform int u_normalTexCoord;\nuniform int u_metallicRoughnessTexCoord;\nuniform int u_occlusionTexCoord;\nuniform int u_emissiveTexCoord;\n\nuniform vec4 u_baseColorFactor;\nuniform float u_metallicFactor;\nuniform float u_roughnessFactor;\nuniform vec3 u_emissiveFactor;\nuniform float u_normalScale;\nuniform int u_blendMode;\nuniform float u_blendCutoff;\n\nuniform mediump int u_geometryFlags;\nuniform mediump int u_pbrFlags;\nuniform vec3 u_eye;\n\nvarying vec2 v_uv[3];\nvarying vec4 v_color;\nvarying vec3 v_position;\n\nvarying mat3 v_TBN;\nvarying vec3 v_normal;\n\n// Encapsulate the various inputs used by the various functions in the shading equation\n// We store values in this struct to simplify the integration of alternative implementations\n// of the shading terms, outlined in the Readme.MD Appendix.\nstruct PBRInfo\n{\n    float NdotL;                  // cos angle between normal and light direction\n    float NdotV;                  // cos angle between normal and view direction\n    float NdotH;                  // cos angle between normal and half vector\n    float LdotH;                  // cos angle between light direction and half vector\n    float VdotH;                  // cos angle between view direction and half vector\n    float perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)\n    float metalness;              // metallic value at the surface\n    vec3 reflectance0;            // full reflectance color (normal incidence angle)\n    vec3 reflectance90;           // reflectance color at grazing angle\n    float alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])\n    vec3 diffuseColor;            // color contribution from diffuse lighting\n    vec3 specularColor;           // color contribution from specular lighting\n};\n\nbool checkGeometryFlag(int flag) {\n    return (u_geometryFlags & flag) == flag;\n}\n\nbool checkFlag(int flag) {\n    return (u_pbrFlags & flag) == flag;\n}\n\nvec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n    #ifdef MANUAL_SRGB\n    #ifdef SRGB_FAST_APPROXIMATION\n    vec3 linOut = pow(srgbIn.xyz,vec3(2.2));\n    #else //SRGB_FAST_APPROXIMATION\n    vec3 bLess = step(vec3(0.04045),srgbIn.xyz);\n    vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );\n    #endif //SRGB_FAST_APPROXIMATION\n    return vec4(linOut,srgbIn.w);;\n    #else //MANUAL_SRGB\n    return srgbIn;\n    #endif //MANUAL_SRGB\n}\n\n// Find the normal for this fragment, pulling either from a predefined normal map\n// or from the interpolated mesh normal and tangent attributes.\nvec3 getNormal()\n{\n    // Retrieve the tangent space matrix\n    mat3 tbn;\n    if (!checkGeometryFlag(HAS_TANGENTS)) {\n        vec3 pos_dx = dFdx(v_position);\n        vec3 pos_dy = dFdy(v_position);\n        vec3 tex_dx = dFdx(vec3(v_uv[0], 0.0));\n        vec3 tex_dy = dFdy(vec3(v_uv[0], 0.0));\n        vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n        vec3 ng;\n        if (checkGeometryFlag(HAS_NORMALS))\n            ng = normalize(v_normal);\n        else\n            ng = cross(pos_dx, pos_dy);\n\n            t = normalize(t - ng * dot(ng, t));\n            vec3 b = normalize(cross(ng, t));\n            tbn = mat3(t, b, ng);\n        }\n    else { // HAS_TANGENTS\n        tbn = v_TBN;\n    }\n\n    vec3 n;\n    if (checkFlag(HAS_NORMALMAP)) {\n        n = texture(u_normal, v_uv[u_normalTexCoord]).rgb;\n        n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_normalScale, u_normalScale, 1.0)));\n    } else {\n        // The tbn matrix is linearly interpolated, so we need to re-normalize\n        n = normalize(tbn[2].xyz);\n    }\n\n    // reverse backface normals\n    n *= (2.0 * float(gl_FrontFacing) - 1.0);\n\n    return n;\n}\n\n// Basic Lambertian diffuse\n// Implementation from Lambert's Photometria https://archive.org/details/lambertsphotome00lambgoog\n// See also [1], Equation 1\nvec3 diffuse(PBRInfo pbrInputs)\n{\n    return pbrInputs.diffuseColor / M_PI;\n}\n\n // The following equation models the Fresnel reflectance term of the spec equation (aka F())\n// Implementation of fresnel from [4], Equation 15\nvec3 specularReflection(PBRInfo pbrInputs)\n{\n    return pbrInputs.reflectance0 + (pbrInputs.reflectance90 - pbrInputs.reflectance0) * pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);\n}\n\n // This calculates the specular geometric attenuation (aka G()),\n// where rougher material will reflect less light back to the viewer.\n// This implementation is based on [1] Equation 4, and we adopt their modifications to\n// alphaRoughness as input as originally proposed in [2].\nfloat geometricOcclusion(PBRInfo pbrInputs)\n{\n    float NdotL = pbrInputs.NdotL;\n    float NdotV = pbrInputs.NdotV;\n    float r = pbrInputs.alphaRoughness;\n\n    float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));\n    float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));\n    return attenuationL * attenuationV;\n}\n\n // The following equation(s) model the distribution of microfacet normals across the area being drawn (aka D())\n// Implementation from \"Average Irregularity Representation of a Roughened Surface for Ray Reflection\" by T. S. Trowbridge, and K. P. Reitz\n// Follows the distribution function recommended in the SIGGRAPH 2013 course notes from EPIC Games [1], Equation 3.\nfloat microfacetDistribution(PBRInfo pbrInputs)\n{\n    float roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;\n    float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;\n    return roughnessSq / (M_PI * f * f);\n}\n\nvec3 getIBLContribution(vec3 n, vec3 v, PBRInfo pbrInfo)\n{\n    float NdotV = clamp(dot(n, v), 0.0, 1.0);\n\n    // TODO: pass uniform for mip count\n    const float MIP_COUNT = 8.0;\n    float lod = clamp(pbrInfo.perceptualRoughness * MIP_COUNT, 0.0, MIP_COUNT);\n    vec3 reflection = normalize(reflect(-v, n));\n\n    vec2 brdfSamplePoint = vec2(NdotV, pbrInfo.perceptualRoughness);\n    vec2 brdf = texture(u_brdfLUT, brdfSamplePoint).rg;\n\n    // vec4 diffuseSample = textureCube(u_DiffuseEnvSampler, n);\n    vec4 specularSample = textureLod(u_specularEnvironment, reflection, lod);\n\n    // vec3 diffuseLight = SRGBtoLINEAR(diffuseSample).rgb;\n    vec3 specularLight = SRGBtoLINEAR(specularSample).rgb;\n\n    // vec3 diffuse = diffuseLight * pbrInfo.diffuseColor;\n    vec3 specular = specularLight * (pbrInfo.specularColor * brdf.x + brdf.y);\n\n    return specular;\n    // return diffuse + specular;\n}\n\nvoid main(void)\n{\n    float perceptualRoughness = u_roughnessFactor;\n    float metallic = u_metallicFactor;\n    if (checkFlag(HAS_METALROUGHNESSMAP)) {\n        // Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.\n        // This layout intentionally reserves the 'r' channel for (optional) occlusion map data\n        vec4 mrSample = texture(u_metallicRoughness, v_uv[u_metallicRoughnessTexCoord]);\n        perceptualRoughness = mrSample.g * perceptualRoughness;\n        metallic = mrSample.b * metallic;\n    }\n    perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);\n    metallic = clamp(metallic, 0.0, 1.0);\n    // Roughness is authored as perceptual roughness; as is convention,\n    // convert to material roughness by squaring the perceptual roughness [2].\n    float alphaRoughness = perceptualRoughness * perceptualRoughness;\n\n     // The albedo may be defined from a base texture or a flat color\n    vec4 baseColor;\n    if (checkFlag(HAS_BASECOLORMAP)) {\n        baseColor = SRGBtoLINEAR(texture(u_baseColor, v_uv[u_baseColorTexCoord])) * u_baseColorFactor;\n    } else {\n        baseColor = u_baseColorFactor;\n    }\n\n    // spec: COLOR_0 ... acts as an additional linear multiplier to baseColor\n    // TODO!: distinguish vec3/vec4 colors...\n    baseColor *= vec4(v_color.rgb, 1.0);\n\n    vec3 f0 = vec3(0.04);\n    vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);\n    diffuseColor *= 1.0 - metallic;\n    vec3 specularColor = mix(f0, baseColor.rgb, metallic);\n\n    // Compute reflectance.\n    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n\n    // For typical incident reflectance range (between 4% to 100%) set the grazing reflectance to 100% for typical fresnel effect.\n    // For very low reflectance range on highly diffuse objects (below 4%), incrementally reduce grazing reflecance to 0%.\n    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);\n    vec3 specularEnvironmentR0 = specularColor.rgb;\n    vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;\n\n    vec3 n = getNormal();                         // normal at surface point\n    vec3 v = normalize(u_eye - v_position);        // Vector from surface point to camera\n    vec3 l = normalize(u_LightDirection);          // Vector from surface point to light\n    vec3 h = normalize(l+v);                       // Half vector between both l and v\n    vec3 reflection = -normalize(reflect(v, n));\n\n    float NdotL = clamp(dot(n, l), 0.001, 1.0);\n    float NdotV = abs(dot(n, v)) + 0.001;\n    float NdotH = clamp(dot(n, h), 0.0, 1.0);\n    float LdotH = clamp(dot(l, h), 0.0, 1.0);\n    float VdotH = clamp(dot(v, h), 0.0, 1.0);\n\n    PBRInfo pbrInputs = PBRInfo(\n        NdotL,\n        NdotV,\n        NdotH,\n        LdotH,\n        VdotH,\n        perceptualRoughness,\n        metallic,\n        specularEnvironmentR0,\n        specularEnvironmentR90,\n        alphaRoughness,\n        diffuseColor,\n        specularColor\n    );\n\n     // Calculate the shading terms for the microfacet specular shading model\n    vec3 F = specularReflection(pbrInputs);\n    float G = geometricOcclusion(pbrInputs);\n    float D = microfacetDistribution(pbrInputs);\n\n     // Calculation of analytical lighting contribution\n    vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);\n    vec3 specContrib = F * G * D / (4.0 * NdotL * NdotV);\n    // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)\n    vec3 color = NdotL * u_LightColor * (diffuseContrib + specContrib);\n\n    vec3 environmentLight = getIBLContribution(n, v, pbrInputs);\n    color += environmentLight;\n\n    if (checkFlag(HAS_EMISSIVEMAP)) {\n        vec3 emissive = SRGBtoLINEAR(texture(u_emissive, v_uv[u_emissiveTexCoord])).rgb * u_emissiveFactor;\n        color += emissive;\n    }\n\n    // NOTE: the spec mandates to ignore any alpha value in 'OPAQUE' mode\n    float alpha = 1.0;\n    if (u_blendMode == 1) {\n        if (baseColor.a < u_blendCutoff) {\n            discard;\n        }\n    }\n    else if (u_blendMode == 2) {\n        alpha = baseColor.a;\n    }\n\n    fragColor = vec4(pow(color, vec3(1.0/2.2)), alpha);\n}\n"

/***/ }),

/***/ "./gltf/shaders/gltf_default.vert":
/*!****************************************!*\
  !*** ./gltf/shaders/gltf_default.vert ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision highp float;\n\n// Adapted from https://github.com/KhronosGroup/glTF-WebGL-PBR\n\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else\n    #define varying out\n#endif\n\n\nconst int HAS_NORMALS           = 1;\nconst int HAS_TANGENTS          = 1 << 1;\nconst int HAS_UV                = 1 << 2;\nconst int HAS_COLORS            = 1 << 3;\n\n#if __VERSION__ == 100\n    attribute vec4 a_position;\n    attribute vec4 a_normal;\n    attribute vec4 a_tangent;\n    attribute vec2 a_texcoord_0;\n    attribute vec2 a_texcoord_1;\n    attribute vec2 a_texcoord_2;\n    attribute vec4 a_joints;\n    attribute vec4 a_weights;\n    attribute vec4 a_color;\n#else\n    layout (location = 0) in vec4 a_position;\n    layout (location = 1) in vec3 a_normal;\n    layout (location = 2) in vec4 a_tangent;\n    layout (location = 3) in vec2 a_texcoord_0;\n    layout (location = 4) in vec2 a_texcoord_1;\n    layout (location = 5) in vec2 a_texcoord_2;\n    layout (location = 6) in vec4 a_joints;\n    layout (location = 7) in vec4 a_weights;\n    layout (location = 8) in vec4 a_color;\n#endif\n\nuniform mat4 u_model;\nuniform mat4 u_viewProjection;\nuniform mat3 u_normalMatrix;\n\nuniform mediump int u_geometryFlags;\n\nvarying vec2 v_uv[3];\nvarying vec4 v_color;\nvarying vec3 v_position;\n\nvarying mat3 v_TBN;\nvarying vec3 v_normal;\n\nbool checkFlag(int flag) {\n    return (u_geometryFlags & flag) == flag;\n}\n\nvoid main(void)\n{\n    vec4 pos = u_model * a_position;\n    v_position = vec3(pos.xyz) / pos.w;\n\n    if (checkFlag(HAS_NORMALS)) {\n        if (checkFlag(HAS_TANGENTS)) {\n            vec3 normalW = normalize(vec3(u_normalMatrix * a_normal));\n            vec3 tangentW = normalize(vec3(u_model * vec4(a_tangent.xyz, 0.0)));\n            vec3 bitangentW = cross(normalW, tangentW) * a_tangent.w;\n            v_TBN = mat3(tangentW, bitangentW, normalW);\n        } else { // HAS_TANGENTS != 1\n            v_normal = normalize(vec3(u_model * vec4(a_normal.xyz, 0.0)));\n        }\n    }\n\n    if (checkFlag(HAS_UV)) {\n        v_uv[0] = a_texcoord_0;\n        v_uv[1] = a_texcoord_1;\n        v_uv[2] = a_texcoord_2;\n    } else {\n        v_uv[0] = vec2(0., 0.);\n        v_uv[1] = vec2(0., 0.);\n        v_uv[2] = vec2(0., 0.);\n    }\n\n    if (checkFlag(HAS_COLORS)) {\n        v_color = a_color;\n    } else {\n        v_color = vec4(1.0);\n    }\n\n    gl_Position = u_viewProjection * u_model * a_position;\n}\n"

/***/ }),

/***/ "./initializable.ts":
/*!**************************!*\
  !*** ./initializable.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var Initializable = (function () {
    function Initializable() {
        var _this = this;
        this._initialized = false;
        this.assertInitialized = function () { return Initializable.assertInitializedFalse(_this); };
        this.assertUninitialized = function () { return undefined; };
    }
    Initializable.initialize = function () {
        return function (target, propertyKey, descriptor) {
            var initialize = descriptor.value;
            descriptor.value = function () {
                var _this = this;
                auxiliaries_1.assert(this._initialized === false, "re-initialization of initialized object not anticipated");
                this._initialized = initialize.apply(this, arguments);
                if (this._initialized) {
                    this.assertInitialized = function () { return undefined; };
                    this.assertUninitialized = function () { return Initializable.assertUninitializedFalse(_this); };
                }
                else {
                    this.assertUninitialized = function () { return undefined; };
                    this.assertInitialized = function () { return Initializable.assertInitializedFalse(_this); };
                }
                return this._initialized;
            };
            return descriptor;
        };
    };
    Initializable.uninitialize = function () {
        return function (target, propertyKey, descriptor) {
            var uninitialize = descriptor.value;
            descriptor.value = function () {
                var _this = this;
                auxiliaries_1.assert(this._initialized === true, "expected object to be initialized in order to uninitialize");
                uninitialize.apply(this);
                this._initialized = false;
                this.assertUninitialized = function () { return undefined; };
                this.assertInitialized = function () { return Initializable.assertInitializedFalse(_this); };
            };
            return descriptor;
        };
    };
    Initializable.assert_initialized = function () {
        return function (target, propertyKey, descriptor) {
            var initialize = descriptor.value;
            descriptor.value = function () {
                this.assertInitialized();
                return initialize.apply(this, arguments);
            };
            return descriptor;
        };
    };
    Initializable.assert_uninitialized = function () {
        return function (target, propertyKey, descriptor) {
            var initialize = descriptor.value;
            descriptor.value = function () {
                this.assertUninitialized();
                initialize.apply(this, arguments);
            };
            return descriptor;
        };
    };
    Object.defineProperty(Initializable.prototype, "initialized", {
        get: function () {
            return this._initialized;
        },
        enumerable: true,
        configurable: true
    });
    Initializable.assertInitializedFalse = function (object) {
        return auxiliaries_1.assert(false, "instance of " + object.constructor.name + " expected to be initialized");
    };
    Initializable.assertUninitializedFalse = function (object) {
        return auxiliaries_1.assert(false, "instance of " + object.constructor.name + " not expected to be initialized");
    };
    return Initializable;
}());
exports.Initializable = Initializable;


/***/ }),

/***/ "./kernel.ts":
/*!*******************!*\
  !*** ./kernel.ts ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var AbstractKernel = (function () {
    function AbstractKernel(components, width, height, depth) {
        if (height === void 0) { height = 1; }
        if (depth === void 0) { depth = 1; }
        this._components = components;
        this._width = isNaN(width) ? 1 : Math.max(1, width);
        this._height = Math.max(1, height);
        this._depth = Math.max(1, depth);
        this.resize();
    }
    AbstractKernel.prototype.get = function (xPosOrIndex, yPos, zPos) {
        var i;
        if (yPos === undefined && zPos === undefined) {
            i = this._components * xPosOrIndex;
        }
        else {
            i = this.index(xPosOrIndex, yPos, zPos ? zPos : 0);
        }
        auxiliaries_1.assert(i < this.length, "index expected to be in range [0, " + (this.length - 1) + "], given " + i);
        switch (this._components) {
            case 1:
                return [this._samples[i]];
            case 2:
                return [this._samples[i], this._samples[i + 1]];
            case 3:
                return [this._samples[i], this._samples[i + 1], this._samples[i + 2]];
            case 4:
                return [this._samples[i], this._samples[i + 1], this._samples[i + 2], this._samples[i + 3]];
        }
    };
    AbstractKernel.prototype.set = function (sample, xPosOrIndex, yPos, zPos) {
        auxiliaries_1.assert(sample.length === this._components, "number of components expected to be " + this._components + ", given " + sample.length);
        var i;
        if (yPos === undefined && zPos === undefined) {
            i = this._components * Math.min(this.elements, Math.max(0, xPosOrIndex));
        }
        else {
            i = this._components * this.index(xPosOrIndex, yPos, zPos ? zPos : 0);
        }
        auxiliaries_1.assert(i < this.length, "index expected to be in range [0, " + (this.length - 1) + "], given " + i);
        switch (this._components) {
            case 4:
                this._samples[i + 3] = sample[3];
            case 3:
                this._samples[i + 2] = sample[2];
            case 2:
                this._samples[i + 1] = sample[1];
            case 1:
                this._samples[i + 0] = sample[0];
                break;
        }
    };
    AbstractKernel.prototype.fromJSON = function (json) {
        auxiliaries_1.assert(json.size && json.size.width !== undefined && json.size.height !== undefined &&
            json.size.depth !== undefined, "expected kernel width, height, and depth to be set, given '" + json.size + "'");
        var flatten = function (array) { return array.reduce(function (a, b) { return a.concat(Array.isArray(b) ? flatten(b) : b); }, []); };
        this._width = Math.max(1, json.size.width);
        this._height = Math.max(1, json.size.height);
        this._depth = Math.max(1, json.size.depth);
        var array = flatten(json.kernel);
        this._components = Math.floor(array.length / this.elements);
        this.resize();
        this.fromArray(array);
    };
    AbstractKernel.prototype.index = function (xPos, yPos, zPos) {
        if (yPos === void 0) { yPos = 0; }
        if (zPos === void 0) { zPos = 0; }
        return this._width * (this._height * Math.min(this._depth, Math.max(0, zPos))
            + Math.min(this._height, Math.max(0, yPos))) + Math.min(this._width, Math.max(0, xPos));
    };
    AbstractKernel.prototype.position = function (index) {
        var clamped = Math.min(this.elements, Math.max(0, index));
        var zPos = Math.floor(clamped / (this._width * this._height));
        clamped -= zPos * this._width * this._height;
        var yPos = Math.floor(clamped / this._width);
        clamped -= yPos * this._width;
        var xPos = clamped;
        return [xPos, yPos, zPos];
    };
    AbstractKernel.prototype.sort = function (approach) {
        if (this.elements < 2) {
            return;
        }
        var tuples = Array(this.elements);
        for (var i = 0; i < this.elements; ++i) {
            var value = 0.0;
            switch (approach) {
                default:
                case AbstractKernel.SortApproach.BySquaredLength:
                    for (var c = 0; c < this._components; ++c) {
                        var v = this._samples[i * this._components + c];
                        value += v * v;
                    }
                    break;
            }
            tuples[i] = [i, value];
        }
        switch (approach) {
            default:
            case AbstractKernel.SortApproach.BySquaredLength:
                tuples.sort(function (a, b) { return a[1] - b[1]; });
                break;
        }
        var source = this._samples.slice();
        for (var i = 0; i < tuples.length; ++i) {
            for (var c = 0; c < this._components; ++c) {
                var iSource = tuples[i][0] * this._components + c;
                var iTarget = i * this._components + c;
                this._samples[iTarget] = source[iSource];
            }
        }
    };
    Object.defineProperty(AbstractKernel.prototype, "samples", {
        get: function () {
            return this._samples;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractKernel.prototype, "length", {
        get: function () {
            return this._width * this._height * this._depth * this._components;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractKernel.prototype, "elements", {
        get: function () {
            var elementCount = this._width * this._height * this._depth;
            return isNaN(elementCount) ? 0 : elementCount;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractKernel.prototype, "components", {
        get: function () {
            return this._components;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractKernel.prototype, "width", {
        get: function () {
            return this._width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractKernel.prototype, "height", {
        get: function () {
            return this._height;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractKernel.prototype, "depth", {
        get: function () {
            return this._depth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractKernel.prototype, "xStride", {
        get: function () {
            return this.bytesPerComponent * this._components;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractKernel.prototype, "yStride", {
        get: function () {
            return this.bytesPerComponent * this._components * this._width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractKernel.prototype, "zStride", {
        get: function () {
            return this.bytesPerComponent * this._components * this._width * this._depth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractKernel.prototype, "bytesLength", {
        get: function () {
            return this.bytesPerComponent * this._components * this._width * this._height * this._depth;
        },
        enumerable: true,
        configurable: true
    });
    return AbstractKernel;
}());
exports.AbstractKernel = AbstractKernel;
(function (AbstractKernel) {
    var SortApproach;
    (function (SortApproach) {
        SortApproach[SortApproach["BySquaredLength"] = 0] = "BySquaredLength";
    })(SortApproach = AbstractKernel.SortApproach || (AbstractKernel.SortApproach = {}));
})(AbstractKernel = exports.AbstractKernel || (exports.AbstractKernel = {}));
exports.AbstractKernel = AbstractKernel;
var KernelF32 = (function (_super) {
    __extends(KernelF32, _super);
    function KernelF32() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    KernelF32.prototype.resize = function () {
        this._samples = new Float32Array(this.length);
    };
    KernelF32.prototype.fromArray = function (samples) {
        auxiliaries_1.assert(samples.length === this.length, "expected samples length to match this kernel's length");
        this._samples.set(new Float32Array(samples));
    };
    Object.defineProperty(KernelF32.prototype, "bytesPerComponent", {
        get: function () {
            return 4;
        },
        enumerable: true,
        configurable: true
    });
    return KernelF32;
}(AbstractKernel));
exports.KernelF32 = KernelF32;
var KernelUI32 = (function (_super) {
    __extends(KernelUI32, _super);
    function KernelUI32() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    KernelUI32.prototype.resize = function () {
        this._samples = new Uint32Array(this.length);
    };
    KernelUI32.prototype.fromArray = function (samples) {
        auxiliaries_1.assert(samples.length === this.length, "expected samples length to match this kernel's length");
        this._samples.set(new Uint32Array(samples));
    };
    Object.defineProperty(KernelUI32.prototype, "bytesPerComponent", {
        get: function () {
            return 4;
        },
        enumerable: true,
        configurable: true
    });
    return KernelUI32;
}(AbstractKernel));
exports.KernelUI32 = KernelUI32;
var KernelI32 = (function (_super) {
    __extends(KernelI32, _super);
    function KernelI32() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    KernelI32.prototype.resize = function () {
        this._samples = new Int32Array(this.length);
    };
    KernelI32.prototype.fromArray = function (samples) {
        auxiliaries_1.assert(samples.length === this.length, "expected samples length to match this kernel's length");
        this._samples.set(new Int32Array(samples));
    };
    Object.defineProperty(KernelI32.prototype, "bytesPerComponent", {
        get: function () {
            return 4;
        },
        enumerable: true,
        configurable: true
    });
    return KernelI32;
}(AbstractKernel));
exports.KernelI32 = KernelI32;
var KernelUI8 = (function (_super) {
    __extends(KernelUI8, _super);
    function KernelUI8() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    KernelUI8.prototype.resize = function () {
        this._samples = new Uint8Array(this.length);
    };
    KernelUI8.prototype.fromArray = function (samples) {
        auxiliaries_1.assert(samples.length === this.length, "expected samples length to match this kernel's length");
        this._samples.set(new Uint8Array(samples));
    };
    Object.defineProperty(KernelUI8.prototype, "bytesPerComponent", {
        get: function () {
            return 4;
        },
        enumerable: true,
        configurable: true
    });
    return KernelUI8;
}(AbstractKernel));
exports.KernelUI8 = KernelUI8;
var KernelI8 = (function (_super) {
    __extends(KernelI8, _super);
    function KernelI8() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    KernelI8.prototype.resize = function () {
        this._samples = new Int8Array(this.length);
    };
    KernelI8.prototype.fromArray = function (samples) {
        auxiliaries_1.assert(samples.length === this.length, "expected samples length to match this kernel's length");
        this._samples.set(new Int8Array(samples));
    };
    Object.defineProperty(KernelI8.prototype, "bytesPerComponent", {
        get: function () {
            return 4;
        },
        enumerable: true,
        configurable: true
    });
    return KernelI8;
}(AbstractKernel));
exports.KernelI8 = KernelI8;


/***/ }),

/***/ "./mouseeventprovider.ts":
/*!*******************************!*\
  !*** ./mouseeventprovider.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var rxjs_1 = __webpack_require__(/*! rxjs */ "rxjs");
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var msagent_1 = __webpack_require__(/*! ./msagent */ "./msagent.ts");
var pointerlock_1 = __webpack_require__(/*! ./pointerlock */ "./pointerlock.ts");
var MouseEventProvider = (function () {
    function MouseEventProvider(element, timeframe) {
        var _this = this;
        this._pointerLockRequestPending = false;
        auxiliaries_1.assert(element !== undefined, "expected valid canvas element on initialization, given " + element);
        this._element = element;
        this._timeframe = timeframe;
        this._element.addEventListener('click', function () { return _this.processPointerLockRequests(); });
        if (msagent_1.IS_EDGE || msagent_1.IS_IE11) {
            this._element.addEventListener('dragstart', function (event) { return event.preventDefault(); });
        }
    }
    MouseEventProvider.prototype.processPointerLockRequests = function () {
        if (!this._pointerLockRequestPending) {
            return;
        }
        pointerlock_1.PointerLock.request(this._element);
    };
    MouseEventProvider.prototype.preventDefaultOnEvent = function (type, event) {
        if (auxiliaries_1.bitInBitfield(this._preventDefaultMask, type)) {
            event.preventDefault();
        }
    };
    MouseEventProvider.prototype.preventDefault = function () {
        var types = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            types[_i] = arguments[_i];
        }
        for (var _a = 0, types_1 = types; _a < types_1.length; _a++) {
            var type = types_1[_a];
            if (!auxiliaries_1.bitInBitfield(this._preventDefaultMask, type)) {
                this._preventDefaultMask |= type;
            }
        }
    };
    MouseEventProvider.prototype.allowDefault = function () {
        var types = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            types[_i] = arguments[_i];
        }
        for (var _a = 0, types_2 = types; _a < types_2.length; _a++) {
            var type = types_2[_a];
            if (auxiliaries_1.bitInBitfield(this._preventDefaultMask, type)) {
                this._preventDefaultMask &= ~type;
            }
        }
    };
    MouseEventProvider.prototype.observable = function (type) {
        switch (type) {
            case MouseEventProvider.Type.Click:
                return this.click$;
            case MouseEventProvider.Type.Enter:
                return this.enter$;
            case MouseEventProvider.Type.Leave:
                return this.leave$;
            case MouseEventProvider.Type.Down:
                return this.down$;
            case MouseEventProvider.Type.Up:
                return this.up$;
            case MouseEventProvider.Type.Move:
                return this.move$;
            case MouseEventProvider.Type.Wheel:
                return this.wheel$;
            case MouseEventProvider.Type.Drag:
                return this.drag$;
            default:
                return undefined;
        }
    };
    Object.defineProperty(MouseEventProvider.prototype, "pointerLock", {
        get: function () {
            return pointerlock_1.PointerLock.active(this._element);
        },
        set: function (lock) {
            this._pointerLockRequestPending = lock;
            if (lock === false) {
                this._pointerLockRequestPending = false;
                pointerlock_1.PointerLock.exit();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseEventProvider.prototype, "click$", {
        get: function () {
            var _this = this;
            if (this._clickSubject === undefined) {
                this._clickSubject = new rxjs_1.ReplaySubject(undefined, this._timeframe);
                this._clickListener = function (event) {
                    _this.preventDefaultOnEvent(MouseEventProvider.Type.Click, event);
                    _this._clickSubject.next(event);
                };
                this._element.addEventListener('click', this._clickListener);
            }
            return this._clickSubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseEventProvider.prototype, "enter$", {
        get: function () {
            var _this = this;
            if (this._enterSubject === undefined) {
                this._enterSubject = new rxjs_1.ReplaySubject(undefined, this._timeframe);
                this._enterListener = function (event) {
                    _this.preventDefaultOnEvent(MouseEventProvider.Type.Enter, event);
                    _this._enterSubject.next(event);
                };
                this._element.addEventListener('mouseenter', this._enterListener);
            }
            return this._enterSubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseEventProvider.prototype, "leave$", {
        get: function () {
            var _this = this;
            if (this._leaveSubject === undefined) {
                this._leaveSubject = new rxjs_1.ReplaySubject(undefined, this._timeframe);
                this._leaveListener = function (event) {
                    _this.preventDefaultOnEvent(MouseEventProvider.Type.Leave, event);
                    _this._leaveSubject.next(event);
                };
                this._element.addEventListener('mouseleave', this._leaveListener);
            }
            return this._leaveSubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseEventProvider.prototype, "down$", {
        get: function () {
            var _this = this;
            if (this._downSubject === undefined) {
                this._downSubject = new rxjs_1.ReplaySubject(undefined, this._timeframe);
                this._downListener = function (event) {
                    _this.preventDefaultOnEvent(MouseEventProvider.Type.Down, event);
                    _this._downSubject.next(event);
                };
                this._element.addEventListener('mousedown', this._downListener);
            }
            return this._downSubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseEventProvider.prototype, "up$", {
        get: function () {
            var _this = this;
            if (this._upSubject === undefined) {
                this._upSubject = new rxjs_1.ReplaySubject(undefined, this._timeframe);
                this._upListener = function (event) {
                    _this.preventDefaultOnEvent(MouseEventProvider.Type.Up, event);
                    _this._upSubject.next(event);
                };
                this._element.addEventListener('mouseup', this._upListener);
            }
            return this._upSubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseEventProvider.prototype, "move$", {
        get: function () {
            var _this = this;
            if (this._moveSubject === undefined) {
                this._moveSubject = new rxjs_1.ReplaySubject(undefined, this._timeframe);
                this._moveListener = function (event) {
                    _this.preventDefaultOnEvent(MouseEventProvider.Type.Move, event);
                    _this._moveSubject.next(event);
                };
                this._element.addEventListener('mousemove', this._moveListener);
            }
            return this._moveSubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseEventProvider.prototype, "wheel$", {
        get: function () {
            var _this = this;
            if (this._wheelSubject === undefined) {
                this._wheelSubject = new rxjs_1.ReplaySubject(undefined, this._timeframe);
                this._wheelListener = function (event) {
                    _this.preventDefaultOnEvent(MouseEventProvider.Type.Wheel, event);
                    _this._wheelSubject.next(event);
                };
                this._element.addEventListener('wheel', this._wheelListener);
            }
            return this._wheelSubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseEventProvider.prototype, "drag$", {
        get: function () {
            var _this = this;
            if (this._dragSubject === undefined) {
                this._dragSubject = new rxjs_1.ReplaySubject(undefined, this._timeframe);
                this._dragListener = function (event) {
                    _this.preventDefaultOnEvent(MouseEventProvider.Type.Drag, event);
                    _this._dragSubject.next(event);
                };
                this._element.addEventListener('drag', this._dragListener);
            }
            return this._dragSubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    return MouseEventProvider;
}());
exports.MouseEventProvider = MouseEventProvider;
(function (MouseEventProvider) {
    var Type;
    (function (Type) {
        Type[Type["Click"] = 1] = "Click";
        Type[Type["Wheel"] = 2] = "Wheel";
        Type[Type["Enter"] = 4] = "Enter";
        Type[Type["Leave"] = 8] = "Leave";
        Type[Type["Move"] = 16] = "Move";
        Type[Type["Down"] = 32] = "Down";
        Type[Type["Up"] = 64] = "Up";
        Type[Type["Drag"] = 128] = "Drag";
    })(Type = MouseEventProvider.Type || (MouseEventProvider.Type = {}));
})(MouseEventProvider = exports.MouseEventProvider || (exports.MouseEventProvider = {}));
exports.MouseEventProvider = MouseEventProvider;


/***/ }),

/***/ "./msagent.ts":
/*!********************!*\
  !*** ./msagent.ts ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.IS_IE11 = typeof navigator === 'undefined' ?
    undefined : /MSIE 11|Windows/i.test(navigator.userAgent);
exports.IS_EDGE = typeof navigator === 'undefined' ?
    undefined : /Edge\/\d./i.test(navigator.userAgent);


/***/ }),

/***/ "./navigation.ts":
/*!***********************!*\
  !*** ./navigation.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "../node_modules/gl-matrix/esm/index.js");
var eventhandler_1 = __webpack_require__(/*! ./eventhandler */ "./eventhandler.ts");
var pointerlock_1 = __webpack_require__(/*! ./pointerlock */ "./pointerlock.ts");
var firstpersonmodifier_1 = __webpack_require__(/*! ./firstpersonmodifier */ "./firstpersonmodifier.ts");
var trackballmodifier_1 = __webpack_require__(/*! ./trackballmodifier */ "./trackballmodifier.ts");
var turntablemodifier_1 = __webpack_require__(/*! ./turntablemodifier */ "./turntablemodifier.ts");
var Navigation = (function () {
    function Navigation(invalidate, mouseEventProvider, touchEventProvider) {
        var _this = this;
        this._alwaysRotateOnMove = false;
        this._invalidate = invalidate;
        this._eventHandler = new eventhandler_1.EventHandler(invalidate, {
            mouseEventProvider: mouseEventProvider,
            touchEventProvider: touchEventProvider,
            eyeGazeEventProvider: undefined
        });
        this._eventHandler.pushMouseDownHandler(function (latests, previous) {
            return _this.onMouseDown(latests, previous);
        });
        this._eventHandler.pushMouseUpHandler(function (latests, previous) {
            return _this.onMouseUp(latests, previous);
        });
        this._eventHandler.pushMouseMoveHandler(function (latests, previous) {
            return _this.onMouseMove(latests, previous);
        });
        this._eventHandler.pushClickHandler(function (latests, previous) {
            return _this.onClick(latests, previous);
        });
        if (touchEventProvider !== undefined) {
            this._eventHandler.pushTouchStartHandler(function (latests, previous) {
                return _this.onTouchStart(latests, previous);
            });
            this._eventHandler.pushTouchEndHandler(function (latests, previous) {
                return _this.onTouchEnd(latests, previous);
            });
            this._eventHandler.pushTouchMoveHandler(function (latests, previous) {
                return _this.onTouchMove(latests, previous);
            });
        }
        this.metaphor = Navigation.Metaphor.Turntable;
    }
    Navigation.prototype.mode = function (event) {
        var isPrimaryButtonDown = event.buttons & 1;
        var isMouseDown = event.type === 'mousedown';
        var isMouseMove = event.type === 'mousemove';
        var touchEvent = event;
        var isTouchEvent = false;
        if (touchEvent !== undefined) {
            isTouchEvent = touchEvent.touches !== undefined && touchEvent.touches.length > 0;
        }
        var isPointerLockedRotate = pointerlock_1.PointerLock.active() && this._alwaysRotateOnMove;
        if (isPointerLockedRotate || ((isMouseDown || isMouseMove) && isPrimaryButtonDown) || isTouchEvent) {
            return Navigation.Modes.Rotate;
        }
        return undefined;
    };
    Navigation.prototype.rotate = function (event, start) {
        var point = this._eventHandler.offsets(event)[0];
        switch (this._metaphor) {
            case Navigation.Metaphor.FirstPerson:
                var firstPerson = this._firstPerson;
                var movement = void 0;
                if (pointerlock_1.PointerLock.active() && event instanceof MouseEvent) {
                    movement = gl_matrix_1.vec2.fromValues(event.movementX, event.movementY);
                }
                start ? firstPerson.initiate(point) : firstPerson.process(point, movement);
                if (event.cancelable) {
                    event.preventDefault();
                }
                break;
            case Navigation.Metaphor.Trackball:
                var trackball = this._trackball;
                start ? trackball.initiate(point) : trackball.process(point);
                if (event.cancelable) {
                    event.preventDefault();
                }
                break;
            case Navigation.Metaphor.Turntable:
                var turntable = this._turntable;
                start ? turntable.initiate(point) : turntable.process(point);
                if (event.cancelable) {
                    event.preventDefault();
                }
                break;
            default:
                break;
        }
    };
    Navigation.prototype.onMouseDown = function (latests, previous) {
        var event = latests[latests.length - 1];
        this._mode = this.mode(event);
        switch (this._mode) {
            case Navigation.Modes.Zoom:
                break;
            case Navigation.Modes.Rotate:
                this.rotate(event, true);
                break;
            default:
                break;
        }
    };
    Navigation.prototype.onTouchStart = function (latests, previous) {
        var event = latests[latests.length - 1];
        this._mode = this.mode(event);
        switch (this._mode) {
            case Navigation.Modes.Zoom:
                break;
            case Navigation.Modes.Rotate:
                this.rotate(event, true);
                break;
            default:
                break;
        }
    };
    Navigation.prototype.onMouseUp = function (latests, previous) {
        var event = latests[latests.length - 1];
        if (undefined === this._mode) {
            return;
        }
        if (event.cancelable) {
            event.preventDefault();
        }
    };
    Navigation.prototype.onTouchEnd = function (latests, previous) {
        var event = latests[latests.length - 1];
        if (undefined === this._mode) {
            return;
        }
        if (event.cancelable) {
            event.preventDefault();
        }
    };
    Navigation.prototype.onMouseMove = function (latests, previous) {
        var event = latests[latests.length - 1];
        var modeWasUndefined = (this._mode === undefined);
        this._mode = this.mode(event);
        switch (this._mode) {
            case Navigation.Modes.Rotate:
                this.rotate(event, modeWasUndefined);
                break;
            default:
                break;
        }
    };
    Navigation.prototype.onTouchMove = function (latests, previous) {
        var event = latests[latests.length - 1];
        var modeWasUndefined = (this._mode === undefined);
        this._mode = this.mode(event);
        switch (this._mode) {
            case Navigation.Modes.Rotate:
                this.rotate(event, modeWasUndefined);
                break;
            default:
                break;
        }
    };
    Navigation.prototype.onClick = function (latests, previous) {
    };
    Navigation.prototype.update = function () {
        this._eventHandler.update();
    };
    Object.defineProperty(Navigation.prototype, "camera", {
        set: function (camera) {
            this._camera = camera;
            if (this._firstPerson) {
                this._firstPerson.camera = camera;
            }
            if (this._trackball) {
                this._trackball.camera = camera;
            }
            if (this._turntable) {
                this._turntable.camera = camera;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Navigation.prototype, "metaphor", {
        get: function () {
            return this._metaphor;
        },
        set: function (metaphor) {
            if (this._metaphor === metaphor) {
                return;
            }
            this._firstPerson = undefined;
            this._trackball = undefined;
            this._turntable = undefined;
            this._eventHandler.exitPointerLock();
            this._alwaysRotateOnMove = false;
            this._metaphor = metaphor;
            switch (this._metaphor) {
                case Navigation.Metaphor.FirstPerson:
                    this._eventHandler.requestPointerLock();
                    this._alwaysRotateOnMove = true;
                    this._firstPerson = new firstpersonmodifier_1.FirstPersonModifier();
                    this._firstPerson.camera = this._camera;
                    break;
                case Navigation.Metaphor.Trackball:
                    this._trackball = new trackballmodifier_1.TrackballModifier();
                    this._trackball.camera = this._camera;
                    break;
                case Navigation.Metaphor.Turntable:
                    this._turntable = new turntablemodifier_1.TurntableModifier();
                    this._turntable.camera = this._camera;
                    break;
                default:
                    break;
            }
            this._invalidate(true);
        },
        enumerable: true,
        configurable: true
    });
    return Navigation;
}());
exports.Navigation = Navigation;
(function (Navigation) {
    var Modes;
    (function (Modes) {
        Modes[Modes["Move"] = 0] = "Move";
        Modes[Modes["Pan"] = 1] = "Pan";
        Modes[Modes["Rotate"] = 2] = "Rotate";
        Modes[Modes["Zoom"] = 3] = "Zoom";
        Modes[Modes["ZoomStep"] = 4] = "ZoomStep";
    })(Modes = Navigation.Modes || (Navigation.Modes = {}));
    var Metaphor;
    (function (Metaphor) {
        Metaphor["FirstPerson"] = "firstperson";
        Metaphor["Flight"] = "flight";
        Metaphor["Trackball"] = "trackball";
        Metaphor["Turntable"] = "turntable";
    })(Metaphor = Navigation.Metaphor || (Navigation.Metaphor = {}));
})(Navigation = exports.Navigation || (exports.Navigation = {}));
exports.Navigation = Navigation;


/***/ }),

/***/ "./ndcfillingrectangle.ts":
/*!********************************!*\
  !*** ./ndcfillingrectangle.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var buffer_1 = __webpack_require__(/*! ./buffer */ "./buffer.ts");
var geometry_1 = __webpack_require__(/*! ./geometry */ "./geometry.ts");
var initializable_1 = __webpack_require__(/*! ./initializable */ "./initializable.ts");
var NdcFillingRectangle = (function (_super) {
    __extends(NdcFillingRectangle, _super);
    function NdcFillingRectangle(context, identifier) {
        var _this = _super.call(this, context, identifier) || this;
        identifier = identifier !== undefined && identifier !== "" ? identifier : _this.constructor.name;
        var vertexVBO = new buffer_1.Buffer(context, identifier + "VBO");
        _this._buffers.push(vertexVBO);
        return _this;
    }
    NdcFillingRectangle.prototype.bindBuffers = function () {
        this._buffers[0].attribEnable(this._vertexLocation, 2, this.context.gl.FLOAT, false, 0, 0, true, false);
    };
    NdcFillingRectangle.prototype.unbindBuffers = function () {
        this._buffers[0].attribDisable(this._vertexLocation, true, true);
    };
    NdcFillingRectangle.prototype.initialize = function (vertexLocation) {
        if (vertexLocation === void 0) { vertexLocation = 0; }
        this._vertexLocation = vertexLocation;
        var gl = this.context.gl;
        var valid = _super.prototype.initialize.call(this, [gl.ARRAY_BUFFER]);
        this._buffers[0].data(NdcFillingRectangle.VERTICES, gl.STATIC_DRAW);
        return valid;
    };
    NdcFillingRectangle.prototype.draw = function () {
        var gl = this.context.gl;
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    };
    Object.defineProperty(NdcFillingRectangle.prototype, "vertexLocation", {
        get: function () {
            return this._vertexLocation;
        },
        enumerable: true,
        configurable: true
    });
    NdcFillingRectangle.VERTICES = new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0]);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], NdcFillingRectangle.prototype, "draw", null);
    return NdcFillingRectangle;
}(geometry_1.Geometry));
exports.NdcFillingRectangle = NdcFillingRectangle;


/***/ }),

/***/ "./ndcfillingtriangle.ts":
/*!*******************************!*\
  !*** ./ndcfillingtriangle.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var buffer_1 = __webpack_require__(/*! ./buffer */ "./buffer.ts");
var geometry_1 = __webpack_require__(/*! ./geometry */ "./geometry.ts");
var initializable_1 = __webpack_require__(/*! ./initializable */ "./initializable.ts");
var NdcFillingTriangle = (function (_super) {
    __extends(NdcFillingTriangle, _super);
    function NdcFillingTriangle(context, identifier) {
        var _this = _super.call(this, context, identifier) || this;
        identifier = identifier !== undefined && identifier !== "" ? identifier : _this.constructor.name;
        var vertexVBO = new buffer_1.Buffer(context, identifier + "VBO");
        _this._buffers.push(vertexVBO);
        return _this;
    }
    NdcFillingTriangle.prototype.bindBuffers = function () {
        this._buffers[0].attribEnable(this._vertexLocation, 2, this.context.gl.FLOAT, false, 0, 0, true, false);
    };
    NdcFillingTriangle.prototype.unbindBuffers = function () {
        this._buffers[0].attribDisable(this._vertexLocation, true, true);
    };
    NdcFillingTriangle.prototype.initialize = function (vertexLocation) {
        if (vertexLocation === void 0) { vertexLocation = 0; }
        this._vertexLocation = vertexLocation;
        var gl = this.context.gl;
        var valid = _super.prototype.initialize.call(this, [gl.ARRAY_BUFFER]);
        this._buffers[0].data(NdcFillingTriangle.VERTICES, gl.STATIC_DRAW);
        return valid;
    };
    NdcFillingTriangle.prototype.draw = function () {
        var gl = this.context.gl;
        gl.drawArrays(gl.TRIANGLES, 0, 3);
    };
    Object.defineProperty(NdcFillingTriangle.prototype, "vertexLocation", {
        get: function () {
            return this._vertexLocation;
        },
        enumerable: true,
        configurable: true
    });
    NdcFillingTriangle.VERTICES = new Float32Array([-1.0, -3.0, 3.0, 1.0, -1.0, 1.0]);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], NdcFillingTriangle.prototype, "draw", null);
    return NdcFillingTriangle;
}(geometry_1.Geometry));
exports.NdcFillingTriangle = NdcFillingTriangle;


/***/ }),

/***/ "./object.ts":
/*!*******************!*\
  !*** ./object.ts ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var initializable_1 = __webpack_require__(/*! ./initializable */ "./initializable.ts");
var AbstractObject = (function (_super) {
    __extends(AbstractObject, _super);
    function AbstractObject(context, identifier) {
        var _this = _super.call(this) || this;
        _this._valid = false;
        _this._referenceCount = 0;
        _this._context = context;
        _this._identifier = identifier !== undefined && identifier !== "" ? identifier : 'Object';
        return _this;
    }
    AbstractObject.prototype.initialize = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this._identifier = this._context.allocationRegister.createUniqueIdentifier(this._identifier);
        this.create.apply(this, args);
        if (!this._valid) {
            this._context.allocationRegister.deleteUniqueIdentifier(this._identifier);
            auxiliaries_1.log(auxiliaries_1.LogLevel.Error, "initialization of '" + this._identifier + "' failed");
        }
        return this._valid;
    };
    AbstractObject.prototype.uninitialize = function () {
        this._context.allocationRegister.reallocate(this._identifier, 0);
        this._context.allocationRegister.deleteUniqueIdentifier(this._identifier);
        this.delete();
        auxiliaries_1.assert(this._object === undefined, "expected object '" + this._identifier + "' to be undefined after delete");
        auxiliaries_1.assert(this._valid === false, "expected object '" + this._identifier + "' to be invalid after delete");
    };
    Object.defineProperty(AbstractObject.prototype, "context", {
        get: function () {
            return this._context;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractObject.prototype, "identifier", {
        get: function () {
            return this._identifier;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractObject.prototype, "object", {
        get: function () {
            auxiliaries_1.assert(this._object !== undefined, "access to undefined object");
            return this._object;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractObject.prototype, "valid", {
        get: function () {
            return this._valid;
        },
        enumerable: true,
        configurable: true
    });
    AbstractObject.prototype.ref = function () {
        auxiliaries_1.assert(this.initialized, "expected object to be initialized in order to be referenced");
        ++this._referenceCount;
    };
    AbstractObject.prototype.unref = function () {
        auxiliaries_1.assert(this._referenceCount > 0, "expected object to be referenced in order to decrease its reference count");
        --this._referenceCount;
    };
    __decorate([
        initializable_1.Initializable.initialize()
    ], AbstractObject.prototype, "initialize", null);
    __decorate([
        initializable_1.Initializable.uninitialize()
    ], AbstractObject.prototype, "uninitialize", null);
    return AbstractObject;
}(initializable_1.Initializable));
exports.AbstractObject = AbstractObject;


/***/ }),

/***/ "./panmodifier.ts":
/*!************************!*\
  !*** ./panmodifier.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var cameramodifier_1 = __webpack_require__(/*! ./cameramodifier */ "./cameramodifier.ts");
var PanModifier = (function (_super) {
    __extends(PanModifier, _super);
    function PanModifier() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PanModifier.prototype.update = function () {
    };
    return PanModifier;
}(cameramodifier_1.CameraModifier));
exports.PanModifier = PanModifier;


/***/ }),

/***/ "./pointerlock.ts":
/*!************************!*\
  !*** ./pointerlock.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var PointerLock = (function () {
    function PointerLock() {
    }
    PointerLock.queryAndCacheAPI = function () {
        if (PointerLock._exit !== undefined) {
            return;
        }
        var document = window.document;
        var exits = [
            document.exitPointerLock,
            document.mozExitPointerLock,
            document.webkitExitPointerLock,
            undefined
        ];
        var api = 0;
        for (; api < exits.length; ++api) {
            if (exits[api] === undefined) {
                continue;
            }
            break;
        }
        switch (api) {
            case 0:
                PointerLock._exit = function () { return document.exitPointerLock(); };
                PointerLock._request = function (element) { return element.requestPointerLock(); };
                PointerLock._element = function () { return document.pointerLockElement; };
                break;
            case 1:
                PointerLock._exit = function () { return document.mozCancelPointerLock(); };
                PointerLock._request = function (element) { return element.mozRequestPointerLock(); };
                PointerLock._element = function () { return document.mozPointerLockElement; };
                break;
            case 2:
                PointerLock._exit = function () { return document.webkitExitPointerLock(); };
                PointerLock._request = function (element) { return element.webkitRequestPointerLock(); };
                PointerLock._element = function () { return document.webkitPointerLockElement; };
                break;
            default:
                auxiliaries_1.assert(false, "none of the following pointer lock apis was found: native, moz, or webkit");
        }
    };
    PointerLock.active = function (element) {
        if (this._element === undefined) {
            return false;
        }
        return (element !== undefined && PointerLock._element() === element) || (element === undefined &&
            PointerLock._element() !== undefined && PointerLock._element() !== null);
    };
    PointerLock.request = function (element, callback) {
        if (element === undefined) {
            return;
        }
        PointerLock.queryAndCacheAPI();
        if (PointerLock.active() && PointerLock._element() !== element) {
            PointerLock._exit();
        }
        if (!PointerLock.active()) {
            PointerLock._request(element);
        }
    };
    PointerLock.exit = function () {
        if (PointerLock._exit) {
            PointerLock._exit();
        }
    };
    return PointerLock;
}());
exports.PointerLock = PointerLock;


/***/ }),

/***/ "./polyfill.ts":
/*!*********************!*\
  !*** ./polyfill.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _this = this;
if (String.prototype.repeat === undefined) {
    String.prototype.repeat = function (count) {
        if (this === null) {
            throw new TypeError('can\'t convert ' + this + ' to object');
        }
        var str = '' + this;
        count = +count;
        if (count !== count) {
            count = 0;
        }
        if (count < 0) {
            throw new RangeError('repeat count must be non-negative');
        }
        if (count === Infinity) {
            throw new RangeError('repeat count must be less than infinity');
        }
        count = Math.floor(count);
        if (str.length === 0 || count === 0) {
            return '';
        }
        if (str.length * count >= 1 << 28) {
            throw new RangeError('repeat count must not overflow maximum string size');
        }
        var rpt = '';
        for (var i = 0; i < count; i++) {
            rpt += str;
        }
        return rpt;
    };
}
if (String.prototype.startsWith === undefined) {
    String.prototype.startsWith = function (searchString, position) {
        position = position || 0;
        return this.indexOf(searchString, position) === position;
    };
}
if (String.prototype.endsWith === undefined) {
    String.prototype.endsWith = function (search, length) {
        if (length === undefined || length > this.length) {
            length = this.length;
        }
        return this.substring(length - search.length, length) === search;
    };
}
if (String.prototype.includes === undefined) {
    String.prototype.includes = function (search, start) {
        if (typeof start !== 'number') {
            start = 0;
        }
        if (start + search.length > this.length) {
            return false;
        }
        else {
            return this.indexOf(search, start) !== -1;
        }
    };
}
if (String.prototype.trimLeft === undefined) {
    String.prototype.trimLeft = function () {
        return this.replace(/^\s+/, '');
    };
}
if (String.prototype.trimRight === undefined) {
    String.prototype.trimRight = function () {
        return this.replace(/^\s+/, '');
    };
}
if (Array.prototype.forEach === undefined) {
    Array.prototype.forEach = function (action, that) {
        var n = _this.length;
        for (var i = 0; i < n; i++) {
            if (i in _this) {
                action.call(that, _this[i], i, _this);
            }
        }
    };
}
if (Array.prototype.fill === undefined) {
    Array.prototype.fill = function (value, start, end) {
        if (_this === null) {
            throw new TypeError('this is null or not defined');
        }
        var O = Object(_this);
        var len = O.length >>> 0;
        var relativeStart = start >> 0;
        var k = relativeStart < 0 ?
            Math.max(len + relativeStart, 0) :
            Math.min(relativeStart, len);
        var relativeEnd = end === undefined ?
            len : end >> 0;
        var final = relativeEnd < 0 ?
            Math.max(len + relativeEnd, 0) :
            Math.min(relativeEnd, len);
        while (k < final) {
            O[k] = value;
            ++k;
        }
        return O;
    };
}
if (Math.log10 === undefined) {
    Math.log10 = function (x) { return Math.log(x) * Math.LOG10E; };
}
if (Number.EPSILON === undefined) {
    Number.EPSILON = Math.pow(2, -52);
}
[Float32Array, Uint8Array, Int8Array, Uint32Array, Int32Array].forEach(function (arrayType) {
    if (!arrayType.prototype.slice) {
        Object.defineProperty(arrayType.prototype, 'slice', { value: Array.prototype.slice });
    }
    if (!arrayType.prototype.reduce) {
        Object.defineProperty(arrayType.prototype, 'reduce', { value: Array.prototype.reduce });
    }
    if (!arrayType.prototype.filter) {
        Object.defineProperty(arrayType.prototype, 'filter', { value: Array.prototype.filter });
    }
    if (!arrayType.prototype.map) {
        Object.defineProperty(arrayType.prototype, 'map', { value: Array.prototype.map });
    }
    if (!arrayType.prototype.indexOf) {
        Object.defineProperty(arrayType.prototype, 'indexOf', { value: Array.prototype.indexOf });
    }
});
if (typeof Object.assign === 'undefined') {
    Object.defineProperty(Object, 'assign', {
        value: function (target, varArgs) {
            if (target === undefined && target === null) {
                throw new TypeError('Cannot convert undefined or null to object');
            }
            var to = Object(target);
            for (var index = 1; index < arguments.length; index++) {
                var nextSource = arguments[index];
                if (nextSource !== undefined && nextSource !== null) {
                    for (var nextKey in nextSource) {
                        if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                            to[nextKey] = nextSource[nextKey];
                        }
                    }
                }
            }
            return to;
        },
        configurable: true,
        writable: true,
    });
}


/***/ }),

/***/ "./program.ts":
/*!********************!*\
  !*** ./program.ts ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var initializable_1 = __webpack_require__(/*! ./initializable */ "./initializable.ts");
var object_1 = __webpack_require__(/*! ./object */ "./object.ts");
var Program = (function (_super) {
    __extends(Program, _super);
    function Program() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._shaders = new Array();
        _this._linked = false;
        return _this;
    }
    Program.prototype.create = function (shaders, link) {
        if (shaders === void 0) { shaders = new Array(); }
        if (link === void 0) { link = true; }
        var gl = this._context.gl;
        var numVertShaders = 0;
        var numFragShaders = 0;
        for (var _i = 0, shaders_1 = shaders; _i < shaders_1.length; _i++) {
            var shader = shaders_1[_i];
            switch (shader.type) {
                case gl.VERTEX_SHADER:
                    ++numVertShaders;
                    break;
                case gl.FRAGMENT_SHADER:
                    ++numFragShaders;
                    break;
                default:
                    auxiliaries_1.assert(false, "Unknown shader type detected.");
                    break;
            }
        }
        auxiliaries_1.logIf(numVertShaders < 1, auxiliaries_1.LogLevel.Error, "at least one vertex shader is expected");
        auxiliaries_1.logIf(numFragShaders < 1, auxiliaries_1.LogLevel.Error, "at least one fragment shader is expected");
        if (numVertShaders < 1 || numFragShaders < 1) {
            return undefined;
        }
        this._object = gl.createProgram();
        this._valid = gl.isProgram(this._object);
        auxiliaries_1.assert(this._object instanceof WebGLProgram, "expected WebGLProgram object to be created");
        if (shaders.length > 0) {
            this.attach(shaders, link);
        }
        return this._object;
    };
    Program.prototype.delete = function () {
        auxiliaries_1.assert(this._object !== undefined, "expected WebGLProgram object");
        this._context.gl.deleteProgram(this._object);
        this._object = undefined;
        this._valid = false;
    };
    Program.prototype.attach = function (shaders, link) {
        if (link === void 0) { link = false; }
        auxiliaries_1.assert(this._object !== undefined, "expected a WebGLProgram object");
        var gl = this._context.gl;
        for (var _i = 0, _a = (shaders instanceof Array ? shaders : [shaders]); _i < _a.length; _i++) {
            var shader = _a[_i];
            if (this._shaders.indexOf(shader) > -1) {
                continue;
            }
            this._shaders.push(shader);
            if (!shader.initialized) {
                auxiliaries_1.log(auxiliaries_1.LogLevel.Error, "shader '" + shader.identifier + "' not initialized.");
                continue;
            }
            gl.attachShader(this._object, shader.object);
            shader.ref();
        }
        if (link) {
            this.link();
        }
        return true;
    };
    Program.prototype.detach = function (shaders) {
        auxiliaries_1.assert(this._object !== undefined, "expected WebGLProgram object");
        var gl = this._context.gl;
        for (var _i = 0, _a = (shaders instanceof Array ? shaders : [shaders]); _i < _a.length; _i++) {
            var shader = _a[_i];
            var index = this._shaders.indexOf(shader);
            if (index > -1) {
                this._shaders.splice(index);
            }
            auxiliaries_1.assert(shader.initialized, "expected shader '" + shader.identifier + "' to be initialized");
            gl.detachShader(this._object, shader.object);
            shader.unref();
        }
    };
    Program.prototype.link = function () {
        auxiliaries_1.assert(this._object !== undefined, "expected WebGLProgram object");
        var gl = this._context.gl;
        gl.linkProgram(this._object);
        if (!gl.getProgramParameter(this._object, gl.LINK_STATUS)) {
            var infoLog = gl.getProgramInfoLog(this._object);
            auxiliaries_1.log(auxiliaries_1.LogLevel.Error, "linking of program '" + this._identifier + "' failed: '" + infoLog + "'");
            this._linked = false;
        }
        else {
            this._linked = true;
        }
        return this._linked;
    };
    Program.prototype.bind = function () {
        this._context.gl.useProgram(this._object);
    };
    Program.prototype.unbind = function () {
        this._context.gl.useProgram(Program.DEFAULT_PROGRAM);
    };
    Program.prototype.uniform = function (uniform) {
        return this._context.gl.getUniformLocation(this._object, uniform);
    };
    Program.prototype.attribute = function (attribute, location) {
        if (location !== undefined) {
            auxiliaries_1.logIf(this._linked, auxiliaries_1.LogLevel.Debug, "name-to-generic attribute index mapping does go into effect on next linking, " +
                ("given " + attribute + " -> " + location + " (" + this.identifier + ")"));
            this._context.gl.bindAttribLocation(this._object, location, attribute);
            return location;
        }
        else {
            return this._context.gl.getAttribLocation(this._object, attribute);
        }
    };
    Object.defineProperty(Program.prototype, "shaders", {
        get: function () {
            return this._shaders;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Program.prototype, "linked", {
        get: function () {
            return this._linked;
        },
        enumerable: true,
        configurable: true
    });
    Program.DEFAULT_PROGRAM = undefined;
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Program.prototype, "bind", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Program.prototype, "unbind", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Program.prototype, "uniform", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Program.prototype, "attribute", null);
    return Program;
}(object_1.AbstractObject));
exports.Program = Program;


/***/ }),

/***/ "./properties.ts":
/*!***********************!*\
  !*** ./properties.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var jsonschema_1 = __webpack_require__(/*! jsonschema */ "../node_modules/jsonschema/lib/index.js");
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var properties;
(function (properties_1) {
    function validate(instance, schema, references) {
        var validator = new jsonschema_1.Validator();
        if (references !== undefined) {
            for (var _i = 0, references_1 = references; _i < references_1.length; _i++) {
                var reference = references_1[_i];
                validator.addSchema(reference[0], reference[1]);
            }
        }
        var result = validator.validate(instance, schema);
        auxiliaries_1.logIf(!result.valid, auxiliaries_1.LogLevel.Warning, "schema expected to be valid:\n" + result.toString());
        return result.valid;
    }
    properties_1.validate = validate;
    function complement(instance, schema) {
        if (instance === undefined) {
            return;
        }
        auxiliaries_1.assert((schema.hasOwnProperty('properties') && schema['type'] === 'object') ||
            (schema.hasOwnProperty('items') && schema['type'] === 'array'), "expected schema to have 'properties' or 'items', given " + schema);
        switch (schema['type']) {
            case 'object':
                var propertiesSchema = schema['properties'];
                var properties_3 = Object.getOwnPropertyNames(propertiesSchema);
                for (var _i = 0, properties_2 = properties_3; _i < properties_2.length; _i++) {
                    var key = properties_2[_i];
                    var propertySchema = propertiesSchema[key];
                    var type = propertySchema['type'];
                    var isObject = type === 'object';
                    var isDefined = instance.hasOwnProperty(key);
                    var hasProperties = propertySchema.hasOwnProperty('properties');
                    var hasDefault = propertySchema.hasOwnProperty('default');
                    auxiliaries_1.assert((hasProperties && isObject) || (!hasProperties && !isObject), "expected property '" + key + "' to be of type 'object', given '" + propertySchema['type'] + "'");
                    if (isDefined && hasProperties) {
                        complement(instance[key], propertySchema);
                    }
                    else if (!isDefined && hasDefault) {
                        Object.defineProperty(instance, key, {
                            value: propertySchema['default'],
                            writable: true,
                        });
                    }
                }
                break;
            case 'array':
                var itemsSchema = schema['items'];
                if (itemsSchema['type'] !== 'object') {
                    break;
                }
                for (var _a = 0, _b = Object.getOwnPropertyNames(instance); _a < _b.length; _a++) {
                    var name_1 = _b[_a];
                    if (name_1 === 'length') {
                        continue;
                    }
                    complement(instance[name_1], itemsSchema);
                }
                break;
        }
    }
    properties_1.complement = complement;
    function compare(objectL, objectR, tracker, path) {
        if (path === void 0) { path = ''; }
        var track = tracker !== undefined;
        auxiliaries_1.assert(!track || tracker.hasOwnProperty('any'), "expected allocation lookup object to have 'any' key");
        if ((objectL === undefined && objectR !== undefined) || (objectL !== undefined && objectR === undefined)) {
            if (track) {
                tracker.alter(path);
            }
            return true;
        }
        var equals = true;
        var types = [typeof objectL, typeof objectR];
        var isArray = [objectL instanceof Array, objectR instanceof Array];
        if ((!isArray[0] || !isArray[1]) && (types[0] !== 'object' || types[1] !== 'object')) {
            equals = objectL === objectR;
            if (!equals && track) {
                tracker.alter("" + path);
            }
            return !equals;
        }
        var names = Array.from(new Set(Array().concat(Object.getOwnPropertyNames(objectL), Object.getOwnPropertyNames(objectR))).values());
        for (var _i = 0, names_1 = names; _i < names_1.length; _i++) {
            var name_2 = names_1[_i];
            if (name_2 === 'length') {
                continue;
            }
            var values = [objectL[name_2], objectR[name_2]];
            types = [typeof values[0], typeof values[1]];
            var propertyPath = "" + path + (path.length > 0 && !isArray[0] ? '.' : '') + (!isArray[0] ? name_2 : '');
            if ((values[0] instanceof Array && values[1] instanceof Array) ||
                (types[0] === 'object' && types[1] === 'object')) {
                equals = equals && !compare(values[0], values[1], tracker, propertyPath);
            }
            else {
                if (types[0] === types[1] && values[0] === values[1]) {
                    continue;
                }
                equals = false;
                if (track) {
                    tracker.alter(propertyPath);
                }
            }
        }
        return !equals;
    }
    properties_1.compare = compare;
})(properties || (properties = {}));
module.exports = properties;


/***/ }),

/***/ "./randomsquarekernel.ts":
/*!*******************************!*\
  !*** ./randomsquarekernel.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var kernel_1 = __webpack_require__(/*! ./kernel */ "./kernel.ts");
var RandomSquareKernel = (function (_super) {
    __extends(RandomSquareKernel, _super);
    function RandomSquareKernel(width) {
        var _this = _super.call(this, 2, width) || this;
        _this.generate();
        return _this;
    }
    RandomSquareKernel.prototype.generate = function () {
        auxiliaries_1.assert(this.width > 0, "expected every kernel to comprise at least one element");
        this.set([0.0, 0.0], 0);
        for (var i = 1; i < this.width; ++i) {
            this.set([auxiliaries_1.rand(-0.5, +0.5), auxiliaries_1.rand(-0.5, +0.5)], i);
        }
    };
    Object.defineProperty(RandomSquareKernel.prototype, "width", {
        get: function () {
            return this._width;
        },
        set: function (width) {
            if (this._width === width) {
                return;
            }
            this._width = width;
            this.resize();
            this.generate();
        },
        enumerable: true,
        configurable: true
    });
    return RandomSquareKernel;
}(kernel_1.KernelF32));
exports.RandomSquareKernel = RandomSquareKernel;


/***/ }),

/***/ "./raymath.ts":
/*!********************!*\
  !*** ./raymath.ts ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "../node_modules/gl-matrix/esm/index.js");
var gl_matrix_extensions_1 = __webpack_require__(/*! ./gl-matrix-extensions */ "./gl-matrix-extensions.ts");
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var ray_math;
(function (ray_math) {
    function rayCircleIntersection(ray0, ray1, radius) {
        if (radius === void 0) { radius = 1.0; }
        var ray_direction = gl_matrix_1.vec2.subtract(gl_matrix_extensions_1.v2(), ray1, ray0);
        if (gl_matrix_1.vec2.equals(ray_direction, gl_matrix_1.vec2.fromValues(0.0, 0.0))) {
            return undefined;
        }
        var a = gl_matrix_1.vec2.squaredLength(ray_direction);
        var b = 2.0 * gl_matrix_1.vec2.dot(ray_direction, ray0);
        var c = gl_matrix_1.vec2.squaredLength(ray0) - radius * radius;
        var delta = b * b - 4.0 * a * c;
        if (delta < 0.0) {
            return undefined;
        }
        var s = Math.sqrt(delta);
        var t = Math.min((-b + s) / (2.0 * a), (-b - s) / (2.0 * a));
        var intersection = gl_matrix_1.vec2.scale(gl_matrix_extensions_1.v2(), ray_direction, t);
        return gl_matrix_1.vec2.add(intersection, intersection, ray0);
    }
    ray_math.rayCircleIntersection = rayCircleIntersection;
    function pointSquareIntersection(point, edgeLength) {
        if (edgeLength === void 0) { edgeLength = 1.0; }
        var a = gl_matrix_extensions_1.abs2(gl_matrix_extensions_1.v2(), point);
        if (a[0] >= a[1]) {
            return gl_matrix_1.vec2.fromValues(gl_matrix_extensions_1.sign(point[0]) * edgeLength, point[1] / a[0] * edgeLength);
        }
        return gl_matrix_1.vec2.fromValues(point[0] / a[1] * edgeLength, gl_matrix_extensions_1.sign(point[1]) * edgeLength);
    }
    ray_math.pointSquareIntersection = pointSquareIntersection;
    function raySquareIntersection(ray0, ray1, halfLength) {
        if (halfLength === void 0) { halfLength = 1.0; }
        var vertices = [gl_matrix_1.vec2.fromValues(-halfLength, +halfLength), gl_matrix_1.vec2.fromValues(-halfLength, -halfLength),
            gl_matrix_1.vec2.fromValues(+halfLength, -halfLength), gl_matrix_1.vec2.fromValues(+halfLength, +halfLength)];
        var intersections = new Array();
        for (var i = 0; i < 4; ++i) {
            var intersection = rayLineIntersection(ray0, ray1, vertices[i], vertices[(i + 1) % 4]);
            if (intersection) {
                intersections.push(intersection[1]);
            }
        }
        return intersections;
    }
    ray_math.raySquareIntersection = raySquareIntersection;
    function rayLineIntersection(ray0, ray1, line0, line1) {
        var p = ray0;
        var r = gl_matrix_1.vec2.sub(gl_matrix_extensions_1.v2(), ray1, ray0);
        var q = line0;
        var s = gl_matrix_1.vec2.sub(gl_matrix_extensions_1.v2(), line1, line0);
        var cross_rs = gl_matrix_1.vec2.cross(gl_matrix_extensions_1.v3(), r, s)[2];
        if (cross_rs === 0.0) {
            return undefined;
        }
        var qp = gl_matrix_1.vec2.sub(gl_matrix_extensions_1.v2(), q, p);
        var u = gl_matrix_1.vec2.cross(gl_matrix_extensions_1.v3(), qp, gl_matrix_1.vec2.scale(gl_matrix_extensions_1.v2(), r, 1.0 / cross_rs))[2];
        var t = gl_matrix_1.vec2.cross(gl_matrix_extensions_1.v3(), qp, gl_matrix_1.vec2.scale(gl_matrix_extensions_1.v2(), s, 1.0 / cross_rs))[2];
        if (u < 0.0 || u > 1.0 || t < 0.0) {
            return undefined;
        }
        return [gl_matrix_1.vec2.add(gl_matrix_extensions_1.v2(), q, gl_matrix_1.vec2.scale(gl_matrix_extensions_1.v2(), s, u)), t];
    }
    ray_math.rayLineIntersection = rayLineIntersection;
    function rayPlaneIntersection(ray0, ray1, origin, normal) {
        if (origin === void 0) { origin = gl_matrix_1.vec3.fromValues(0.0, 0.0, 0.0); }
        if (normal === void 0) { normal = gl_matrix_1.vec3.fromValues(0.0, 1.0, 0.0); }
        var ray_direction = gl_matrix_1.vec3.normalize(gl_matrix_extensions_1.v3(), gl_matrix_1.vec3.subtract(gl_matrix_extensions_1.v3(), ray1, ray0));
        var rdDotN = gl_matrix_1.vec3.dot(ray_direction, normal);
        if (gl_matrix_1.vec3.equals(ray_direction, [0, 0, 0]) || rdDotN >= 0.0) {
            return undefined;
        }
        var t = gl_matrix_1.vec3.dot(gl_matrix_1.vec3.subtract(gl_matrix_extensions_1.v3(), origin, ray0), normal) / rdDotN;
        return gl_matrix_1.vec3.add(gl_matrix_extensions_1.v3(), gl_matrix_1.vec3.scale(gl_matrix_extensions_1.v3(), ray_direction, t), ray0);
    }
    ray_math.rayPlaneIntersection = rayPlaneIntersection;
    function raySphereIntersection(ray0, ray1, origin, radius) {
        if (origin === void 0) { origin = gl_matrix_1.vec3.fromValues(0.0, 0.0, 0.0); }
        if (radius === void 0) { radius = 1.0; }
        var rayOriginToSphereCenter = gl_matrix_1.vec3.subtract(gl_matrix_extensions_1.v3(), ray0, origin);
        var ray_direction = gl_matrix_1.vec3.normalize(gl_matrix_extensions_1.v3(), gl_matrix_1.vec3.subtract(gl_matrix_extensions_1.v3(), ray1, ray0));
        var dot_term = gl_matrix_1.vec3.dot(ray_direction, rayOriginToSphereCenter);
        var t = dot_term * dot_term - gl_matrix_1.vec3.squaredLength(rayOriginToSphereCenter) + radius * radius;
        if (t <= 0.0) {
            return undefined;
        }
        return gl_matrix_1.vec3.add(gl_matrix_extensions_1.v3(), ray0, gl_matrix_1.vec3.scale(gl_matrix_extensions_1.v3(), ray_direction, -dot_term - Math.sqrt(t)));
    }
    ray_math.raySphereIntersection = raySphereIntersection;
    function rayPlaneIntersection_tube(ray0, ray1, radius) {
        if (radius === void 0) { radius = 1.0; }
        var intersection = rayPlaneIntersection(ray0, ray1);
        if (intersection !== undefined && gl_matrix_1.vec3.length(intersection) < radius) {
            return intersection;
        }
        var ray0_xz = gl_matrix_1.vec2.fromValues(ray0[0], ray0[2]);
        var ray1_xz = gl_matrix_1.vec2.fromValues(ray1[0], ray1[2]);
        var intersection2 = rayCircleIntersection(ray0_xz, ray1_xz, radius);
        return intersection2 ? gl_matrix_1.vec3.fromValues(intersection2[0], 0.0, intersection2[1]) : undefined;
    }
    ray_math.rayPlaneIntersection_tube = rayPlaneIntersection_tube;
    function isPointWithinSquare(point, halfLength) {
        if (halfLength === void 0) { halfLength = 1.0; }
        var p_abs = gl_matrix_extensions_1.abs2(gl_matrix_extensions_1.v2(), point);
        return p_abs[0] <= halfLength && p_abs[1] <= halfLength;
    }
    ray_math.isPointWithinSquare = isPointWithinSquare;
    function isPointWithinNDC(viewProjection, point) {
        var p_transformed = gl_matrix_1.vec3.transformMat4(gl_matrix_extensions_1.v3(), point, viewProjection);
        var p_abs = gl_matrix_extensions_1.abs3(gl_matrix_extensions_1.v3(), p_transformed);
        return p_abs[0] <= 1.0 && p_abs[1] <= 1.0 && p_transformed[2] >= 0.0 && p_transformed[2] <= 1.0;
    }
    ray_math.isPointWithinNDC = isPointWithinNDC;
    function distancePointToRay(ray0, ray1, point) {
        var ray_direction = gl_matrix_1.vec3.subtract(gl_matrix_extensions_1.v3(), ray1, ray0);
        var ray_length = gl_matrix_1.vec3.squaredLength(ray_direction);
        if (ray_length === 0.0) {
            return 0.0;
        }
        var eyeToPoint = gl_matrix_1.vec3.subtract(gl_matrix_extensions_1.v3(), point, ray0);
        var theta = gl_matrix_1.vec3.dot(eyeToPoint, ray_direction);
        return theta / ray_length;
    }
    ray_math.distancePointToRay = distancePointToRay;
    function eyeWithPointInView(camera, point) {
        var ray_direction = gl_matrix_1.vec3.subtract(gl_matrix_extensions_1.v3(), camera.center, camera.eye);
        var ray_normalized = gl_matrix_1.vec3.normalize(gl_matrix_extensions_1.v3(), ray_direction);
        var ortho_v = gl_matrix_1.vec3.normalize(gl_matrix_extensions_1.v3(), gl_matrix_1.vec3.cross(gl_matrix_extensions_1.v3(), ray_normalized, camera.up));
        var ortho_u = gl_matrix_1.vec3.normalize(gl_matrix_extensions_1.v3(), gl_matrix_1.vec3.cross(gl_matrix_extensions_1.v3(), ortho_v, ray_normalized));
        var distance = distancePointToRay(camera.eye, camera.center, point);
        var closest = gl_matrix_1.vec3.add(gl_matrix_extensions_1.v3(), camera.eye, gl_matrix_1.vec3.scale(gl_matrix_extensions_1.v3(), ray_direction, distance));
        var t = gl_matrix_1.vec3.subtract(gl_matrix_extensions_1.v3(), point, closest);
        var part_v = Math.abs(gl_matrix_1.vec3.dot(t, ortho_v)) / camera.aspect;
        var part_u = Math.abs(gl_matrix_1.vec3.dot(t, ortho_u));
        var part_max = Math.max(part_v, part_u);
        var a = part_max / Math.tan(camera.fovy * auxiliaries_1.DEG2RAD * 0.5);
        return gl_matrix_1.vec3.subtract(gl_matrix_extensions_1.v3(), closest, gl_matrix_1.vec3.scale(gl_matrix_extensions_1.v3(), ray_normalized, a));
    }
    ray_math.eyeWithPointInView = eyeWithPointInView;
})(ray_math || (ray_math = {}));
module.exports = ray_math;


/***/ }),

/***/ "./readbackpass.ts":
/*!*************************!*\
  !*** ./readbackpass.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "../node_modules/gl-matrix/esm/index.js");
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var gl_matrix_extensions_1 = __webpack_require__(/*! ./gl-matrix-extensions */ "./gl-matrix-extensions.ts");
var framebuffer_1 = __webpack_require__(/*! ./framebuffer */ "./framebuffer.ts");
var initializable_1 = __webpack_require__(/*! ./initializable */ "./initializable.ts");
var ndcfillingtriangle_1 = __webpack_require__(/*! ./ndcfillingtriangle */ "./ndcfillingtriangle.ts");
var program_1 = __webpack_require__(/*! ./program */ "./program.ts");
var shader_1 = __webpack_require__(/*! ./shader */ "./shader.ts");
var texture2d_1 = __webpack_require__(/*! ./texture2d */ "./texture2d.ts");
var ReadbackPass = (function (_super) {
    __extends(ReadbackPass, _super);
    function ReadbackPass(context) {
        var _this = _super.call(this) || this;
        _this._cache = false;
        _this._depthAttachment = 0;
        _this._cachedDepths = new Map();
        _this._cachedIDs = new Map();
        _this._buffer = new Uint8Array(4);
        _this._ndcTriangleShared = false;
        _this._context = context;
        return _this;
    }
    ReadbackPass.maxClearDepth = function () {
        return gl_matrix_extensions_1.decode_float24x1_from_uint8x3(gl_matrix_1.vec3.fromValues(255, 255, 255));
    };
    ReadbackPass.prototype.onFrame = function () {
        this._cachedDepths.clear();
        this._cachedIDs.clear();
    };
    ReadbackPass.prototype.hash = function (x, y) {
        return 0xffff * y + x;
    };
    ReadbackPass.prototype.directReadDepthAt = function (x, y) {
        auxiliaries_1.assert(this._depthFBO !== undefined && this._depthFBO.valid, "valid depth FBO expected for reading back depth");
        var texture = this._depthFBO.texture(this._depthAttachment);
        var gl = this._context.gl;
        var size = texture.size;
        this._depthFBO.bind();
        var scale = this._referenceSize === undefined ? [1.0, 1.0] :
            [size[0] / this._referenceSize[0], size[1] / this._referenceSize[1]];
        if (this._context.isWebGL2 || this._context.supportsDrawBuffers) {
            gl.readBuffer(this._depthAttachment);
        }
        gl.readPixels(x * scale[0], size[1] - y * scale[1], 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, this._buffer);
        return this._buffer;
    };
    ReadbackPass.prototype.renderThenReadDepthAt = function (x, y) {
        auxiliaries_1.assert(this._depthFBO !== undefined && this._depthFBO.valid, "valid depth FBO expected for reading back depth");
        var texture = this._depthFBO.texture(this._depthAttachment);
        var gl = this._context.gl;
        var size = texture.size;
        var scale = this._referenceSize === undefined ? [1.0, 1.0] :
            [size[0] / this._referenceSize[0], size[1] / this._referenceSize[1]];
        gl.viewport(0, 0, 1, 1);
        this._program.bind();
        gl.uniform2f(this._uOffset, x * scale[0] / size[0], (size[1] - y * scale[1]) / size[1]);
        gl.uniform2f(this._uScale, 1.0 / size[0], 1.0 / size[1]);
        texture.bind(gl.TEXTURE0);
        this._framebuffer.bind();
        this._ndcTriangle.bind();
        this._ndcTriangle.draw();
        this._ndcTriangle.unbind();
        texture.unbind();
        if ((this._context.isWebGL2 || this._context.supportsDrawBuffers) && gl.readBuffer) {
            gl.readBuffer(gl.COLOR_ATTACHMENT0);
        }
        gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, this._buffer);
        this._framebuffer.unbind();
        return this._buffer;
    };
    ReadbackPass.prototype.initialize = function (ndcTriangle, direct) {
        var gl = this._context.gl;
        var gl2facade = this._context.gl2facade;
        if (direct) {
            this.readDepthAt = this.directReadDepthAt;
            return true;
        }
        this.readDepthAt = this.renderThenReadDepthAt;
        var vert = new shader_1.Shader(this._context, gl.VERTEX_SHADER, 'ndcvertices.vert (readback)');
        vert.initialize(__webpack_require__(/*! ./shaders/ndcvertices.vert */ "./shaders/ndcvertices.vert"));
        var frag = new shader_1.Shader(this._context, gl.FRAGMENT_SHADER, 'readbackdepth.frag');
        frag.initialize(__webpack_require__(/*! ./shaders/readbackdepth.frag */ "./shaders/readbackdepth.frag"));
        this._program = new program_1.Program(this._context, 'ReadbackDepthProgram');
        this._program.initialize([vert, frag], false);
        if (ndcTriangle === undefined) {
            this._ndcTriangle = new ndcfillingtriangle_1.NdcFillingTriangle(this._context);
        }
        else {
            this._ndcTriangle = ndcTriangle;
            this._ndcTriangleShared = true;
        }
        if (!this._ndcTriangle.initialized) {
            this._ndcTriangle.initialize();
        }
        this._program.attribute('a_vertex', this._ndcTriangle.vertexLocation);
        this._program.link();
        this._uOffset = this._program.uniform('u_offset');
        this._program.bind();
        gl.uniform1i(this._program.uniform('u_texture'), 0);
        this._program.unbind();
        this._texture = new texture2d_1.Texture2D(this._context, 'ReadbackRenderTexture');
        this._texture.initialize(1, 1, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE);
        this._framebuffer = new framebuffer_1.Framebuffer(this._context, 'ReadbackFBO');
        this._framebuffer.initialize([[gl2facade.COLOR_ATTACHMENT0, this._texture]]);
        return true;
    };
    ReadbackPass.prototype.uninitialize = function () {
        if (this._context.isWebGL1 && !this._context.supportsDepthTexture) {
            return;
        }
        if (!this._ndcTriangleShared && this._ndcTriangle.initialized) {
            this._ndcTriangle.uninitialize();
        }
        this._program.uninitialize();
        this._texture.uninitialize();
        this._framebuffer.uninitialize();
    };
    ReadbackPass.prototype.depthAt = function (x, y) {
        var hash = this.hash(x, y);
        if (this._cache && this._cachedDepths.has(hash)) {
            return this._cachedDepths.get(hash);
        }
        var buffer = this.readDepthAt(x, y);
        var depth = buffer[0] === 255 && buffer[1] === 255 && buffer[2] === 255 ?
            undefined : gl_matrix_extensions_1.decode_float24x1_from_uint8x3(gl_matrix_1.vec3.fromValues(buffer[0], buffer[1], buffer[2]));
        if (this._cache) {
            this._cachedDepths.set(hash, depth);
        }
        return depth;
    };
    ReadbackPass.prototype.coordsAt = function (x, y, zInNDC, viewProjectionInverse) {
        var size = this._depthFBO.texture(this._depthAttachment).size;
        var depth = zInNDC === undefined ? this.depthAt(x, y) : zInNDC;
        if (depth === undefined) {
            return undefined;
        }
        var scale = this._referenceSize === undefined ? [1.0, 1.0] :
            [size[0] / this._referenceSize[0], size[1] / this._referenceSize[1]];
        var p = gl_matrix_1.vec3.fromValues(x * scale[0] * 2.0 / size[0] - 1.0, 1.0 - y * scale[1] * 2.0 / size[1], depth * 2.0 - 1.0);
        return gl_matrix_1.vec3.transformMat4(gl_matrix_1.vec3.create(), p, viewProjectionInverse);
    };
    ReadbackPass.prototype.idAt = function (x, y) {
        var hash = this.hash(x, y);
        if (this._cache && this._cachedIDs.has(hash)) {
            return this._cachedIDs.get(hash);
        }
        var gl = this._context.gl;
        var size = this._idFBO.texture(this._idAttachment).size;
        var scale = this._referenceSize === undefined ? [1.0, 1.0] :
            [size[0] / this._referenceSize[0], size[1] / this._referenceSize[1]];
        this._idFBO.bind();
        if (this._context.isWebGL2) {
            gl.readBuffer(this._idAttachment);
        }
        gl.readPixels(x * scale[0], size[1] - y * scale[1], 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, this._buffer);
        var id = gl_matrix_extensions_1.decode_uint32_from_rgba8(gl_matrix_1.vec4.fromValues(this._buffer[0], this._buffer[1], this._buffer[2], this._buffer[3]));
        if (this._cache) {
            this._cachedIDs.set(hash, id);
        }
        return id;
    };
    ReadbackPass.prototype.frame = function () {
        this.onFrame();
    };
    Object.defineProperty(ReadbackPass.prototype, "cache", {
        set: function (value) {
            this._cache = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ReadbackPass.prototype, "depthFBO", {
        set: function (framebuffer) {
            this._depthFBO = framebuffer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ReadbackPass.prototype, "depthAttachment", {
        set: function (attachment) {
            this._depthAttachment = attachment;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ReadbackPass.prototype, "idFBO", {
        set: function (framebuffer) {
            this._idFBO = framebuffer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ReadbackPass.prototype, "idAttachment", {
        set: function (attachment) {
            this._idAttachment = attachment;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ReadbackPass.prototype, "coordinateReferenceSize", {
        set: function (size) {
            this._referenceSize = size;
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], ReadbackPass.prototype, "directReadDepthAt", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], ReadbackPass.prototype, "renderThenReadDepthAt", null);
    __decorate([
        initializable_1.Initializable.initialize()
    ], ReadbackPass.prototype, "initialize", null);
    __decorate([
        initializable_1.Initializable.uninitialize()
    ], ReadbackPass.prototype, "uninitialize", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], ReadbackPass.prototype, "depthAt", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], ReadbackPass.prototype, "coordsAt", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], ReadbackPass.prototype, "idAt", null);
    return ReadbackPass;
}(initializable_1.Initializable));
exports.ReadbackPass = ReadbackPass;


/***/ }),

/***/ "./renderbuffer.ts":
/*!*************************!*\
  !*** ./renderbuffer.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var formatbytesizes_1 = __webpack_require__(/*! ./formatbytesizes */ "./formatbytesizes.ts");
var initializable_1 = __webpack_require__(/*! ./initializable */ "./initializable.ts");
var object_1 = __webpack_require__(/*! ./object */ "./object.ts");
var Renderbuffer = (function (_super) {
    __extends(Renderbuffer, _super);
    function Renderbuffer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._internalFormat = undefined;
        return _this;
    }
    Renderbuffer.prototype.create = function (width, height, internalFormat) {
        auxiliaries_1.assert(width > 0 && height > 0, "renderbuffer object requires valid width and height greater than zero");
        var gl = this.context.gl;
        this._object = gl.createRenderbuffer();
        this._width = width;
        this._height = height;
        this._internalFormat = internalFormat;
        gl.bindRenderbuffer(gl.RENDERBUFFER, this._object);
        gl.renderbufferStorage(gl.RENDERBUFFER, internalFormat, width, height);
        this._valid = gl.isRenderbuffer(this._object);
        gl.bindRenderbuffer(gl.RENDERBUFFER, Renderbuffer.DEFAULT_RENDER_BUFFER);
        var bytes = width * height * formatbytesizes_1.byteSizeOfFormat(this.context, internalFormat);
        this.context.allocationRegister.reallocate(this._identifier, bytes);
        return this._object;
    };
    Renderbuffer.prototype.delete = function () {
        auxiliaries_1.assert(this._object instanceof WebGLRenderbuffer, "expected WebGLRenderbuffer object");
        this.context.gl.deleteRenderbuffer(this._object);
        this._object = undefined;
        this._valid = false;
        this._internalFormat = undefined;
        this._width = 0;
        this._height = 0;
    };
    Renderbuffer.prototype.bind = function () {
        this.context.gl.bindRenderbuffer(this.context.gl.RENDERBUFFER, this._object);
    };
    Renderbuffer.prototype.unbind = function () {
        this.context.gl.bindRenderbuffer(this.context.gl.RENDERBUFFER, Renderbuffer.DEFAULT_RENDER_BUFFER);
    };
    Renderbuffer.prototype.resize = function (width, height, bind, unbind) {
        if (bind === void 0) { bind = false; }
        if (unbind === void 0) { unbind = false; }
        if (width === this._width && height === this._height) {
            return;
        }
        this._width = width;
        this._height = height;
        var gl = this.context.gl;
        if (bind) {
            this.bind();
        }
        gl.renderbufferStorage(gl.RENDERBUFFER, this._internalFormat, width, height);
        if (unbind) {
            this.unbind();
        }
        var bytes = width * height * formatbytesizes_1.byteSizeOfFormat(this.context, this._internalFormat);
        this.context.allocationRegister.reallocate(this._identifier, bytes);
    };
    Object.defineProperty(Renderbuffer.prototype, "bytes", {
        get: function () {
            this.assertInitialized();
            return this.context.allocationRegister.allocated(this._identifier);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Renderbuffer.prototype, "internalFormat", {
        get: function () {
            this.assertInitialized();
            return this._internalFormat;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Renderbuffer.prototype, "width", {
        get: function () {
            this.assertInitialized();
            return this._width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Renderbuffer.prototype, "height", {
        get: function () {
            this.assertInitialized();
            return this._height;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Renderbuffer.prototype, "size", {
        get: function () {
            return [this.width, this.height];
        },
        enumerable: true,
        configurable: true
    });
    Renderbuffer.DEFAULT_RENDER_BUFFER = undefined;
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Renderbuffer.prototype, "bind", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Renderbuffer.prototype, "unbind", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Renderbuffer.prototype, "resize", null);
    return Renderbuffer;
}(object_1.AbstractObject));
exports.Renderbuffer = Renderbuffer;


/***/ }),

/***/ "./renderer.ts":
/*!*********************!*\
  !*** ./renderer.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var rxjs_1 = __webpack_require__(/*! rxjs */ "rxjs");
var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "../node_modules/gl-matrix/esm/index.js");
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var gl_matrix_extensions_1 = __webpack_require__(/*! ./gl-matrix-extensions */ "./gl-matrix-extensions.ts");
var changelookup_1 = __webpack_require__(/*! ./changelookup */ "./changelookup.ts");
var initializable_1 = __webpack_require__(/*! ./initializable */ "./initializable.ts");
var tuples_1 = __webpack_require__(/*! ./tuples */ "./tuples.ts");
var wizard_1 = __webpack_require__(/*! ./wizard */ "./wizard.ts");
var LoadingStatus;
(function (LoadingStatus) {
    LoadingStatus[LoadingStatus["Started"] = 0] = "Started";
    LoadingStatus[LoadingStatus["Finished"] = 1] = "Finished";
})(LoadingStatus = exports.LoadingStatus || (exports.LoadingStatus = {}));
var Renderer = (function (_super) {
    __extends(Renderer, _super);
    function Renderer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._altered = Object.assign(new changelookup_1.ChangeLookup(), {
            any: false, multiFrameNumber: false, frameSize: false, canvasSize: false, framePrecision: false,
            clearColor: false, debugTexture: false,
        });
        _this._frameSize = [0, 0];
        _this._canvasSize = [0, 0];
        _this._framePrecision = wizard_1.Wizard.Precision.half;
        _this._clearColor = [0.0, 0.0, 0.0, 1.0];
        _this._debugTextures = new Array();
        _this._debugTextureSubject = new rxjs_1.ReplaySubject(1);
        return _this;
    }
    Renderer.prototype.invalidate = function (force) {
        if (force === void 0) { force = false; }
        this._invalidate(force);
    };
    Renderer.prototype.debugTextureNext = function () {
        this._debugTextureSubject.next(this._debugTexture);
    };
    Object.defineProperty(Renderer.prototype, "context", {
        get: function () {
            this.assertInitialized();
            return this._context;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Renderer.prototype, "canvasSize", {
        get: function () {
            this.assertInitialized();
            return this._canvasSize;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Renderer.prototype, "altered", {
        get: function () {
            return this._altered.any;
        },
        enumerable: true,
        configurable: true
    });
    Renderer.prototype.onSwap = function () { };
    Renderer.prototype.startLoading = function () {
        this._isLoading = true;
        this._loadingStatusSubscription.next(LoadingStatus.Started);
    };
    Renderer.prototype.finishLoading = function () {
        this._isLoading = false;
        this._loadingStatusSubscription.next(LoadingStatus.Finished);
    };
    Renderer.prototype.initialize = function (context, callback, eventProvider) {
        auxiliaries_1.assert(context !== undefined, "valid webgl context required");
        this._context = context;
        auxiliaries_1.assert(callback !== undefined, "valid multi-frame update callback required");
        this._invalidate = callback;
        this._isLoading = true;
        this._loadingStatusSubscription = new rxjs_1.ReplaySubject();
        return this.onInitialize(context, callback, eventProvider);
    };
    Renderer.prototype.uninitialize = function () {
        this.onUninitialize();
    };
    Renderer.prototype.update = function (multiFrameNumber) {
        if (this._canvasSize[0] !== this._context.gl.canvas.width ||
            this._canvasSize[1] !== this._context.gl.canvas.height) {
            this._canvasSize[0] = this._context.gl.canvas.width;
            this._canvasSize[1] = this._context.gl.canvas.height;
            this._altered.alter('canvasSize');
        }
        if (this._multiFrameNumber !== multiFrameNumber) {
            this._multiFrameNumber = multiFrameNumber;
            this._altered.alter('multiFrameNumber');
        }
        return this.onUpdate() || this._altered.any;
    };
    Renderer.prototype.prepare = function () {
        this.onPrepare();
    };
    Renderer.prototype.frame = function (frameNumber) {
        this.onFrame(frameNumber);
    };
    Renderer.prototype.swap = function () {
        this.onSwap();
    };
    Renderer.prototype.frameCoords = function (x, y) {
        var position = gl_matrix_1.vec2.divide(gl_matrix_extensions_1.v2(), this._frameSize, this.canvasSize);
        gl_matrix_1.vec2.floor(position, gl_matrix_1.vec2.multiply(position, [x + 0.5, y + 0.5], position));
        gl_matrix_1.vec2.add(position, position, [0.5, 0.5]);
        return tuples_1.tuple2(position);
    };
    Object.defineProperty(Renderer.prototype, "frameSize", {
        set: function (size) {
            this.assertInitialized();
            if (gl_matrix_1.vec2.equals(this._frameSize, size)) {
                return;
            }
            Object.assign(this._frameSize, size);
            this._altered.alter('frameSize');
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Renderer.prototype, "framePrecision", {
        set: function (precision) {
            this.assertInitialized();
            if (this._framePrecision === precision) {
                return;
            }
            this._framePrecision = precision;
            this._altered.alter('framePrecision');
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Renderer.prototype, "clearColor", {
        set: function (color) {
            this.assertInitialized();
            if (gl_matrix_1.vec4.equals(this._clearColor, color)) {
                return;
            }
            Object.assign(this._clearColor, color);
            this._altered.alter('clearColor');
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Renderer.prototype, "debugTextures", {
        get: function () {
            this.assertInitialized();
            return this._debugTextures;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Renderer.prototype, "debugTexture", {
        get: function () {
            this.assertInitialized();
            return this._debugTexture;
        },
        set: function (index) {
            this.assertInitialized();
            if (this._debugTexture === index) {
                return;
            }
            auxiliaries_1.logIf(index >= this._debugTextures.length, auxiliaries_1.LogLevel.Error, "invalid texture index, " +
                ("debug texture disabled (index set to -1) | " + index + " not in [-1,+" + (this._debugTextures.length - 1) + "]"));
            this._debugTexture = index < this._debugTextures.length ?
                gl_matrix_extensions_1.clamp(index, -1, this._debugTextures.length - 1) : -1;
            this._altered.alter('debugTexture');
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Renderer.prototype, "debugTexture$", {
        get: function () {
            return this._debugTextureSubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Renderer.prototype, "isLoading", {
        get: function () {
            return this._isLoading;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Renderer.prototype, "loadingStatus$", {
        get: function () {
            return this._loadingStatusSubscription.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Renderer.prototype, "invalidate", null);
    __decorate([
        initializable_1.Initializable.initialize()
    ], Renderer.prototype, "initialize", null);
    __decorate([
        initializable_1.Initializable.uninitialize()
    ], Renderer.prototype, "uninitialize", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Renderer.prototype, "update", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Renderer.prototype, "prepare", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Renderer.prototype, "frame", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Renderer.prototype, "swap", null);
    return Renderer;
}(initializable_1.Initializable));
exports.Renderer = Renderer;


/***/ }),

/***/ "./resizable.ts":
/*!**********************!*\
  !*** ./resizable.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var Resizable = (function () {
    function Resizable() {
        var _this = this;
        this._resizeEventListener = function () { return Resizable.resize(); };
        this._mutationEventListener = function () {
            _this._mutationObserver.takeRecords();
            Resizable.resize();
        };
        if (Resizable.instances.length === 0) {
            var event_1 = "on" + Resizable.EVENT_IDENTIFIER;
            Resizable.eventSupported = document && (event_1 in document.documentElement || event_1 in document.body);
            auxiliaries_1.logIf(!Resizable.eventSupported, auxiliaries_1.LogLevel.Warning, "resize event not supported");
        }
        if (Resizable.instances.length === 0 && Resizable.eventSupported) {
            window.addEventListener(Resizable.EVENT_IDENTIFIER, this._resizeEventListener);
        }
        Resizable.instances.push(this);
    }
    Resizable.resize = function () {
        auxiliaries_1.assert(Resizable.instances.length > 0, "resize event received without a single resizable registered");
        Resizable.instances.forEach(function (item) { return item.onResize(); });
    };
    Resizable.elementSize = function (element) {
        if (element === undefined || window === undefined || typeof window.devicePixelRatio !== 'number') {
            return [0, 0];
        }
        var scale = window.devicePixelRatio;
        var style = getComputedStyle(element);
        var pxUnits = style.width !== null && style.width.endsWith('px') &&
            style.height !== null && style.height.endsWith('px');
        if (!pxUnits) {
            auxiliaries_1.log(auxiliaries_1.LogLevel.Debug, "computed element size expected in 'px', given " + style.width + " " + style.height);
            return undefined;
        }
        var sizef = [parseFloat(style.width), parseFloat(style.height)];
        var size = [Math.round(sizef[0] * scale), Math.round(sizef[1] * scale)];
        return size;
    };
    Resizable.prototype.observe = function (element) {
        if (element !== undefined) {
            this._mutationObserver = new MutationObserver(this._mutationEventListener);
        }
        this._mutationObserver.observe(element, Resizable.MUTATION_OBSERVER_CONFIG);
    };
    Resizable.prototype.dispose = function () {
        var i = Resizable.instances.indexOf(this);
        auxiliaries_1.assert(i !== -1, "invalid reference counting of resizable instances");
        Resizable.instances.splice(i, 1);
        if (Resizable.instances.length === 0 && Resizable.eventSupported) {
            window.removeEventListener(Resizable.EVENT_IDENTIFIER, this._resizeEventListener);
        }
        if (this._mutationObserver) {
            this._mutationObserver.disconnect();
        }
    };
    Resizable.EVENT_IDENTIFIER = 'resize';
    Resizable.instances = [];
    Resizable.eventSupported = false;
    Resizable.MUTATION_OBSERVER_CONFIG = {
        attributes: true,
        attributeFilter: ['style', 'class'],
        childList: true,
        subtree: true,
    };
    return Resizable;
}());
exports.Resizable = Resizable;


/***/ }),

/***/ "./scene/forwardscenerenderpass.ts":
/*!*****************************************!*\
  !*** ./scene/forwardscenerenderpass.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "../node_modules/gl-matrix/esm/index.js");
var auxiliaries_1 = __webpack_require__(/*! ../auxiliaries */ "./auxiliaries.ts");
var changelookup_1 = __webpack_require__(/*! ../changelookup */ "./changelookup.ts");
var initializable_1 = __webpack_require__(/*! ../initializable */ "./initializable.ts");
var scenerenderpass_1 = __webpack_require__(/*! ./scenerenderpass */ "./scene/scenerenderpass.ts");
var ForwardSceneRenderPass = (function (_super) {
    __extends(ForwardSceneRenderPass, _super);
    function ForwardSceneRenderPass(context) {
        var _this = _super.call(this) || this;
        _this._altered = Object.assign(new changelookup_1.ChangeLookup(), {
            any: false,
            camera: false,
        });
        _this._context = context;
        _this._opaqueGeometryMap = new Map();
        _this._transparentGeometryMap = new Map();
        return _this;
    }
    ForwardSceneRenderPass.prototype.preprocessScene = function () {
        auxiliaries_1.assert(this._scene !== undefined, 'Scene was undefined during preprocessing.');
        if (this._scene === undefined) {
            return;
        }
        this._opaqueGeometryMap.clear();
        this._transparentGeometryMap.clear();
        this.preprocessNode(this._scene, gl_matrix_1.mat4.create());
    };
    ForwardSceneRenderPass.prototype.preprocessNode = function (node, transform) {
        var nodeTransform = gl_matrix_1.mat4.clone(transform);
        var transformComponents = node.componentsOfType('TransformComponent');
        auxiliaries_1.assert(transformComponents.length <= 1, "SceneNode can not have more than one transform component");
        if (transformComponents.length === 1) {
            var transformComponent = transformComponents[0];
            gl_matrix_1.mat4.mul(nodeTransform, nodeTransform, transformComponent.transform);
        }
        var geometryComponents = node.componentsOfType('GeometryComponent');
        for (var _i = 0, geometryComponents_1 = geometryComponents; _i < geometryComponents_1.length; _i++) {
            var geometryComponent = geometryComponents_1[_i];
            var currentComponent = geometryComponent;
            var material = currentComponent.material;
            var geometry = currentComponent.geometry;
            if (material.isTransparent) {
                var map = this._transparentGeometryMap.get(material);
                if (map === undefined) {
                    map = [];
                }
                map.push([geometry, nodeTransform]);
                this._transparentGeometryMap.set(material, map);
            }
            else {
                var map = this._opaqueGeometryMap.get(material);
                if (map === undefined) {
                    map = [];
                }
                map.push([geometry, nodeTransform]);
                this._opaqueGeometryMap.set(material, map);
            }
        }
        if (node.nodes === undefined) {
            return;
        }
        for (var _a = 0, _b = node.nodes; _a < _b.length; _a++) {
            var child = _b[_a];
            this.preprocessNode(child, nodeTransform);
        }
    };
    ForwardSceneRenderPass.prototype.renderGeometryMap = function (map) {
        for (var _i = 0, _a = Array.from(map.keys()); _i < _a.length; _i++) {
            var material = _a[_i];
            this.bindMaterial(material);
            var geometryTuples = map.get(material);
            for (var _b = 0, geometryTuples_1 = geometryTuples; _b < geometryTuples_1.length; _b++) {
                var _c = geometryTuples_1[_b], geometry = _c[0], transform = _c[1];
                geometry.bind();
                if (this.bindGeometry !== undefined) {
                    this.bindGeometry(geometry);
                }
                this.updateModelTransform(transform);
                geometry.draw();
                geometry.unbind();
            }
        }
    };
    ForwardSceneRenderPass.prototype.initialize = function () {
        return true;
    };
    ForwardSceneRenderPass.prototype.uninitialize = function () { };
    ForwardSceneRenderPass.prototype.prepare = function () { };
    ForwardSceneRenderPass.prototype.update = function (override) {
        if (override === void 0) { override = false; }
    };
    ForwardSceneRenderPass.prototype.frame = function () {
        auxiliaries_1.assert(this._target && this._target.valid, "valid target expected");
        auxiliaries_1.assert(this._program && this._program.valid, "valid program expected");
        auxiliaries_1.assert(this.updateModelTransform !== undefined, "Model transform function needs to be initialized.");
        auxiliaries_1.assert(this.updateViewProjectionTransform !== undefined, "View Projection transform function needs to be initialized.");
        auxiliaries_1.assert(this.bindMaterial !== undefined, "Material binding function needs to be initialized.");
        if (this._scene === undefined) {
            return;
        }
        var gl = this._context.gl;
        gl.disable(gl.CULL_FACE);
        gl.cullFace(gl.BACK);
        gl.enable(gl.DEPTH_TEST);
        var size = this._target.size;
        gl.viewport(0, 0, size[0], size[1]);
        var c = this._clearColor;
        gl.clearColor(c[0], c[1], c[2], c[3]);
        this._target.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, true, false);
        this._program.bind();
        if (this.bindUniforms !== undefined) {
            this.bindUniforms();
        }
        this.updateViewProjectionTransform(this._camera.viewProjection);
        this.drawCalls();
        this._program.unbind();
        gl.cullFace(gl.BACK);
        gl.disable(gl.CULL_FACE);
        gl.disable(gl.BLEND);
    };
    ForwardSceneRenderPass.prototype.drawCalls = function (renderTransparentMaterials) {
        if (renderTransparentMaterials === void 0) { renderTransparentMaterials = true; }
        if (this._scene === undefined) {
            return;
        }
        this.renderGeometryMap(this._opaqueGeometryMap);
        if (renderTransparentMaterials) {
            this.renderGeometryMap(this._transparentGeometryMap);
        }
    };
    Object.defineProperty(ForwardSceneRenderPass.prototype, "target", {
        set: function (target) {
            this.assertInitialized();
            this._target = target;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ForwardSceneRenderPass.prototype, "ndcOffset", {
        set: function (offset) {
            this.assertInitialized();
            this._ndcOffset = offset;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ForwardSceneRenderPass.prototype, "camera", {
        set: function (camera) {
            this.assertInitialized();
            if (this._camera === camera) {
                return;
            }
            this._camera = camera;
            this._altered.alter('camera');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ForwardSceneRenderPass.prototype, "clearColor", {
        set: function (color) {
            this._clearColor = color;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ForwardSceneRenderPass.prototype, "program", {
        set: function (program) {
            this._program = program;
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        initializable_1.Initializable.initialize()
    ], ForwardSceneRenderPass.prototype, "initialize", null);
    __decorate([
        initializable_1.Initializable.uninitialize()
    ], ForwardSceneRenderPass.prototype, "uninitialize", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], ForwardSceneRenderPass.prototype, "update", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], ForwardSceneRenderPass.prototype, "frame", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], ForwardSceneRenderPass.prototype, "drawCalls", null);
    return ForwardSceneRenderPass;
}(scenerenderpass_1.SceneRenderPass));
exports.ForwardSceneRenderPass = ForwardSceneRenderPass;


/***/ }),

/***/ "./scene/geometrycomponent.ts":
/*!************************************!*\
  !*** ./scene/geometrycomponent.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var scenenodecomponent_1 = __webpack_require__(/*! ./scenenodecomponent */ "./scene/scenenodecomponent.ts");
var GeometryComponent = (function (_super) {
    __extends(GeometryComponent, _super);
    function GeometryComponent() {
        return _super.call(this, 'GeometryComponent') || this;
    }
    Object.defineProperty(GeometryComponent.prototype, "geometry", {
        get: function () {
            return this._geometry;
        },
        set: function (geometry) {
            this._geometry = geometry;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GeometryComponent.prototype, "material", {
        get: function () {
            return this._material;
        },
        set: function (material) {
            this._material = material;
        },
        enumerable: true,
        configurable: true
    });
    return GeometryComponent;
}(scenenodecomponent_1.SceneNodeComponent));
exports.GeometryComponent = GeometryComponent;


/***/ }),

/***/ "./scene/index.ts":
/*!************************!*\
  !*** ./scene/index.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var forwardscenerenderpass_1 = __webpack_require__(/*! ./forwardscenerenderpass */ "./scene/forwardscenerenderpass.ts");
exports.ForwardSceneRenderPass = forwardscenerenderpass_1.ForwardSceneRenderPass;
var scenenode_1 = __webpack_require__(/*! ./scenenode */ "./scene/scenenode.ts");
exports.SceneNode = scenenode_1.SceneNode;
var scenenodecomponent_1 = __webpack_require__(/*! ./scenenodecomponent */ "./scene/scenenodecomponent.ts");
exports.SceneNodeComponent = scenenodecomponent_1.SceneNodeComponent;
var transformcomponent_1 = __webpack_require__(/*! ./transformcomponent */ "./scene/transformcomponent.ts");
exports.TransformComponent = transformcomponent_1.TransformComponent;
var geometrycomponent_1 = __webpack_require__(/*! ./geometrycomponent */ "./scene/geometrycomponent.ts");
exports.GeometryComponent = geometrycomponent_1.GeometryComponent;
var material_1 = __webpack_require__(/*! ./material */ "./scene/material.ts");
exports.Material = material_1.Material;
var scenerenderpass_1 = __webpack_require__(/*! ./scenerenderpass */ "./scene/scenerenderpass.ts");
exports.SceneRenderPass = scenerenderpass_1.SceneRenderPass;


/***/ }),

/***/ "./scene/material.ts":
/*!***************************!*\
  !*** ./scene/material.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Material = (function () {
    function Material(context, name) {
        this._context = context;
        this._name = name;
        this._isTransparent = false;
    }
    Object.defineProperty(Material.prototype, "name", {
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "isTransparent", {
        get: function () {
            return this._isTransparent;
        },
        set: function (val) {
            this._isTransparent = val;
        },
        enumerable: true,
        configurable: true
    });
    return Material;
}());
exports.Material = Material;


/***/ }),

/***/ "./scene/scenenode.ts":
/*!****************************!*\
  !*** ./scene/scenenode.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var SceneNode = (function () {
    function SceneNode(name) {
        this._nodes = new Array();
        this._components = new Array();
        this._name = name;
        this._parent = undefined;
    }
    SceneNode.prototype.traverse = function (callback) {
        callback(this);
        for (var _i = 0, _a = this._nodes; _i < _a.length; _i++) {
            var child = _a[_i];
            child.traverse(callback);
        }
    };
    SceneNode.prototype.addNode = function (node) {
        node._parent = this;
        this._nodes.push(node);
        return node;
    };
    SceneNode.prototype.addComponent = function (component) {
        this._components.push(component);
        return component;
    };
    SceneNode.prototype.componentsOfType = function (type) {
        return this._components.filter(function (component) { return type === component.type; });
    };
    Object.defineProperty(SceneNode.prototype, "name", {
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneNode.prototype, "parent", {
        get: function () {
            return this._parent;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneNode.prototype, "nodes", {
        get: function () {
            return this._nodes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneNode.prototype, "components", {
        get: function () {
            return this._components;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneNode.prototype, "isLeaf", {
        get: function () {
            return this._nodes.length === 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneNode.prototype, "isRoot", {
        get: function () {
            return this._parent === undefined;
        },
        enumerable: true,
        configurable: true
    });
    return SceneNode;
}());
exports.SceneNode = SceneNode;


/***/ }),

/***/ "./scene/scenenodecomponent.ts":
/*!*************************************!*\
  !*** ./scene/scenenodecomponent.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var SceneNodeComponent = (function () {
    function SceneNodeComponent(type) {
        this._type = type;
    }
    Object.defineProperty(SceneNodeComponent.prototype, "type", {
        get: function () {
            return this._type;
        },
        enumerable: true,
        configurable: true
    });
    return SceneNodeComponent;
}());
exports.SceneNodeComponent = SceneNodeComponent;


/***/ }),

/***/ "./scene/scenerenderpass.ts":
/*!**********************************!*\
  !*** ./scene/scenerenderpass.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var initializable_1 = __webpack_require__(/*! ../initializable */ "./initializable.ts");
var SceneRenderPass = (function (_super) {
    __extends(SceneRenderPass, _super);
    function SceneRenderPass() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(SceneRenderPass.prototype, "scene", {
        get: function () {
            return this._scene;
        },
        set: function (scene) {
            this._scene = scene;
            if (this._scene !== undefined) {
                this.preprocessScene();
            }
        },
        enumerable: true,
        configurable: true
    });
    return SceneRenderPass;
}(initializable_1.Initializable));
exports.SceneRenderPass = SceneRenderPass;


/***/ }),

/***/ "./scene/transformcomponent.ts":
/*!*************************************!*\
  !*** ./scene/transformcomponent.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var scenenodecomponent_1 = __webpack_require__(/*! ./scenenodecomponent */ "./scene/scenenodecomponent.ts");
var TransformComponent = (function (_super) {
    __extends(TransformComponent, _super);
    function TransformComponent(transform) {
        var _this = _super.call(this, 'TransformComponent') || this;
        _this._transform = transform;
        return _this;
    }
    Object.defineProperty(TransformComponent.prototype, "transform", {
        get: function () {
            return this._transform;
        },
        enumerable: true,
        configurable: true
    });
    return TransformComponent;
}(scenenodecomponent_1.SceneNodeComponent));
exports.TransformComponent = TransformComponent;


/***/ }),

/***/ "./shader.ts":
/*!*******************!*\
  !*** ./shader.ts ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var object_1 = __webpack_require__(/*! ./object */ "./object.ts");
var Shader = (function (_super) {
    __extends(Shader, _super);
    function Shader(context, type, identifier) {
        var _this = _super.call(this, context, identifier) || this;
        _this._compiled = false;
        var gl = context.gl;
        if (identifier === undefined) {
            switch (type) {
                case context.gl.FRAGMENT_SHADER:
                    identifier = 'FragmentShader';
                    break;
                case context.gl.VERTEX_SHADER:
                    identifier = 'VertexShader';
                    break;
                default:
                    auxiliaries_1.assert(false, "expected either a FRAGMENT_SHADER (" + gl.FRAGMENT_SHADER + ") " +
                        ("or a VERTEX_SHADER (" + gl.VERTEX_SHADER + "), given " + type));
            }
        }
        _this._type = type;
        return _this;
    }
    Shader.prototype.create = function (source, compile) {
        if (compile === void 0) { compile = true; }
        var gl = this._context.gl;
        this._object = gl.createShader(this._type);
        this._valid = gl.isShader(this._object);
        this._compiled = false;
        auxiliaries_1.assert(this._object instanceof WebGLShader, "expected WebGLShader object to be created");
        if (source) {
            this.source = source;
        }
        if (source && compile) {
            this.compile();
        }
        return this._object;
    };
    Shader.prototype.delete = function () {
        auxiliaries_1.assert(this._object !== undefined, "expected WebGLShader object");
        this._context.gl.deleteShader(this._object);
        this._object = undefined;
        this._valid = false;
        this._compiled = false;
    };
    Shader.prototype.compile = function () {
        var gl = this._context.gl;
        var source = this.sourceWithReplacements;
        if (this._context.isWebGL2) {
            source = "#version 300 es\n" + source;
        }
        gl.shaderSource(this._object, source);
        gl.compileShader(this._object);
        this._compiled = gl.getShaderParameter(this._object, gl.COMPILE_STATUS);
        if (!this._compiled) {
            var infoLog = gl.getShaderInfoLog(this._object);
            auxiliaries_1.log(auxiliaries_1.LogLevel.Error, "compilation of shader '" + this._identifier + "' failed: " + infoLog);
        }
    };
    Shader.prototype.replace = function (searchValue, replaceValue) {
        if (this._replacements === undefined) {
            this._replacements = new Map();
        }
        this._replacements.set(searchValue, replaceValue);
    };
    Object.defineProperty(Shader.prototype, "type", {
        get: function () {
            this.assertInitialized();
            return this._type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Shader.prototype, "source", {
        get: function () {
            this.assertInitialized();
            return this._source;
        },
        set: function (source) {
            if (this._source === source) {
                return;
            }
            this._source = source;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Shader.prototype, "sourceWithReplacements", {
        get: function () {
            if (this._replacements === undefined) {
                return this._source;
            }
            var source = this._source;
            this._replacements.forEach(function (replaceValue, searchValue) {
                var searchRegex = searchValue.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                source = source.replace(new RegExp(searchRegex, 'g'), replaceValue);
            });
            return source;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Shader.prototype, "compiled", {
        get: function () {
            this.assertInitialized();
            return this._compiled;
        },
        enumerable: true,
        configurable: true
    });
    return Shader;
}(object_1.AbstractObject));
exports.Shader = Shader;


/***/ }),

/***/ "./shaders/accumulate.frag":
/*!*********************************!*\
  !*** ./shaders/accumulate.frag ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nprecision lowp float;\n\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else \n    #define varying in\n#endif\n\n\n\n#if __VERSION__ == 100\n    #define fragColor gl_FragColor\n#else\n    layout(location = 0) out vec4 fragColor;\n#endif\n\n\nuniform float u_weight;\nuniform sampler2D u_accumulationTexture;\nuniform sampler2D u_currentFrameTexture;\n\nvarying vec2 v_uv;\n\n\nvoid main(void)\n{\n    vec4 accumulationColor = texture(u_accumulationTexture, v_uv);\n    vec4 currentFrameColor = texture(u_currentFrameTexture, v_uv);\n    fragColor = mix(accumulationColor, currentFrameColor, u_weight);\n}\n"

/***/ }),

/***/ "./shaders/blit.frag":
/*!***************************!*\
  !*** ./shaders/blit.frag ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nprecision highp float;\n\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else \n    #define varying in\n#endif\n\n\n\n#if __VERSION__ == 100\n    #define fragColor gl_FragColor\n#else\n    layout(location = 0) out vec4 fragColor;\n#endif\n\n\nuniform sampler2D u_source;\n\nvarying vec2 v_uv;\n\n\nvoid main(void)\n{\n    fragColor = texture(u_source, v_uv);\n}\n"

/***/ }),

/***/ "./shaders/blit.vert":
/*!***************************!*\
  !*** ./shaders/blit.vert ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nprecision lowp float;\n\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else\n    #define varying out\n#endif\n\n\n\n#if __VERSION__ == 100\n    attribute vec2 a_vertex;\n#else\n    layout(location = 0) in vec2 a_vertex;\n#endif\n\nuniform vec4 u_srcBounds; // normalized\nuniform vec4 u_dstBounds; // normalized\n\nvarying vec2 v_uv;\n\n\nvoid main(void)\n{\n    vec2 uv = a_vertex * 0.5 + 0.5;\n\n    v_uv = mix(u_srcBounds.xy, u_srcBounds.zw, uv);\n    gl_Position = vec4(a_vertex.xy, 0.0, 1.0);\n}\n"

/***/ }),

/***/ "./shaders/blit_debug.frag":
/*!*********************************!*\
  !*** ./shaders/blit_debug.frag ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nprecision highp float;\n\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else \n    #define varying in\n#endif\n\n\n\nconst float one255ths = 1.0 / 255.0;\n\nvec3 float24x1_to_uint8x3(const in float f) {\n    vec3 uint8x3 = vec3(f, fract(f * 256.0), fract(f * 65536.0));\n    return floor(uint8x3 * 256.0) * one255ths;\n}\n\nvec4 float24x1_to_uint8x4(const in float f) {\n    vec4 uint8x4 = vec4(f, fract(f * 256.0), fract(f * 65536.0), fract(f * 16777216.0));\n    return floor(uint8x4 * 256.0) * one255ths;\n}\n\nconst vec3 premultUint8x3 = vec3(255.0 / 256.0, 255.0 / 65536.0, 255.0 / 16777216.0);\nfloat uint8x3_to_float24x1(const in vec3 v) {\n    return dot(v, premultUint8x3); // a1 * b1 + a2 * b2 + a3 * b3  ;)\n}\n\nconst vec4 premultUint8x4 = vec4(255.0 / 256.0, 255.0 / 65536.0, 255.0 / 16777216.0, 255.0 / 4294967296.0);\nfloat uint8x4_to_float32x1(const in vec4 v) {\n    return dot(v, premultUint8x4); // a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4  ;)\n}\n\n\nfloat linearizeDepth(float zInNDC, float near, float far) {\n    float zLinear = 2.0 * near;\n    zLinear /= far + near - zInNDC * (far - near);\n    return zLinear;\n}\n\n\n\n#if __VERSION__ == 100\n    #define fragColor gl_FragColor\n#else\n    layout(location = 0) out vec4 fragColor;\n#endif\n\n\nuniform sampler2D u_source;\n\nuniform int u_mode; /* Debug mode. */\nuniform vec2 u_linearize; /* [ zNear, zFar ] */\n\n\nvarying vec2 v_uv;\n\n\nvoid main(void)\n{\n    vec4 source = texture(u_source, v_uv);\n\n    if(u_mode == 1) {           /* Depth */\n        source.rgb = vec3(source[0]);\n\n    } else if (u_mode == 2) {   /* DepthLinear */\n        float zLinear = linearizeDepth(source[0], u_linearize[0], u_linearize[1]);\n        source.rgb = vec3(zLinear);\n\n    } else if(u_mode == 3) {    /* DepthPacked */\n        source.rgb = float24x1_to_uint8x3(source[0]);\n\n    } else if (u_mode == 4) {   /* DepthLinearPacked */\n        float zLinear = linearizeDepth(source[0], u_linearize[0], u_linearize[1]);\n        source.rgb = float24x1_to_uint8x3(zLinear);\n    }\n\n    fragColor = source;\n}\n"

/***/ }),

/***/ "./shaders/gaussfilter.frag":
/*!**********************************!*\
  !*** ./shaders/gaussfilter.frag ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nprecision lowp float;\nprecision lowp int;\n\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else \n    #define varying in\n#endif\n\n\n#if __VERSION__ == 100\n  #define fragColor gl_FragColor\n#else\n  layout(location = 0) out vec4 fragColor;\n#endif\n\n\nuniform float u_weights[32];\nuniform vec2 u_delta;\n\nuniform sampler2D u_texture;\n\nvarying vec2 v_texCoords;\n\n\nvoid main()\n{\n    vec4 result = u_weights[0] * texture(u_texture, v_texCoords);\n    for (int i = 1; i <= $KERNEL_HALF_SIZE; i++)\n    {\n        result += u_weights[i] * texture(u_texture, v_texCoords + float(i) * u_delta);\n        result += u_weights[i] * texture(u_texture, v_texCoords - float(i) * u_delta);\n    }\n\n    fragColor = result;\n}\n"

/***/ }),

/***/ "./shaders/gaussfilter.vert":
/*!**********************************!*\
  !*** ./shaders/gaussfilter.vert ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nprecision lowp float;\nprecision lowp int;\n\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else\n    #define varying out\n#endif\n\n\n#if __VERSION__ == 100\n  attribute vec2 a_vertex;\n#else\n  layout(location = 0) in vec2 a_vertex;\n#endif\n\n\nvarying vec2 v_texCoords;\n\n\nvoid main()\n{\n    v_texCoords = a_vertex * 0.5 + 0.5;\n    gl_Position = vec4(a_vertex, 0.0, 1.0);\n}\n"

/***/ }),

/***/ "./shaders/ndcvertices.vert":
/*!**********************************!*\
  !*** ./shaders/ndcvertices.vert ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nprecision lowp float;\n\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else\n    #define varying out\n#endif\n\n\n\n#if __VERSION__ == 100\n    attribute vec2 a_vertex;\n#else\n    layout(location = 0) in vec2 a_vertex;\n#endif\n\n\nvarying vec2 v_uv;\n\n\nvoid main(void)\n{\n    v_uv = a_vertex * 0.5 + 0.5;\n\n    gl_Position = vec4(a_vertex, 0.0, 1.0);\n}\n"

/***/ }),

/***/ "./shaders/readbackdepth.frag":
/*!************************************!*\
  !*** ./shaders/readbackdepth.frag ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nprecision highp float;\n\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else \n    #define varying in\n#endif\n\n\nconst float one255ths = 1.0 / 255.0;\n\nvec3 float24x1_to_uint8x3(const in float f) {\n    vec3 uint8x3 = vec3(f, fract(f * 256.0), fract(f * 65536.0));\n    return floor(uint8x3 * 256.0) * one255ths;\n}\n\nvec4 float24x1_to_uint8x4(const in float f) {\n    vec4 uint8x4 = vec4(f, fract(f * 256.0), fract(f * 65536.0), fract(f * 16777216.0));\n    return floor(uint8x4 * 256.0) * one255ths;\n}\n\nconst vec3 premultUint8x3 = vec3(255.0 / 256.0, 255.0 / 65536.0, 255.0 / 16777216.0);\nfloat uint8x3_to_float24x1(const in vec3 v) {\n    return dot(v, premultUint8x3); // a1 * b1 + a2 * b2 + a3 * b3  ;)\n}\n\nconst vec4 premultUint8x4 = vec4(255.0 / 256.0, 255.0 / 65536.0, 255.0 / 16777216.0, 255.0 / 4294967296.0);\nfloat uint8x4_to_float32x1(const in vec4 v) {\n    return dot(v, premultUint8x4); // a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4  ;)\n}\n\n\n\n#if __VERSION__ == 100\n    #define fragDepth gl_FragColor\n#else \n    layout(location = 0) out vec4 fragDepth;\n#endif\n\n\nuniform sampler2D u_texture;\nuniform vec2 u_offset;\nuniform vec2 u_scale;\n\nvarying vec2 v_uv;\n\n\n\nvoid main(void)\n{\n    vec2 uv = vec2(v_uv.x, 1.0 - v_uv.y) * u_scale + u_offset;\n    float depth = texture(u_texture, uv).r;\n\n    fragDepth = vec4(float24x1_to_uint8x3(depth), 1.0);\n}\n"

/***/ }),

/***/ "./shadowpass.ts":
/*!***********************!*\
  !*** ./shadowpass.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var framebuffer_1 = __webpack_require__(/*! ./framebuffer */ "./framebuffer.ts");
var gaussfilter_1 = __webpack_require__(/*! ./gaussfilter */ "./gaussfilter.ts");
var initializable_1 = __webpack_require__(/*! ./initializable */ "./initializable.ts");
var renderbuffer_1 = __webpack_require__(/*! ./renderbuffer */ "./renderbuffer.ts");
var texture2d_1 = __webpack_require__(/*! ./texture2d */ "./texture2d.ts");
var wizard_1 = __webpack_require__(/*! ./wizard */ "./wizard.ts");
var ShadowPass = (function (_super) {
    __extends(ShadowPass, _super);
    function ShadowPass(context) {
        var _this = _super.call(this) || this;
        _this._gaussFilterKernelSize = 21;
        _this._context = context;
        return _this;
    }
    Object.defineProperty(ShadowPass.prototype, "shadowMapFBO", {
        get: function () {
            return this._shadowMapFBO;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShadowPass.prototype, "shadowMapTexture", {
        get: function () {
            if (this.hasBlur) {
                return this._blurTexture;
            }
            return this._shadowMapTexture;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShadowPass.prototype, "hasBlur", {
        get: function () {
            return this._shadowType !== ShadowPass.ShadowMappingType.HardLinear;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShadowPass.prototype, "blurSize", {
        get: function () {
            return this._gaussFilterKernelSize;
        },
        set: function (blurSize) {
            if (blurSize === this._gaussFilterKernelSize) {
                return;
            }
            if (this._gaussFilter !== undefined) {
                this._gaussFilter.kernelSize = blurSize;
                this._gaussFilter.standardDeviation = blurSize / 6.0;
            }
            this._gaussFilterKernelSize = blurSize;
        },
        enumerable: true,
        configurable: true
    });
    ShadowPass.prototype.resize = function (size, bind, unbind) {
        if (bind === void 0) { bind = true; }
        if (unbind === void 0) { unbind = true; }
        auxiliaries_1.assert(size[0] > 0 && size[1] > 0, 'Size has to be > 0.');
        this._shadowMapSize = size;
        this._shadowMapFBO.resize(this._shadowMapSize[0], this._shadowMapSize[1], bind, unbind);
    };
    ShadowPass.prototype.resizeBlurTexture = function (size, bind, unbind) {
        if (bind === void 0) { bind = true; }
        if (unbind === void 0) { unbind = true; }
        auxiliaries_1.assert(size[0] > 0 && size[1] > 0, 'Size has to be > 0.');
        this._blurredShadowMapSize = size;
        this._intermediateBlurFBO.resize(this._blurredShadowMapSize[0], this._blurredShadowMapSize[1], bind, unbind);
        this._blurFBO.resize(this._blurredShadowMapSize[0], this._blurredShadowMapSize[1], bind, unbind);
    };
    ShadowPass.prototype.initialize = function (shadowType, shadowMapSize, blurredShadowMapSize) {
        auxiliaries_1.assert(shadowMapSize[0] > 0 && shadowMapSize[1] > 0, 'Size has to be > 0.');
        this._shadowType = shadowType;
        this._shadowMapSize = shadowMapSize;
        if (blurredShadowMapSize !== undefined) {
            this._blurredShadowMapSize = blurredShadowMapSize;
        }
        else {
            this._blurredShadowMapSize = this._shadowMapSize;
        }
        var gl = this._context.gl;
        var gl2facade = this._context.gl2facade;
        var format = gl.RGBA;
        if (this._context.isWebGL2) {
            var gl2 = this._context.gl;
            switch (this._shadowType) {
                case ShadowPass.ShadowMappingType.HardLinear:
                case ShadowPass.ShadowMappingType.HardExponential:
                    format = gl2.RED;
                    break;
                case ShadowPass.ShadowMappingType.SoftLinear:
                    format = gl2.RG;
                    break;
                case ShadowPass.ShadowMappingType.SoftExponential:
                    format = gl2.RGBA;
                    break;
                default:
                    auxiliaries_1.assert(false, 'Unexpected value for shadowType');
            }
        }
        var _a = wizard_1.Wizard.queryInternalTextureFormat(this._context, format, wizard_1.Wizard.Precision.float), internalFormat = _a[0], type = _a[1];
        if (this._shadowType !== ShadowPass.ShadowMappingType.HardLinear && type !== gl.FLOAT) {
            auxiliaries_1.log(auxiliaries_1.LogLevel.Warning, 'floating point textures are not supported, falling back to HardLinear');
            this._shadowType = ShadowPass.ShadowMappingType.HardLinear;
        }
        var filter = gl.LINEAR;
        if (type === gl.FLOAT && !this._context.supportsTextureFloatLinear) {
            filter = gl.NEAREST;
        }
        if (type === gl2facade.HALF_FLOAT && !this._context.supportsTextureHalfFloatLinear) {
            filter = gl.NEAREST;
        }
        this._shadowMapTexture = new texture2d_1.Texture2D(this._context);
        this._shadowMapTexture.initialize(this._shadowMapSize[0], this._shadowMapSize[1], internalFormat, format, gl.FLOAT);
        this._shadowMapTexture.wrap(gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE);
        this._shadowMapTexture.filter(filter, filter);
        this._shadowMapRenderbuffer = new renderbuffer_1.Renderbuffer(this._context);
        this._shadowMapRenderbuffer.initialize(this._shadowMapSize[0], this._shadowMapSize[1], gl.DEPTH_COMPONENT16);
        this._shadowMapFBO = new framebuffer_1.Framebuffer(this._context);
        this._shadowMapFBO.initialize([[gl2facade.COLOR_ATTACHMENT0, this._shadowMapTexture],
            [gl.DEPTH_ATTACHMENT, this._shadowMapRenderbuffer]]);
        this._shadowMapFBO.clearColor([1.0, 1.0, 1.0, 1.0]);
        this._shadowMapFBO.clearDepth(1.0);
        if (this.hasBlur) {
            this._gaussFilter = new gaussfilter_1.GaussFilter(this._context);
            this._gaussFilter.kernelSize = this._gaussFilterKernelSize;
            this._gaussFilter.standardDeviation = this._gaussFilterKernelSize / 6.0;
            this._gaussFilter.initialize();
            this._intermediateBlurTexture = new texture2d_1.Texture2D(this._context, 'IntermediateBlurTexture');
            this._intermediateBlurTexture.initialize(this._blurredShadowMapSize[0], this._blurredShadowMapSize[1], internalFormat, format, gl.FLOAT);
            this._intermediateBlurTexture.wrap(gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE);
            this._intermediateBlurTexture.filter(filter, filter);
            this._intermediateBlurFBO = new framebuffer_1.Framebuffer(this._context, 'IntermediateBlurFramebuffer');
            this._intermediateBlurFBO.initialize([[gl2facade.COLOR_ATTACHMENT0, this._intermediateBlurTexture]]);
            this._intermediateBlurFBO.clearColor([1.0, 1.0, 1.0, 1.0]);
            this._intermediateBlurFBO.clearDepth(1.0);
            this._blurTexture = new texture2d_1.Texture2D(this._context, 'BlurTexture');
            this._blurTexture.initialize(this._blurredShadowMapSize[0], this._blurredShadowMapSize[1], internalFormat, format, gl.FLOAT);
            this._blurTexture.wrap(gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE);
            this._blurTexture.filter(filter, filter);
            this._blurFBO = new framebuffer_1.Framebuffer(this._context, 'BlurFramebuffer');
            this._blurFBO.initialize([[gl2facade.COLOR_ATTACHMENT0, this._blurTexture]]);
            this._blurFBO.clearColor([1.0, 1.0, 1.0, 1.0]);
            this._blurFBO.clearDepth(1.0);
        }
        return true;
    };
    ShadowPass.prototype.uninitialize = function () {
        this._shadowMapFBO.uninitialize();
        this._shadowMapRenderbuffer.uninitialize();
        this._shadowMapTexture.uninitialize();
        if (this.hasBlur) {
            this._intermediateBlurFBO.uninitialize();
            this._intermediateBlurTexture.uninitialize();
            this._blurFBO.uninitialize();
            this._blurTexture.uninitialize();
            this._gaussFilter.uninitialize();
        }
    };
    ShadowPass.prototype.frame = function (callback) {
        var gl = this._context.gl;
        gl.viewport(0, 0, this._shadowMapSize[0], this._shadowMapSize[1]);
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);
        this._shadowMapFBO.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, true, false);
        callback();
        gl.disable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LESS);
        if (this.hasBlur) {
            gl.viewport(0, 0, this._intermediateBlurFBO.width, this._intermediateBlurFBO.height);
            this._intermediateBlurFBO.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, true, false);
            this._gaussFilter.filter(this._shadowMapTexture, gaussfilter_1.GaussFilter.Direction.Horizontal);
            gl.viewport(0, 0, this._blurFBO.width, this._blurFBO.height);
            this._blurFBO.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, true, false);
            this._gaussFilter.filter(this._intermediateBlurTexture, gaussfilter_1.GaussFilter.Direction.Vertical);
        }
    };
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], ShadowPass.prototype, "resize", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], ShadowPass.prototype, "resizeBlurTexture", null);
    __decorate([
        initializable_1.Initializable.initialize()
    ], ShadowPass.prototype, "initialize", null);
    __decorate([
        initializable_1.Initializable.uninitialize()
    ], ShadowPass.prototype, "uninitialize", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], ShadowPass.prototype, "frame", null);
    return ShadowPass;
}(initializable_1.Initializable));
exports.ShadowPass = ShadowPass;
(function (ShadowPass) {
    var ShadowMappingType;
    (function (ShadowMappingType) {
        ShadowMappingType[ShadowMappingType["HardLinear"] = 0] = "HardLinear";
        ShadowMappingType[ShadowMappingType["SoftLinear"] = 1] = "SoftLinear";
        ShadowMappingType[ShadowMappingType["HardExponential"] = 2] = "HardExponential";
        ShadowMappingType[ShadowMappingType["SoftExponential"] = 3] = "SoftExponential";
    })(ShadowMappingType = ShadowPass.ShadowMappingType || (ShadowPass.ShadowMappingType = {}));
})(ShadowPass = exports.ShadowPass || (exports.ShadowPass = {}));
exports.ShadowPass = ShadowPass;


/***/ }),

/***/ "./text/fontface.ts":
/*!**************************!*\
  !*** ./text/fontface.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var auxiliaries_1 = __webpack_require__(/*! ../auxiliaries */ "./auxiliaries.ts");
var texture2d_1 = __webpack_require__(/*! ../texture2d */ "./texture2d.ts");
var wizard_1 = __webpack_require__(/*! ../wizard */ "./wizard.ts");
var fetch_1 = __webpack_require__(/*! ../fetch */ "./fetch.ts");
var fontfaceloader_1 = __webpack_require__(/*! ./fontfaceloader */ "./text/fontfaceloader.ts");
var glyph_1 = __webpack_require__(/*! ./glyph */ "./text/glyph.ts");
var FontFace = (function () {
    function FontFace(context, identifier) {
        this._ascent = 0.0;
        this._descent = 0.0;
        this._lineGap = 0.0;
        this._glyphTextureExtent = [0.0, 0.0];
        this._glyphTexturePadding = [0.0, 0.0, 0.0, 0.0];
        this._glyphs = new Map();
        this._context = context;
        var gl = context.gl;
        identifier = identifier !== undefined && identifier !== "" ? identifier : this.constructor.name;
        this._glyphTexture = new texture2d_1.Texture2D(context, identifier + "GlyphAtlas");
        var internalFormat = wizard_1.Wizard.queryInternalTextureFormat(context, gl.RGBA, wizard_1.Wizard.Precision.byte);
        this._glyphTexture.initialize(1, 1, internalFormat[0], gl.RGBA, internalFormat[1]);
        this._glyphTexture.filter(gl.LINEAR, gl.LINEAR);
    }
    FontFace.fromFile = function (url, context, headless, identifier) {
        if (headless === void 0) { headless = false; }
        var transform = function (data) {
            var font = new FontFace(context, identifier);
            return fontfaceloader_1.FontFaceLoader.process(font, data, url, headless)
                .then(function (fontFace) { return fontFace; })
                .catch(function (reason) { return Promise.reject("processing font face data failed: " + reason); });
        };
        return fetch_1.fetchAsync(url, 'text').then(transform);
    };
    FontFace.prototype.hasGlyph = function (index) {
        return !!this._glyphs.get(index);
    };
    FontFace.prototype.glyph = function (index) {
        var existingGlyph = this._glyphs.get(index);
        if (existingGlyph) {
            return existingGlyph;
        }
        var glyph = new glyph_1.Glyph();
        glyph.index = index;
        return glyph;
    };
    FontFace.prototype.addGlyph = function (glyph) {
        auxiliaries_1.assert(!(this._glyphs.get(glyph.index)), 'expected glyph to not already exist');
        this._glyphs.set(glyph.index, glyph);
    };
    FontFace.prototype.arrayOfGlyphIndices = function () {
        return Array.from(this._glyphs.keys());
    };
    FontFace.prototype.depictable = function (index) {
        return this.glyph(index).depictable();
    };
    FontFace.prototype.kerning = function (index, subsequentIndex) {
        var glyph = this._glyphs.get(index);
        if (!glyph) {
            return 0.0;
        }
        return glyph.kerning(subsequentIndex);
    };
    FontFace.prototype.setKerning = function (index, subsequentIndex, kerning) {
        var glyph = this._glyphs.get(index);
        if (!glyph || !this.hasGlyph(subsequentIndex)) {
            auxiliaries_1.assert(false, "expected glyph or glyph of subsequent index to exist,                 given " + index + " and " + subsequentIndex + " respectively");
            return;
        }
        glyph.setKerning(subsequentIndex, kerning);
    };
    Object.defineProperty(FontFace.prototype, "size", {
        get: function () {
            return this._size;
        },
        set: function (size) {
            auxiliaries_1.assert(size > 0.0, "expected size to be greater than 0.0, given " + size);
            this._size = size;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FontFace.prototype, "base", {
        get: function () {
            return this._base;
        },
        set: function (base) {
            auxiliaries_1.assert(base > 0.0, "expected base to be greater than 0.0, given " + base);
            this._base = base;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FontFace.prototype, "ascent", {
        get: function () {
            return this._ascent;
        },
        set: function (ascent) {
            auxiliaries_1.assert(ascent > 0.0, "expected ascent to be greater than 0.0, given " + ascent);
            this._ascent = ascent;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FontFace.prototype, "descent", {
        get: function () {
            return this._descent;
        },
        set: function (descent) {
            this._descent = descent;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FontFace.prototype, "lineGap", {
        get: function () {
            return this._lineGap;
        },
        set: function (lineGap) {
            this._lineGap = lineGap;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FontFace.prototype, "lineHeight", {
        get: function () {
            return this.size + this.lineGap;
        },
        set: function (lineHeight) {
            auxiliaries_1.assert(this.size > 0, "expected size to be greater than zero to derive line gap from line height");
            this._lineGap = lineHeight - this.size;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FontFace.prototype, "lineSpace", {
        get: function () {
            if (this.lineHeight === 0.0) {
                return this.lineHeight;
            }
            return this.size / this.lineHeight;
        },
        set: function (lineSpace) {
            this._lineGap = this.size * (lineSpace - 1);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FontFace.prototype, "glyphTextureExtent", {
        get: function () {
            return this._glyphTextureExtent;
        },
        set: function (extent) {
            auxiliaries_1.assert(extent[0] > 0, "expected extent.x to be greater than 0.0, given " + extent[0]);
            auxiliaries_1.assert(extent[1] > 0, "expected extent.y to be greater than 0.0, given " + extent[1]);
            this._glyphTextureExtent = extent;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FontFace.prototype, "glyphTexturePadding", {
        get: function () {
            return this._glyphTexturePadding;
        },
        set: function (padding) {
            auxiliaries_1.assert(padding[0] >= 0.0, "expected padding[0] to be greater than 0.0, given " + padding[0]);
            auxiliaries_1.assert(padding[1] >= 0.0, "expected padding[1] to be greater than 0.0, given " + padding[1]);
            auxiliaries_1.assert(padding[2] >= 0.0, "expected padding[2] to be greater than 0.0, given " + padding[2]);
            auxiliaries_1.assert(padding[3] >= 0.0, "expected padding[3] to be greater than 0.0, given " + padding[3]);
            this._glyphTexturePadding = padding;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FontFace.prototype, "glyphTexture", {
        get: function () {
            return this._glyphTexture;
        },
        set: function (texture) {
            this._glyphTexture = texture;
        },
        enumerable: true,
        configurable: true
    });
    return FontFace;
}());
exports.FontFace = FontFace;


/***/ }),

/***/ "./text/fontfaceloader.ts":
/*!********************************!*\
  !*** ./text/fontfaceloader.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var auxiliaries_1 = __webpack_require__(/*! ../auxiliaries */ "./auxiliaries.ts");
var glyph_1 = __webpack_require__(/*! ./glyph */ "./text/glyph.ts");
var FontFaceLoader = (function () {
    function FontFaceLoader() {
    }
    FontFaceLoader.processInfo = function (stream, fontFace) {
        var pairs = new Map();
        var success = this.readKeyValuePairs(stream, ['size', 'padding'], pairs);
        if (!success) {
            return false;
        }
        fontFace.size = parseFloat(pairs.get('size'));
        var values = pairs.get('padding').split(',');
        if (values.length !== 4) {
            auxiliaries_1.log(auxiliaries_1.LogLevel.Warning, "expected 4 values for padding, given " + values + " (" + values.length + ")");
            return false;
        }
        var padding = [
            parseFloat(values[0]),
            parseFloat(values[1]),
            parseFloat(values[2]),
            parseFloat(values[3]),
        ];
        fontFace.glyphTexturePadding = padding;
        return true;
    };
    FontFaceLoader.processCommon = function (stream, fontFace) {
        var pairs = new Map();
        var success = this.readKeyValuePairs(stream, ['lineHeight', 'base', 'scaleW', 'scaleH'], pairs);
        if (!success) {
            return false;
        }
        fontFace.base = parseFloat(pairs.get('base'));
        if (pairs.has('ascent')) {
            fontFace.ascent = parseFloat(pairs.get('ascent'));
        }
        if (pairs.has('descent')) {
            fontFace.descent = parseFloat(pairs.get('descent'));
        }
        fontFace.lineHeight = parseFloat(pairs.get('lineHeight'));
        fontFace.glyphTextureExtent = [
            parseFloat(pairs.get('scaleW')),
            parseFloat(pairs.get('scaleH')),
        ];
        return true;
    };
    FontFaceLoader.processPage = function (stream, fontFace, url) {
        var pairs = new Map();
        var success = this.readKeyValuePairs(stream, ['file'], pairs);
        if (!success) {
            return undefined;
        }
        var path = auxiliaries_1.dirname(url);
        var page = pairs.get('file');
        page = page.replace(/['"]+/g, '');
        return fontFace.glyphTexture.fetch(path + "/" + page, false, true)
            .catch(function () { return Promise.reject("page '" + page + "' referenced in font file '" + url + "' was not found"); });
    };
    FontFaceLoader.processChar = function (stream, fontFace) {
        var pairs = new Map();
        var success = this.readKeyValuePairs(stream, ['id', 'x', 'y', 'width', 'height', 'xoffset', 'yoffset', 'xadvance'], pairs);
        if (!success) {
            return false;
        }
        var index = parseInt(pairs.get('id'), 10);
        auxiliaries_1.logIf(index <= 0.0, auxiliaries_1.LogLevel.Warning, "expected glyph index to be greater than 0, given " + index);
        var glyph = new glyph_1.Glyph();
        glyph.index = index;
        var extentScale = [
            1.0 / fontFace.glyphTextureExtent[0],
            1.0 / fontFace.glyphTextureExtent[1],
        ];
        var extent = [
            parseFloat(pairs.get('width')),
            parseFloat(pairs.get('height')),
        ];
        glyph.subTextureOrigin = [
            parseFloat(pairs.get('x')) * extentScale[0],
            1.0 - (parseFloat(pairs.get('y')) + extent[1]) * extentScale[1],
        ];
        glyph.extent = extent;
        glyph.subTextureExtent[0] = extent[0] * extentScale[0];
        glyph.subTextureExtent[1] = extent[1] * extentScale[1];
        glyph.bearingFromFontBaseAndOffset(fontFace.base, parseFloat(pairs.get('xoffset')), parseFloat(pairs.get('yoffset')));
        glyph.advance = parseFloat(pairs.get('xadvance'));
        fontFace.addGlyph(glyph);
        return true;
    };
    FontFaceLoader.processKerning = function (stream, fontFace) {
        var pairs = new Map();
        var success = this.readKeyValuePairs(stream, ['first', 'second', 'amount'], pairs);
        if (!success) {
            return false;
        }
        var first = parseInt(pairs.get('first'), 10);
        if (first <= 0.0) {
            auxiliaries_1.log(auxiliaries_1.LogLevel.Warning, "expected kerning's first to be greater than 0, given " + first);
            return false;
        }
        var second = parseInt(pairs.get('second'), 10);
        if (second <= 0.0) {
            auxiliaries_1.log(auxiliaries_1.LogLevel.Warning, "expected kerning's second to be greater than 0, given " + second);
            return false;
        }
        var kerning = parseFloat(pairs.get('amount'));
        fontFace.setKerning(first, second, kerning);
        return true;
    };
    FontFaceLoader.readKeyValuePairs = function (stream, mandatoryKeys, resultPairs) {
        var key;
        var value;
        for (var _i = 0, stream_1 = stream; _i < stream_1.length; _i++) {
            var s = stream_1[_i];
            var pair = s.split('=');
            key = pair[0];
            value = pair[1];
            resultPairs.set(key, value);
        }
        var valid = true;
        mandatoryKeys.forEach(function (key) { return valid = valid && resultPairs.has(key); });
        if (!valid) {
            auxiliaries_1.log(auxiliaries_1.LogLevel.Warning, "Not all required keys are provided! Mandatory keys: " + mandatoryKeys);
        }
        return valid;
    };
    FontFaceLoader.findAscentAndDescentIfNoneProvided = function (fontFace, size) {
        if (fontFace.ascent > 0.0 && fontFace.descent < 0.0) {
            return;
        }
        if (fontFace.ascent > 0.0) {
            fontFace.descent = fontFace.ascent - size;
        }
        if (fontFace.descent < 0.0) {
            fontFace.ascent = fontFace.descent - size;
        }
        var maximumYBearing = Number.MIN_VALUE;
        for (var _i = 0, _a = fontFace.arrayOfGlyphIndices(); _i < _a.length; _i++) {
            var i = _a[_i];
            if (fontFace.glyph(i).extent[1] === 0.0) {
                continue;
            }
            maximumYBearing = Math.max(fontFace.glyph(i).bearing[1], maximumYBearing);
        }
        fontFace.ascent = maximumYBearing;
        fontFace.descent = fontFace.ascent - size;
        auxiliaries_1.log(auxiliaries_1.LogLevel.Debug, "ascent not specified, derived " + fontFace.ascent + " from maximum y-offset");
    };
    FontFaceLoader.process = function (fontFace, data, url, headless) {
        if (headless === void 0) { headless = false; }
        var lines = data.split('\n');
        var promises = new Array();
        var status = true;
        for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {
            var line = lines_1[_i];
            var attributes = line.split(' ');
            var identifier = attributes[0];
            attributes = attributes.slice(1);
            switch (identifier) {
                case 'info':
                    status = this.processInfo(attributes, fontFace);
                    break;
                case 'common':
                    status = this.processCommon(attributes, fontFace);
                    break;
                case 'page':
                    if (headless) {
                        break;
                    }
                    var promise = this.processPage(attributes, fontFace, url);
                    if (promise !== undefined) {
                        promises.push(promise);
                    }
                    break;
                case 'char':
                    status = this.processChar(attributes, fontFace);
                    break;
                case 'kerning':
                    this.processKerning(attributes, fontFace);
                    break;
                default:
                    break;
            }
            if (status === false) {
                break;
            }
        }
        FontFaceLoader.findAscentAndDescentIfNoneProvided(fontFace, fontFace.size);
        if (fontFace.size <= 0.0) {
            auxiliaries_1.log(auxiliaries_1.LogLevel.Warning, "expected fontFace.size to be greater than 0, given " + fontFace.size);
        }
        return Promise.all(promises).then(function () { return fontFace; });
    };
    return FontFaceLoader;
}());
exports.FontFaceLoader = FontFaceLoader;


/***/ }),

/***/ "./text/glyph.frag":
/*!*************************!*\
  !*** ./text/glyph.frag ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision mediump float;\n\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else \n    #define varying in\n#endif\n\n\n\n#if __VERSION__ == 100\n    #define fragColor gl_FragColor\n\n    #ifdef GL_OES_standard_derivatives\n        #extension GL_OES_standard_derivatives : enable\n        #define AASTEP\n    #endif\n\n#else\n    layout(location = 0) out vec4 fragColor;\n\n    #define AASTEP\n\n#endif\n\n\nuniform sampler2D u_glyphs;\nuniform vec4 u_color;\nuniform float u_aaStepScale;\nuniform int u_aaSampling;\n\nvarying vec2 v_uv;\n\nconst int channel = 0;\n\n\nfloat aastep(float t, float value)\n{\n#ifdef AASTEP\n    /* float afwidth = length(vec2(dFdx(value), dFdy(value))) * u_aaStepScale; */\n    float afwidth = fwidth(value) * u_aaStepScale;\n    /* The aa step scale is more of a hack to provide seemingly smoother (e.g., >= 1.0) or crisper (e.g., between 0.0\n     * and 1.0) contours without specific sampling. It's just scaling the outcome of the derivatives.\n     */\n\n    return smoothstep(t - afwidth, t + afwidth, value);\n#else\n    return step(t, value);\n#endif\n}\n\nfloat texStep(float t, vec2 uv)\n{\n    /*\n     * This is a workaround for a known bug in Chrome software rendering (SwiftShader), for updates follow\n     * https://issuetracker.google.com/u/1/issues/146041290\n     * Workaround: Storing the result of the texture access into another variable that then is passed as parameter.\n     */\n    float distanceValue = texture(u_glyphs, uv)[channel];\n    return step(t, distanceValue);\n}\n\nfloat texSmooth(float t, vec2 uv)\n{\n    /*\n     * This is a workaround for a known bug in Chrome software rendering (SwiftShader), for updates follow\n     * https://issuetracker.google.com/u/1/issues/146041290\n     * Workaround: Storing the result of the texture access into another variable that then is passed as parameter.\n     */\n    float distanceValue = texture(u_glyphs, uv)[channel];\n    return aastep(t, distanceValue);\n}\n\n#ifdef AASTEP\n\nfloat aastep3h(float t, vec2 uv)\n{\n    float x = dFdy(uv.x) * 1.0 / 3.0;\n\n    float v = texSmooth(t, uv + vec2( -x, 0.0))\n            + texSmooth(t, uv + vec2(0.0, 0.0))\n            + texSmooth(t, uv + vec2( +x, 0.0));\n\n    return v / 3.0;\n}\n\nfloat aastep3v(float t, vec2 uv)\n{\n    float y = dFdy(uv.y) * 1.0 / 3.0;\n\n    float v = texSmooth(t, uv + vec2( 0.0,  -y))\n            + texSmooth(t, uv + vec2( 0.0, 0.0))\n            + texSmooth(t, uv + vec2( 0.0,  +y));\n\n    return v / 3.0;\n}\n\nfloat aastep3x3(float t, vec2 uv)\n{\n    float x = dFdx(uv.x) * 1.0 / 3.0;\n    float y = dFdy(uv.y) * 1.0 / 3.0;\n\n    float v = texSmooth(t, uv + vec2(  -x, -y)) + texSmooth(t, uv + vec2(  -x, 0.0)) + texSmooth(t, uv + vec2(  -x, +y))\n            + texSmooth(t, uv + vec2( 0.0, -y)) + texSmooth(t, uv + vec2( 0.0, 0.0)) + texSmooth(t, uv + vec2( 0.0, +y))\n            + texSmooth(t, uv + vec2(  +x, -y)) + texSmooth(t, uv + vec2(  +x, 0.0)) + texSmooth(t, uv + vec2(  +x, +y));\n\n    return v / 9.0;\n}\n\nfloat aastep4x4(float t, vec2 uv)\n{\n    float x0 = dFdx(uv.x);\n    float y0 = dFdx(uv.y);\n    float x1 = x0 * 1.0 / 8.0;\n    float y1 = y0 * 1.0 / 8.0;\n    float x2 = x0 * 3.0 / 8.0;\n    float y2 = y0 * 3.0 / 8.0;\n\n    float v = texSmooth(t, uv + vec2(-x2,-y2)) + texSmooth(t, uv + vec2(-x2,-y1))\n            + texSmooth(t, uv + vec2(-x2,+y1)) + texSmooth(t, uv + vec2(-x2,+y2))\n\n            + texSmooth(t, uv + vec2(-x1,-y2)) + texSmooth(t, uv + vec2(-x1,-y1))\n            + texSmooth(t, uv + vec2(-x1,+y1)) + texSmooth(t, uv + vec2(-x1,+y2))\n\n            + texSmooth(t, uv + vec2(+x1,-y2)) + texSmooth(t, uv + vec2(+x1,-y1))\n            + texSmooth(t, uv + vec2(+x1,+y1)) + texSmooth(t, uv + vec2(+x1,+y2))\n\n            + texSmooth(t, uv + vec2(+x2,-y2)) + texSmooth(t, uv + vec2(+x2,-y1))\n            + texSmooth(t, uv + vec2(+x2,+y1)) + texSmooth(t, uv + vec2(+x2,+y2));\n\n    return v / 16.0;\n}\n\n// vec4 subpix(float r, float g, float b, vec4 fore, vec4 back)\n// {\n//     return vec4(mix(back.rgb, fore.rgb, vec3(r, g, b)), mix(back.a, fore.a, (r + b + g) / 3.0));\n// }\n\n#endif\n\nvoid main(void)\n{\n    /** @todo mipmap access? */\n\n    float a = 0.0;\n    /* When using multiframe sampling, might not be necessary and even tends to add more blur */\n#ifdef AASTEP\n    if(u_aaSampling == 0) {         // LabelRenderPass.Sampling.None\n#endif\n\n        a = texStep(0.5, v_uv);\n\n#ifdef AASTEP\n    } else if(u_aaSampling == 1) {  // LabelRenderPass.Sampling.Smooth\n        a = texSmooth(0.5, v_uv);\n    } else if(u_aaSampling == 2) {  // LabelRenderPass.Sampling.Horizontal3\n        a = aastep3h(0.5, v_uv);\n    } else if(u_aaSampling == 3) {  // LabelRenderPass.Sampling.Vertical3\n        a = aastep3v(0.5, v_uv);\n    } else if(u_aaSampling == 4) {  // LabelRenderPass.Sampling.Grid3x3\n        a = aastep3x3(0.5, v_uv);\n    } else if(u_aaSampling == 5) {  // LabelRenderPass.Sampling.Grid4x4\n        a = aastep4x4(0.5, v_uv);\n    }\n#endif\n\n    /**\n     * @todo - design decision: Don't discard fragments?, as we might need them for an id-buffer for\n     * clicking-interaction. Furthermore, using if-statement and discard can slow down performance:\n     * it's bad for IMR, TBR, TBDR and early-Z optimization\n     * https://stackoverflow.com/questions/8509051/is-discard-bad-for-program-performance-in-opengl\n     */\n    if(a <= 0.0) {\n        discard;\n    }\n    fragColor = vec4(u_color.rgb, u_color.a * a);\n\n    /* use when pre-multiplied color is required. */\n    /* fragColor = vec4(u_color.rgb * u_color.a * a, u_color.a * a); */\n}\n"

/***/ }),

/***/ "./text/glyph.ts":
/*!***********************!*\
  !*** ./text/glyph.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tuples_1 = __webpack_require__(/*! ../tuples */ "./tuples.ts");
var Glyph = (function () {
    function Glyph(index, advance) {
        if (index === void 0) { index = 0; }
        if (advance === void 0) { advance = 0; }
        this._bearing = [0.0, 0.0];
        this._extent = [0.0, 0.0];
        this._kernings = new Map();
        this._subTextureOrigin = [0.0, 0.0];
        this._subTextureExtent = [0.0, 0.0];
        this._index = index;
        this._advance = advance;
    }
    Glyph.prototype.depictable = function () {
        return this._subTextureExtent[0] > 0 && this._subTextureExtent[1] > 0;
    };
    Glyph.prototype.kerning = function (subsequentIndex) {
        var kerning = this._kernings.get(subsequentIndex);
        if (kerning !== undefined) {
            return kerning;
        }
        return 0.0;
    };
    Glyph.prototype.setKerning = function (subsequentIndex, kerning) {
        this._kernings.set(subsequentIndex, kerning);
    };
    Object.defineProperty(Glyph.prototype, "index", {
        get: function () {
            return this._index;
        },
        set: function (index) {
            this._index = index;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Glyph.prototype, "subTextureOrigin", {
        get: function () {
            return this._subTextureOrigin;
        },
        set: function (origin) {
            this._subTextureOrigin = tuples_1.clampf2(origin, 'texture origin');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Glyph.prototype, "subTextureExtent", {
        get: function () {
            return this._subTextureExtent;
        },
        set: function (extent) {
            this._subTextureExtent = tuples_1.clampf2(extent, 'texture extent');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Glyph.prototype, "bearing", {
        get: function () {
            return this._bearing;
        },
        set: function (bearing) {
            this._bearing = bearing;
        },
        enumerable: true,
        configurable: true
    });
    Glyph.prototype.bearingFromFontBaseAndOffset = function (fontBase, xOffset, yOffset) {
        this._bearing[0] = xOffset;
        this._bearing[1] = fontBase - yOffset;
    };
    Object.defineProperty(Glyph.prototype, "extent", {
        get: function () {
            return this._extent;
        },
        set: function (extent) {
            this._extent = extent;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Glyph.prototype, "advance", {
        get: function () {
            return this._advance;
        },
        set: function (advance) {
            this._advance = advance;
        },
        enumerable: true,
        configurable: true
    });
    return Glyph;
}());
exports.Glyph = Glyph;


/***/ }),

/***/ "./text/glyph.vert":
/*!*************************!*\
  !*** ./text/glyph.vert ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision mediump float;\nprecision lowp int;\n\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else\n    #define varying out\n#endif\n\n\n\n#if __VERSION__ == 100\n\n#extension GL_EXT_draw_buffers : enable\nattribute vec2 a_vertex;\n/* [ texture ll: vec2, ur: vec2 ] */\nattribute vec4 a_texCoord;\nattribute vec3 a_origin;\nattribute vec3 a_tangent;\nattribute vec3 a_up;\n\n#else\n\nin vec2 a_vertex;\n/* [ texture ll: vec2, ur: vec2 ]*/\nin vec4 a_texCoord;\nin vec3 a_origin;\nin vec3 a_tangent;\nin vec3 a_up;\n\n#endif\n\n\nuniform mat4 u_viewProjection;\nuniform vec2 u_ndcOffset;\nuniform mat4 u_transform;\nuniform bool u_dynamic;\n\nvarying vec2 v_uv;\n\n\nvoid ndcOffset(inout vec4 vertex, in vec2 offset) {\n    vertex.xy = offset * vec2(vertex.w) + vertex.xy;\n}\n\n\n\nvoid main(void)\n{\n    /* TEXTURE COORDS */\n\n    /* flip y-coordinates */\n    vec2 texExt = vec2(a_texCoord[2] - a_texCoord[0], a_texCoord[1] - a_texCoord[3]);\n\n    v_uv = a_vertex * texExt + vec2(a_texCoord[0], 1.0 - a_texCoord[1]);\n\n    /* POSITIONING */\n    /* quad data as flat array: [0, 0,  0, 1,  1, 0,  1, 1] (a_vertex), which translates to ll, lr, ul, ur corners.\n     * 2-------4\n     * |  \\    |\n     * |    \\  |\n     * 1-------3\n     * The current vertex is calculated based on the current quad corners and the tangent attributes.\n     * The following lines are optimized for MAD optimization.\n     */\n    vec3 tangentDirection = a_origin + a_vertex.x * a_tangent;\n    vec4 vertex = vec4(tangentDirection + a_vertex.y * a_up, 1.0);\n\n    if(u_dynamic) {\n        vertex = u_transform * vertex;\n    }\n    vertex = u_viewProjection * vertex;\n\n    ndcOffset(vertex, u_ndcOffset);\n    gl_Position = vertex;\n}\n"

/***/ }),

/***/ "./text/glyphvertices.ts":
/*!*******************************!*\
  !*** ./text/glyphvertices.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var GlyphVertices = (function () {
    function GlyphVertices(numberOfGlyphs) {
        var length = Math.max(0, numberOfGlyphs);
        this._texCoords = new Float32Array(length * GlyphVertices.FLOATS_PER_TEXCOORD);
        this._origins = new Float32Array(length * GlyphVertices.FLOATS_PER_ORIGIN);
        this._tangents = new Float32Array(length * GlyphVertices.FLOATS_PER_TANGENT);
        this._ups = new Float32Array(length * GlyphVertices.FLOATS_PER_UP);
    }
    GlyphVertices.concat = function (array) {
        var length = 0;
        array.forEach(function (vertices) { return length += vertices ? vertices.length : 0; });
        var concatenated = new GlyphVertices(length);
        var offset = 0;
        for (var index = 0; index < array.length; ++index) {
            var vertices = array[index];
            if (vertices === undefined || vertices.length === 0) {
                continue;
            }
            concatenated._texCoords.set(vertices._texCoords, offset * GlyphVertices.FLOATS_PER_TEXCOORD);
            concatenated._origins.set(vertices._origins, offset * GlyphVertices.FLOATS_PER_ORIGIN);
            concatenated._tangents.set(vertices._tangents, offset * GlyphVertices.FLOATS_PER_TANGENT);
            concatenated._ups.set(vertices._ups, offset * GlyphVertices.FLOATS_PER_UP);
            offset += vertices.length;
        }
        return concatenated;
    };
    GlyphVertices.prototype.shrink = function (numberOfGlyphs) {
        var length = Math.max(0, numberOfGlyphs);
        if (this.length === length) {
            return;
        }
        var shrink = function (array, length, components) {
            return array = new Float32Array(array.buffer.slice(0, length * array.BYTES_PER_ELEMENT * components), 0, length * components);
        };
        shrink(this._texCoords, length, GlyphVertices.FLOATS_PER_TEXCOORD);
        shrink(this._origins, length, GlyphVertices.FLOATS_PER_ORIGIN);
        shrink(this._ups, length, GlyphVertices.FLOATS_PER_TANGENT);
        shrink(this._tangents, length, GlyphVertices.FLOATS_PER_UP);
    };
    GlyphVertices.prototype.uvLowerLeft = function (index) {
        var begin = index * GlyphVertices.FLOATS_PER_TEXCOORD + 0;
        return this._texCoords.subarray(begin, begin + 2);
    };
    GlyphVertices.prototype.uvUpperRight = function (index) {
        var begin = index * GlyphVertices.FLOATS_PER_TEXCOORD + 2;
        return this._texCoords.subarray(begin, begin + 2);
    };
    GlyphVertices.prototype.origin = function (index) {
        var begin = index * GlyphVertices.FLOATS_PER_ORIGIN;
        return this._origins.subarray(begin, begin + GlyphVertices.FLOATS_PER_ORIGIN);
    };
    GlyphVertices.prototype.tangent = function (index) {
        var begin = index * GlyphVertices.FLOATS_PER_TANGENT;
        return this._tangents.subarray(begin, begin + GlyphVertices.FLOATS_PER_TANGENT);
    };
    GlyphVertices.prototype.up = function (index) {
        var begin = index * GlyphVertices.FLOATS_PER_UP;
        return this._ups.subarray(begin, begin + GlyphVertices.FLOATS_PER_UP);
    };
    Object.defineProperty(GlyphVertices.prototype, "length", {
        get: function () {
            return this._origins.length / GlyphVertices.FLOATS_PER_ORIGIN;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GlyphVertices.prototype, "origins", {
        get: function () {
            return this._origins;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GlyphVertices.prototype, "tangents", {
        get: function () {
            return this._tangents;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GlyphVertices.prototype, "ups", {
        get: function () {
            return this._ups;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GlyphVertices.prototype, "texCoords", {
        get: function () {
            return this._texCoords;
        },
        enumerable: true,
        configurable: true
    });
    GlyphVertices.FLOATS_PER_TEXCOORD = 4;
    GlyphVertices.FLOATS_PER_ORIGIN = 3;
    GlyphVertices.FLOATS_PER_TANGENT = 3;
    GlyphVertices.FLOATS_PER_UP = 3;
    return GlyphVertices;
}());
exports.GlyphVertices = GlyphVertices;


/***/ }),

/***/ "./text/index.ts":
/*!***********************!*\
  !*** ./text/index.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var fontface_1 = __webpack_require__(/*! ./fontface */ "./text/fontface.ts");
exports.FontFace = fontface_1.FontFace;
var glyphvertices_1 = __webpack_require__(/*! ./glyphvertices */ "./text/glyphvertices.ts");
exports.GlyphVertices = glyphvertices_1.GlyphVertices;
var label_1 = __webpack_require__(/*! ./label */ "./text/label.ts");
exports.Label = label_1.Label;
var labelgeometry_1 = __webpack_require__(/*! ./labelgeometry */ "./text/labelgeometry.ts");
exports.LabelGeometry = labelgeometry_1.LabelGeometry;
var labelrenderpass_1 = __webpack_require__(/*! ./labelrenderpass */ "./text/labelrenderpass.ts");
exports.LabelRenderPass = labelrenderpass_1.LabelRenderPass;
var position2dlabel_1 = __webpack_require__(/*! ./position2dlabel */ "./text/position2dlabel.ts");
exports.Position2DLabel = position2dlabel_1.Position2DLabel;
var position3dlabel_1 = __webpack_require__(/*! ./position3dlabel */ "./text/position3dlabel.ts");
exports.Position3DLabel = position3dlabel_1.Position3DLabel;
var projected3dlabel_1 = __webpack_require__(/*! ./projected3dlabel */ "./text/projected3dlabel.ts");
exports.Projected3DLabel = projected3dlabel_1.Projected3DLabel;
var text_1 = __webpack_require__(/*! ./text */ "./text/text.ts");
exports.Text = text_1.Text;
var typesetter_1 = __webpack_require__(/*! ./typesetter */ "./text/typesetter.ts");
exports.Typesetter = typesetter_1.Typesetter;


/***/ }),

/***/ "./text/label.ts":
/*!***********************!*\
  !*** ./text/label.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "../node_modules/gl-matrix/esm/index.js");
var changelookup_1 = __webpack_require__(/*! ../changelookup */ "./changelookup.ts");
var color_1 = __webpack_require__(/*! ../color */ "./color.ts");
var glyphvertices_1 = __webpack_require__(/*! ./glyphvertices */ "./text/glyphvertices.ts");
var text_1 = __webpack_require__(/*! ./text */ "./text/text.ts");
var Label = (function () {
    function Label(text, type, fontFace) {
        this._alignment = Label.Alignment.Left;
        this._lineAnchor = Label.LineAnchor.Baseline;
        this._lineWidth = NaN;
        this._fontSizeUnit = Label.Unit.World;
        this._color = new color_1.Color(Label.DEFAULT_COLOR);
        this._altered = Object.assign(new changelookup_1.ChangeLookup(), {
            any: false, color: false, resources: false, text: false, typesetting: false,
            static: false, dynamic: false,
        });
        this._wrap = false;
        this._elide = Label.Elide.None;
        this._ellipsis = Label.DEFAULT_ELLIPSIS;
        this._text = text;
        this._type = type;
        this._staticTransform = gl_matrix_1.mat4.create();
        this._dynamicTransform = gl_matrix_1.mat4.create();
        this._extent = [0, 0];
        if (fontFace) {
            this._fontFace = fontFace;
        }
    }
    Label.devicePixelRatio = function () {
        if (window === undefined || typeof window.devicePixelRatio !== 'number') {
            return 1.0;
        }
        return window.devicePixelRatio;
    };
    Label.prototype.vertices = function () {
        var vertices = new glyphvertices_1.GlyphVertices(this.length + this.ellipsis.length);
        return vertices;
    };
    Label.prototype.charAt = function (index) {
        return this._text.charAt(index);
    };
    Label.prototype.charCodeAt = function (index) {
        return this._text.charCodeAt(index);
    };
    Label.prototype.lineFeedAt = function (index) {
        return this.charAt(index) === this.lineFeed;
    };
    Label.prototype.kerningBefore = function (index) {
        if (index < 1 || index > this.length) {
            return NaN;
        }
        return this._fontFace.kerning(this.charCodeAt(index - 1), this.charCodeAt(index));
    };
    Label.prototype.kerningAfter = function (index) {
        if (index < 0 || index > this.length - 1) {
            return NaN;
        }
        return this._fontFace.kerning(this.charCodeAt(index), this.charCodeAt(index + 1));
    };
    Label.prototype.advance = function (index) {
        if (index < 0 || index > this.length) {
            return NaN;
        }
        return this._fontFace.glyph(this.charCodeAt(index)).advance;
    };
    Label.prototype.toString = function () {
        if (this._text instanceof text_1.Text) {
            return this._text.text;
        }
        return this._text;
    };
    Label.prototype.reset = function () {
        this._altered.reset();
    };
    Object.defineProperty(Label.prototype, "text", {
        get: function () {
            return this._text;
        },
        set: function (text) {
            this._altered.alter('text');
            this._text = text;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "type", {
        get: function () {
            return this._type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "length", {
        get: function () {
            return this._text.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "lineFeed", {
        get: function () {
            if (this._text instanceof text_1.Text) {
                return this._text.lineFeed;
            }
            return text_1.Text.DEFAULT_LINE_FEED;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "wrap", {
        get: function () {
            return this._wrap;
        },
        set: function (flag) {
            this._wrap = flag;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "elide", {
        get: function () {
            return this._elide;
        },
        set: function (elide) {
            this._elide = elide;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "ellipsis", {
        get: function () {
            return this._ellipsis;
        },
        set: function (ellipsis) {
            if (this._ellipsis === ellipsis) {
                return;
            }
            this._ellipsis = ellipsis;
            if (this._elide !== Label.Elide.None) {
                this._altered.alter('typesetting');
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "lineWidth", {
        get: function () {
            return this._lineWidth * this._fontFace.size / this.fontSize;
        },
        set: function (lineWidth) {
            if (this._lineWidth === lineWidth) {
                return;
            }
            this._lineWidth = lineWidth;
            this._altered.alter('typesetting');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "alignment", {
        get: function () {
            return this._alignment;
        },
        set: function (alignment) {
            if (this._alignment === alignment) {
                return;
            }
            this._alignment = alignment;
            this._altered.alter('typesetting');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "lineAnchor", {
        get: function () {
            return this._lineAnchor;
        },
        set: function (anchor) {
            if (this._lineAnchor === anchor) {
                return;
            }
            this._lineAnchor = anchor;
            this._altered.alter('typesetting');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "fontSize", {
        get: function () {
            return this._fontSize;
        },
        set: function (size) {
            if (this._fontSize === size) {
                return;
            }
            this._fontSize = size;
            this._altered.alter('typesetting');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "fontSizeUnit", {
        get: function () {
            return this._fontSizeUnit;
        },
        set: function (unit) {
            if (this._fontSizeUnit === unit) {
                return;
            }
            this._fontSizeUnit = unit;
            this._altered.alter('typesetting');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "fontFace", {
        get: function () {
            return this._fontFace;
        },
        set: function (fontFace) {
            if (this._fontFace === fontFace) {
                return;
            }
            this._fontFace = fontFace;
            this._altered.alter('typesetting');
            this._altered.alter('resources');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "color", {
        get: function () {
            return this._color;
        },
        set: function (color) {
            if (this._color.equals(color)) {
                return;
            }
            this._color = color;
            this._altered.alter('color');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "backgroundColor", {
        get: function () {
            return this._backgroundColor;
        },
        set: function (color) {
            if (this._backgroundColor.equals(color)) {
                return;
            }
            this._backgroundColor = color;
            this._altered.alter('color');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "staticTransform", {
        get: function () {
            var s = this.fontSize / this._fontFace.size;
            var t = gl_matrix_1.mat4.create();
            gl_matrix_1.mat4.scale(t, this._staticTransform, gl_matrix_1.vec3.fromValues(s, s, s));
            return t;
        },
        set: function (transform) {
            if (gl_matrix_1.mat4.equals(this._staticTransform, transform)) {
                return;
            }
            this._staticTransform = transform;
            this._altered.alter('static');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "dynamicTransform", {
        get: function () {
            return this._dynamicTransform;
        },
        set: function (t) {
            this._altered.alter('dynamic');
            this._dynamicTransform = t;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "extent", {
        get: function () {
            return this._extent;
        },
        set: function (e) {
            this._extent = e;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "altered", {
        get: function () {
            return this._altered.any || this._text.altered || this._color.altered;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "valid", {
        get: function () {
            return this._fontFace !== undefined && this._fontFace.glyphTexture.valid && this._text.length > 0;
        },
        enumerable: true,
        configurable: true
    });
    Label.DEFAULT_COLOR = [0.1098, 0.4588, 0.7373, 1.0];
    Label.DEFAULT_ELLIPSIS = '...';
    return Label;
}());
exports.Label = Label;
(function (Label) {
    var Type;
    (function (Type) {
        Type["Static"] = "static";
        Type["Dynamic"] = "dynamic";
    })(Type = Label.Type || (Label.Type = {}));
    var Elide;
    (function (Elide) {
        Elide["None"] = "none";
        Elide["Left"] = "left";
        Elide["Middle"] = "middle";
        Elide["Right"] = "right";
    })(Elide = Label.Elide || (Label.Elide = {}));
    var Alignment;
    (function (Alignment) {
        Alignment["Left"] = "left";
        Alignment["Center"] = "center";
        Alignment["Right"] = "right";
    })(Alignment = Label.Alignment || (Label.Alignment = {}));
    var LineAnchor;
    (function (LineAnchor) {
        LineAnchor["Top"] = "top";
        LineAnchor["Ascent"] = "ascent";
        LineAnchor["Center"] = "center";
        LineAnchor["Baseline"] = "baseline";
        LineAnchor["Descent"] = "descent";
        LineAnchor["Bottom"] = "bottom";
    })(LineAnchor = Label.LineAnchor || (Label.LineAnchor = {}));
    var Unit;
    (function (Unit) {
        Unit["World"] = "world";
        Unit["Pixel"] = "pixel";
        Unit["Mixed"] = "mixed";
    })(Unit = Label.Unit || (Label.Unit = {}));
})(Label = exports.Label || (exports.Label = {}));
exports.Label = Label;


/***/ }),

/***/ "./text/labelgeometry.ts":
/*!*******************************!*\
  !*** ./text/labelgeometry.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var auxiliaries_1 = __webpack_require__(/*! ../auxiliaries */ "./auxiliaries.ts");
var buffer_1 = __webpack_require__(/*! ../buffer */ "./buffer.ts");
var geometry_1 = __webpack_require__(/*! ../geometry */ "./geometry.ts");
var initializable_1 = __webpack_require__(/*! ../initializable */ "./initializable.ts");
var LabelGeometry = (function (_super) {
    __extends(LabelGeometry, _super);
    function LabelGeometry(context, identifier) {
        var _this = _super.call(this, context, identifier) || this;
        _this._numberOfGlyphs = 0;
        auxiliaries_1.assert(context.isWebGL2 || context.supportsInstancedArrays, "expected extension 'ANGLE_instanced_arrays' to be supported");
        identifier = identifier !== undefined && identifier !== "" ? identifier : _this.constructor.name;
        _this._vertices = new buffer_1.Buffer(context, identifier + "VBO");
        _this._buffers.push(_this._vertices);
        _this._texCoords = new buffer_1.Buffer(context, identifier + "TexCoordVBO");
        _this._buffers.push(_this._texCoords);
        _this._origins = new buffer_1.Buffer(context, identifier + "OriginVBO");
        _this._buffers.push(_this._origins);
        _this._tangents = new buffer_1.Buffer(context, identifier + "TangentVBO");
        _this._buffers.push(_this._tangents);
        _this._ups = new buffer_1.Buffer(context, identifier + "UpVBO");
        _this._buffers.push(_this._ups);
        return _this;
    }
    LabelGeometry.prototype.bindBuffers = function () {
        var gl = this.context.gl;
        var gl2facade = this.context.gl2facade;
        this._vertices.attribEnable(this._vertexLocation, 2, gl.FLOAT, false, 8, 0, true, false);
        gl2facade.vertexAttribDivisor(this._vertexLocation, 0);
        this._texCoords.attribEnable(this._texCoordLocation, 4, gl.FLOAT, false, 16, 0, true, false);
        gl2facade.vertexAttribDivisor(this._texCoordLocation, 1);
        this._origins.attribEnable(this._originLocation, 3, gl.FLOAT, false, 12, 0, true, false);
        gl2facade.vertexAttribDivisor(this._originLocation, 1);
        this._tangents.attribEnable(this._tangentLocation, 3, gl.FLOAT, false, 12, 0, true, false);
        gl2facade.vertexAttribDivisor(this._tangentLocation, 1);
        this._ups.attribEnable(this._upLocation, 3, gl.FLOAT, false, 12, 0, true, false);
        gl2facade.vertexAttribDivisor(this._upLocation, 1);
    };
    LabelGeometry.prototype.unbindBuffers = function () {
        this._vertices.attribDisable(this._vertexLocation, false, false);
        this._texCoords.attribDisable(this._texCoordLocation, false, false);
        this._origins.attribDisable(this._originLocation, false, false);
        this._tangents.attribDisable(this._tangentLocation, false, false);
        this._ups.attribDisable(this._upLocation, false, false);
    };
    LabelGeometry.prototype.initialize = function (vertexLocation, texCoordLocation, originLocation, tangentLocation, upLocation) {
        if (vertexLocation === void 0) { vertexLocation = 0; }
        if (texCoordLocation === void 0) { texCoordLocation = 1; }
        if (originLocation === void 0) { originLocation = 2; }
        if (tangentLocation === void 0) { tangentLocation = 3; }
        if (upLocation === void 0) { upLocation = 4; }
        this._vertexLocation = vertexLocation;
        this._texCoordLocation = texCoordLocation;
        this._originLocation = originLocation;
        this._tangentLocation = tangentLocation;
        this._upLocation = upLocation;
        var gl = this.context.gl;
        var valid = _super.prototype.initialize.call(this, [gl.ARRAY_BUFFER, gl.ARRAY_BUFFER, gl.ARRAY_BUFFER, gl.ARRAY_BUFFER, gl.ARRAY_BUFFER]);
        this._vertices.data(LabelGeometry.VERTICES, gl.STATIC_DRAW);
        return valid;
    };
    LabelGeometry.prototype.update = function (origins, tangents, up, texCoords) {
        this._numberOfGlyphs = origins.length / 3;
        var gl = this.context.gl;
        this._texCoords.data(texCoords, gl.STATIC_DRAW);
        this._origins.data(origins, gl.STATIC_DRAW);
        this._tangents.data(tangents, gl.STATIC_DRAW);
        this._ups.data(up, gl.STATIC_DRAW);
    };
    LabelGeometry.prototype.draw = function (offset, count) {
        if (offset === void 0) { offset = 0; }
        if (count === void 0) { count = 0; }
        var gl = this.context.gl;
        var gl2facade = this.context.gl2facade;
        this._vertices.attribEnable(this._vertexLocation, 2, gl.FLOAT, false, 8, 0, true, false);
        this._texCoords.attribEnable(this._texCoordLocation, 4, gl.FLOAT, false, 16, offset * 16, true, false);
        this._origins.attribEnable(this._originLocation, 3, gl.FLOAT, false, 12, offset * 12, true, false);
        this._tangents.attribEnable(this._tangentLocation, 3, gl.FLOAT, false, 12, offset * 12, true, false);
        this._ups.attribEnable(this._upLocation, 3, gl.FLOAT, false, 12, offset * 12, true, false);
        gl2facade.drawArraysInstanced(gl.TRIANGLE_STRIP, 0, 4, count);
    };
    Object.defineProperty(LabelGeometry.prototype, "numGlyphs", {
        get: function () {
            return this._numberOfGlyphs;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LabelGeometry.prototype, "valid", {
        get: function () {
            var validVertex = this._vertices && this._vertices.valid;
            var validTexCoord = this._texCoords && this._texCoords.valid;
            var validOrigin = this._origins && this._origins.valid;
            var validTangent = this._tangents && this._tangents.valid;
            var validUp = this._ups && this._ups.valid;
            return this.initialized && validVertex && validTexCoord && validOrigin && validTangent && validUp;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LabelGeometry.prototype, "vertexLocation", {
        get: function () {
            return this._vertexLocation;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LabelGeometry.prototype, "texCoordLocation", {
        get: function () {
            return this._texCoordLocation;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LabelGeometry.prototype, "originLocation", {
        get: function () {
            return this._originLocation;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LabelGeometry.prototype, "tangentLocation", {
        get: function () {
            return this._tangentLocation;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LabelGeometry.prototype, "upLocation", {
        get: function () {
            return this._upLocation;
        },
        enumerable: true,
        configurable: true
    });
    LabelGeometry.VERTICES = new Float32Array([0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], LabelGeometry.prototype, "draw", null);
    return LabelGeometry;
}(geometry_1.Geometry));
exports.LabelGeometry = LabelGeometry;


/***/ }),

/***/ "./text/labelrenderpass.ts":
/*!*********************************!*\
  !*** ./text/labelrenderpass.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "../node_modules/gl-matrix/esm/index.js");
var auxiliaries_1 = __webpack_require__(/*! ../auxiliaries */ "./auxiliaries.ts");
var changelookup_1 = __webpack_require__(/*! ../changelookup */ "./changelookup.ts");
var initializable_1 = __webpack_require__(/*! ../initializable */ "./initializable.ts");
var program_1 = __webpack_require__(/*! ../program */ "./program.ts");
var shader_1 = __webpack_require__(/*! ../shader */ "./shader.ts");
var texture2d_1 = __webpack_require__(/*! ../texture2d */ "./texture2d.ts");
var glyphvertices_1 = __webpack_require__(/*! ./glyphvertices */ "./text/glyphvertices.ts");
var label_1 = __webpack_require__(/*! ./label */ "./text/label.ts");
var labelgeometry_1 = __webpack_require__(/*! ./labelgeometry */ "./text/labelgeometry.ts");
var position2dlabel_1 = __webpack_require__(/*! ./position2dlabel */ "./text/position2dlabel.ts");
var position3dlabel_1 = __webpack_require__(/*! ./position3dlabel */ "./text/position3dlabel.ts");
var projected3dlabel_1 = __webpack_require__(/*! ./projected3dlabel */ "./text/projected3dlabel.ts");
var LabelRenderPass = (function (_super) {
    __extends(LabelRenderPass, _super);
    function LabelRenderPass(context) {
        var _this = _super.call(this) || this;
        _this._altered = Object.assign(new changelookup_1.ChangeLookup(), {
            any: false,
            camera: false,
            geometry: false,
            labels: false,
            aaStepScale: false,
            aaSampling: false,
        });
        _this._ndcOffset = [0.0, 0.0];
        _this._depthMask = false;
        _this._aaSampling = LabelRenderPass.Sampling.Smooth1;
        _this._labels = new Array();
        _this._ranges = new Array();
        _this._verticesPerLabel = new Array();
        _this._context = context;
        _this._depthFunc = context.gl.LESS;
        _this._program = new program_1.Program(context, 'LabelRenderProgram');
        _this._geometry = new labelgeometry_1.LabelGeometry(_this._context, 'LabelGeometry');
        _this._aaStepScale = LabelRenderPass.DEFAULT_AA_STEP_SCALE;
        return _this;
    }
    LabelRenderPass.prototype.prepare = function () {
        var frameSize = this._camera.viewport;
        for (var i = 0; i < this._labels.length; ++i) {
            var label = this._labels[i];
            var vertices = void 0;
            var forceTypeset = this._altered.labels && this._verticesPerLabel[i] === undefined;
            if (label instanceof position2dlabel_1.Position2DLabel) {
                label.frameSize = frameSize;
                vertices = label.typeset(forceTypeset);
            }
            else if (label instanceof projected3dlabel_1.Projected3DLabel) {
                label.camera = this._camera;
                vertices = label.typeset(forceTypeset);
            }
            else if (label instanceof position3dlabel_1.Position3DLabel) {
                vertices = label.typeset(forceTypeset);
            }
            if (vertices === undefined) {
                vertices = this._verticesPerLabel[i];
            }
            else {
                this._verticesPerLabel[i] = vertices;
            }
            var rangeStart = i > 0 ? this._ranges[i - 1][1] : 0;
            var rangeEnd = rangeStart + (vertices === undefined ? 0 : vertices.length);
            this._ranges[i] = [rangeStart, rangeEnd];
        }
        var data = glyphvertices_1.GlyphVertices.concat(this._verticesPerLabel);
        this._geometry.update(data.origins, data.tangents, data.ups, data.texCoords);
    };
    LabelRenderPass.prototype.initialize = function () {
        var gl = this._context.gl;
        this._geometry.initialize();
        this._context.enable(['OES_standard_derivatives']);
        var vert = new shader_1.Shader(this._context, gl.VERTEX_SHADER, 'glyph.vert');
        vert.initialize(__webpack_require__(/*! ./glyph.vert */ "./text/glyph.vert"));
        var frag = new shader_1.Shader(this._context, gl.FRAGMENT_SHADER, 'glyph.frag');
        frag.initialize(__webpack_require__(/*! ./glyph.frag */ "./text/glyph.frag"));
        this._program.initialize([vert, frag], false);
        this._program.attribute('a_vertex', this._geometry.vertexLocation);
        this._program.attribute('a_texCoord', this._geometry.texCoordLocation);
        this._program.attribute('a_origin', this._geometry.originLocation);
        this._program.attribute('a_tangent', this._geometry.tangentLocation);
        this._program.attribute('a_up', this._geometry.upLocation);
        this._program.link();
        this._uViewProjection = this._program.uniform('u_viewProjection');
        this._uNdcOffset = this._program.uniform('u_ndcOffset');
        this._uColor = this._program.uniform('u_color');
        this._uAAStepScale = this._program.uniform('u_aaStepScale');
        this._uAASampling = this._program.uniform('u_aaSampling');
        this._uTransform = this._program.uniform('u_transform');
        this._uDynamic = this._program.uniform('u_dynamic');
        this._program.bind();
        gl.uniform1i(this._program.uniform('u_glyphs'), 0);
        gl.uniform1f(this._uAAStepScale, this._aaStepScale);
        gl.uniform1i(this._uAASampling, this._aaSampling);
        this._program.unbind();
        return true;
    };
    LabelRenderPass.prototype.uninitialize = function () {
        this._geometry.uninitialize();
        this._program.uninitialize();
        this._uViewProjection = undefined;
        this._uNdcOffset = undefined;
        this._uColor = undefined;
        this._uAAStepScale = undefined;
        this._uAASampling = undefined;
        this._uTransform = undefined;
        this._uDynamic = undefined;
    };
    LabelRenderPass.prototype.update = function (override) {
        if (override === void 0) { override = false; }
        var gl = this._context.gl;
        this._program.bind();
        if (override || this._altered.camera || this._camera.altered) {
            gl.uniformMatrix4fv(this._uViewProjection, false, this._camera.viewProjection);
        }
        if (override || this._altered.aaStepScale) {
            gl.uniform1f(this._uAAStepScale, this._aaStepScale);
        }
        if (override || this._altered.aaSampling) {
            gl.uniform1i(this._uAASampling, this._aaSampling);
        }
        var labelsAltered = override || this._altered.labels || this._altered.camera || this._camera.altered;
        var i = 0;
        while (labelsAltered === false && i < this._labels.length) {
            labelsAltered = this._labels[i].altered;
            ++i;
        }
        if (labelsAltered) {
            this.prepare();
        }
        this._altered.reset();
    };
    LabelRenderPass.prototype.frame = function () {
        if (this._geometry.numGlyphs === 0 || this._labels.length === 0) {
            return;
        }
        auxiliaries_1.assert(this._target && this._target.valid, "valid target expected");
        var gl = this._context.gl;
        var size = this._target.size;
        gl.viewport(0, 0, size[0], size[1]);
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(this._depthFunc);
        if (this._depthMask === false) {
            gl.depthMask(this._depthMask);
        }
        gl.enable(gl.BLEND);
        gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        this._program.bind();
        gl.uniform2fv(this._uNdcOffset, this._ndcOffset);
        gl.uniformMatrix4fv(this._uViewProjection, false, this._camera.viewProjection);
        this._target.bind();
        this._geometry.bind();
        var range = [0, 0];
        var currentColor;
        var currentFontFace;
        var identity = gl_matrix_1.mat4.create();
        for (var i = 0; i < this._labels.length; ++i) {
            var label0 = this._labels[i];
            range[1] = this._ranges[i][1];
            if (range[0] === range[1] || (i < this._labels.length - 1 && !label0.valid)) {
                continue;
            }
            var label1 = i < this._labels.length - 1 ? this._labels[i + 1] : undefined;
            var bothStatic = label1 && label0.type === label_1.Label.Type.Static && label1.type === label_1.Label.Type.Static;
            var sameColor = label1 && label0.color.equals(label1.color);
            var sameFontFace = label1 && label0.fontFace === label1.fontFace;
            var sameUnit = label1 && label0.fontSizeUnit === label1.fontSizeUnit;
            if (label1 && (this._ranges[i + 1][0] === this._ranges[i + 1][1]
                || (bothStatic && sameColor && sameFontFace && sameUnit))) {
                continue;
            }
            var dynamic = label0.type === label_1.Label.Type.Dynamic;
            gl.uniform1i(this._uDynamic, dynamic);
            if (dynamic) {
                gl.uniformMatrix4fv(this._uTransform, false, label0.dynamicTransform);
            }
            if (currentColor === undefined || !currentColor.equals(label0.color)) {
                gl.uniform4fv(this._uColor, label0.color.rgbaF32);
                currentColor = label0.color;
            }
            if (currentFontFace !== label0.fontFace) {
                label0.fontFace.glyphTexture.bind(gl.TEXTURE0);
                currentFontFace = label0.fontFace;
            }
            switch (label0.fontSizeUnit) {
                case label_1.Label.Unit.Pixel:
                    gl.uniformMatrix4fv(this._uViewProjection, false, identity);
                    break;
                case label_1.Label.Unit.World:
                case label_1.Label.Unit.Mixed:
                default:
                    gl.uniformMatrix4fv(this._uViewProjection, false, this._camera.viewProjection);
            }
            this._geometry.draw(range[0], range[1] - range[0]);
            range[0] = range[1];
        }
        gl.bindTexture(gl.TEXTURE_2D, texture2d_1.Texture2D.DEFAULT_TEXTURE);
        if (this._depthMask === false) {
            gl.depthMask(true);
        }
        gl.depthFunc(gl.LESS);
        gl.disable(gl.DEPTH_TEST);
        gl.disable(gl.BLEND);
    };
    LabelRenderPass.prototype.unbind = function () {
        if (this._geometry.valid) {
            this._geometry.unbind();
        }
        if (this._program.valid) {
            this._program.unbind();
        }
    };
    Object.defineProperty(LabelRenderPass.prototype, "target", {
        set: function (target) {
            this.assertInitialized();
            this._target = target;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LabelRenderPass.prototype, "ndcOffset", {
        set: function (offset) {
            this.assertInitialized();
            this._ndcOffset = offset;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LabelRenderPass.prototype, "camera", {
        set: function (camera) {
            this.assertInitialized();
            if (this._camera === camera) {
                return;
            }
            this._camera = camera;
            this._altered.alter('camera');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LabelRenderPass.prototype, "depthMask", {
        get: function () {
            return this._depthMask;
        },
        set: function (flag) {
            this._depthMask = flag;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LabelRenderPass.prototype, "depthFunc", {
        get: function () {
            return this._depthFunc;
        },
        set: function (func) {
            this._depthFunc = func;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LabelRenderPass.prototype, "labels", {
        get: function () {
            return this._labels;
        },
        set: function (labels) {
            this._labels = labels;
            this._ranges.length = this._labels.length;
            this._verticesPerLabel.length = this._labels.length;
            this._verticesPerLabel.fill(undefined);
            this._altered.alter('labels');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LabelRenderPass.prototype, "aaStepScale", {
        get: function () {
            return this._aaStepScale;
        },
        set: function (scale) {
            if (this._aaStepScale === scale) {
                return;
            }
            this._aaStepScale = scale;
            this._altered.alter('aaStepScale');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LabelRenderPass.prototype, "aaSampling", {
        get: function () {
            return this._aaSampling;
        },
        set: function (sampling) {
            if (this._aaSampling === sampling) {
                return;
            }
            this._aaSampling = sampling;
            this._altered.alter('aaSampling');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LabelRenderPass.prototype, "geometry", {
        get: function () {
            return this._geometry;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LabelRenderPass.prototype, "program", {
        get: function () {
            return this._program;
        },
        enumerable: true,
        configurable: true
    });
    LabelRenderPass.DEFAULT_AA_STEP_SCALE = 0.6666;
    __decorate([
        initializable_1.Initializable.initialize()
    ], LabelRenderPass.prototype, "initialize", null);
    __decorate([
        initializable_1.Initializable.uninitialize()
    ], LabelRenderPass.prototype, "uninitialize", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], LabelRenderPass.prototype, "update", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], LabelRenderPass.prototype, "frame", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], LabelRenderPass.prototype, "unbind", null);
    return LabelRenderPass;
}(initializable_1.Initializable));
exports.LabelRenderPass = LabelRenderPass;
(function (LabelRenderPass) {
    var Sampling;
    (function (Sampling) {
        Sampling[Sampling["None"] = 0] = "None";
        Sampling[Sampling["Smooth1"] = 1] = "Smooth1";
        Sampling[Sampling["Horizontal3"] = 2] = "Horizontal3";
        Sampling[Sampling["Vertical3"] = 3] = "Vertical3";
        Sampling[Sampling["Grid3x3"] = 4] = "Grid3x3";
        Sampling[Sampling["Grid4x4"] = 5] = "Grid4x4";
    })(Sampling = LabelRenderPass.Sampling || (LabelRenderPass.Sampling = {}));
})(LabelRenderPass = exports.LabelRenderPass || (exports.LabelRenderPass = {}));
exports.LabelRenderPass = LabelRenderPass;


/***/ }),

/***/ "./text/position2dlabel.ts":
/*!*********************************!*\
  !*** ./text/position2dlabel.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "../node_modules/gl-matrix/esm/index.js");
var auxiliaries_1 = __webpack_require__(/*! ../auxiliaries */ "./auxiliaries.ts");
var gl_matrix_extensions_1 = __webpack_require__(/*! ../gl-matrix-extensions */ "./gl-matrix-extensions.ts");
var glyphvertices_1 = __webpack_require__(/*! ./glyphvertices */ "./text/glyphvertices.ts");
var label_1 = __webpack_require__(/*! ./label */ "./text/label.ts");
var typesetter_1 = __webpack_require__(/*! ./typesetter */ "./text/typesetter.ts");
var Position2DLabel = (function (_super) {
    __extends(Position2DLabel, _super);
    function Position2DLabel(text, type, fontFace) {
        var _this = _super.call(this, text, type, fontFace) || this;
        _this._position = gl_matrix_1.vec2.fromValues(0.0, 0.0);
        _this._direction = gl_matrix_1.vec2.fromValues(1.0, 0.0);
        _this._frameSize = gl_matrix_1.vec2.create();
        _this._fontSize = Position2DLabel.DEFAULT_FONTSIZE_PX;
        _this._fontSizeUnit = label_1.Label.Unit.Pixel;
        return _this;
    }
    Position2DLabel.prototype.typeset = function (force) {
        if (force === void 0) { force = false; }
        var typeset = force || this._altered.typesetting || this._altered.static || this._altered.text
            || this.text.altered;
        if (!typeset && !this._altered.dynamic && !force) {
            return undefined;
        }
        if (!this.valid) {
            return new glyphvertices_1.GlyphVertices(0);
        }
        var margins = gl_matrix_1.vec4.create();
        var transform = gl_matrix_1.mat4.create();
        gl_matrix_1.mat4.translate(transform, gl_matrix_extensions_1.m4(), gl_matrix_1.vec3.fromValues(-1.0, -1.0, 0.0));
        gl_matrix_1.mat4.scale(transform, transform, gl_matrix_1.vec3.fromValues(2.0 / this._frameSize[0], 2.0 / this._frameSize[1], 1.0));
        var marginedExtent = gl_matrix_1.vec2.sub(gl_matrix_extensions_1.v2(), gl_matrix_1.vec2.fromValues(this._frameSize[0], this._frameSize[1]), gl_matrix_1.vec2.fromValues(margins[3] + margins[1], margins[2] + margins[0]));
        var v3 = gl_matrix_1.vec3.fromValues(0.5 * marginedExtent[0], 0.5 * marginedExtent[1], 0);
        gl_matrix_1.vec3.add(v3, v3, gl_matrix_1.vec3.fromValues(margins[3], margins[2], 0.0));
        gl_matrix_1.mat4.translate(transform, transform, v3);
        gl_matrix_1.mat4.translate(transform, transform, gl_matrix_1.vec3.fromValues(this._position[0], this._position[1], 0));
        var n = gl_matrix_1.vec2.fromValues(1.0, 0.0);
        var angle = gl_matrix_1.vec2.angle(n, this._direction);
        if (n[0] * this._direction[1] - n[1] * this._direction[0] < 0.0) {
            angle = -angle;
        }
        gl_matrix_1.mat4.rotateZ(transform, transform, angle);
        switch (this._type) {
            case label_1.Label.Type.Static:
                this.staticTransform = gl_matrix_1.mat4.clone(transform);
                this.dynamicTransform = gl_matrix_extensions_1.m4();
                break;
            case label_1.Label.Type.Dynamic:
                this.staticTransform = gl_matrix_extensions_1.m4();
                this.dynamicTransform = gl_matrix_1.mat4.clone(transform);
                break;
            default:
        }
        this._altered.reset();
        this._text.altered = false;
        this._color.altered = false;
        if (!typeset) {
            return undefined;
        }
        var vertices = this.vertices();
        typesetter_1.Typesetter.typeset(this, vertices);
        return vertices;
    };
    Object.defineProperty(Position2DLabel.prototype, "frameSize", {
        get: function () {
            return this._frameSize;
        },
        set: function (size) {
            if (gl_matrix_1.vec2.equals(this._frameSize, size)) {
                return;
            }
            gl_matrix_1.vec2.max(this._frameSize, size, [1.0, 1.0]);
            this._altered.alter(this._type);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Position2DLabel.prototype, "position", {
        get: function () {
            return this._position;
        },
        set: function (position) {
            if (gl_matrix_1.vec2.equals(this._position, position)) {
                return;
            }
            this._position = gl_matrix_1.vec2.clone(position);
            this._altered.alter(this._type);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Position2DLabel.prototype, "direction", {
        get: function () {
            return this._direction;
        },
        set: function (direction) {
            gl_matrix_1.vec2.normalize(this._direction, direction);
            this._altered.alter(this._type);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Position2DLabel.prototype, "fontSizeUnit", {
        get: function () {
            return this._fontSizeUnit;
        },
        set: function (unit) {
            auxiliaries_1.logIf(unit !== label_1.Label.Unit.Pixel, auxiliaries_1.LogLevel.Warning, "font size unit other than 'px' are not supported in position-2d-label, given " + unit);
        },
        enumerable: true,
        configurable: true
    });
    Position2DLabel.DEFAULT_FONTSIZE_PX = 20;
    return Position2DLabel;
}(label_1.Label));
exports.Position2DLabel = Position2DLabel;


/***/ }),

/***/ "./text/position3dlabel.ts":
/*!*********************************!*\
  !*** ./text/position3dlabel.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "../node_modules/gl-matrix/esm/index.js");
var auxiliaries_1 = __webpack_require__(/*! ../auxiliaries */ "./auxiliaries.ts");
var gl_matrix_extensions_1 = __webpack_require__(/*! ../gl-matrix-extensions */ "./gl-matrix-extensions.ts");
var glyphvertices_1 = __webpack_require__(/*! ./glyphvertices */ "./text/glyphvertices.ts");
var label_1 = __webpack_require__(/*! ./label */ "./text/label.ts");
var typesetter_1 = __webpack_require__(/*! ./typesetter */ "./text/typesetter.ts");
var Position3DLabel = (function (_super) {
    __extends(Position3DLabel, _super);
    function Position3DLabel(text, type, fontFace) {
        var _this = _super.call(this, text, type, fontFace) || this;
        _this._position = gl_matrix_1.vec3.fromValues(0.0, 0.0, 0.0);
        _this._direction = gl_matrix_1.vec3.fromValues(1.0, 0.0, 0.0);
        _this._up = gl_matrix_1.vec3.fromValues(0.0, 1.0, 0.0);
        _this._fontSize = Position3DLabel.DEFAULT_FONTSIZE_WORLD;
        _this._fontSizeUnit = label_1.Label.Unit.World;
        return _this;
    }
    Position3DLabel.prototype.typeset = function (force) {
        if (force === void 0) { force = false; }
        var typeset = force || this._altered.typesetting || this._altered.static || this._altered.text
            || this.text.altered;
        if (!typeset && !this._altered.dynamic && !force) {
            return undefined;
        }
        if (!this.valid) {
            return new glyphvertices_1.GlyphVertices(0);
        }
        var transform = gl_matrix_1.mat4.create();
        gl_matrix_1.mat4.translate(transform, gl_matrix_extensions_1.m4(), this._position);
        var normal = gl_matrix_1.vec3.cross(gl_matrix_extensions_1.v3(), this._direction, this._up);
        var rotation = gl_matrix_1.mat4.fromValues(this._direction[0], this._direction[1], this._direction[2], 0.0, this._up[0], this._up[1], this._up[2], 0.0, normal[0], normal[1], normal[2], 0.0, 0.0, 0.0, 0.0, 1.0);
        gl_matrix_1.mat4.mul(transform, transform, rotation);
        switch (this._type) {
            case label_1.Label.Type.Static:
                this.staticTransform = gl_matrix_1.mat4.clone(transform);
                this.dynamicTransform = gl_matrix_extensions_1.m4();
                break;
            case label_1.Label.Type.Dynamic:
                this.staticTransform = gl_matrix_extensions_1.m4();
                this.dynamicTransform = gl_matrix_1.mat4.clone(transform);
                break;
            default:
        }
        this._altered.reset();
        this._text.altered = false;
        this._color.altered = false;
        if (!typeset) {
            return undefined;
        }
        var vertices = this.vertices();
        typesetter_1.Typesetter.typeset(this, vertices);
        return vertices;
    };
    Object.defineProperty(Position3DLabel.prototype, "position", {
        get: function () {
            return this._position;
        },
        set: function (position) {
            this._position = gl_matrix_1.vec3.clone(position);
            this._altered.alter(this._type);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Position3DLabel.prototype, "direction", {
        get: function () {
            return this._direction;
        },
        set: function (direction) {
            gl_matrix_1.vec3.normalize(this._direction, direction);
            this._altered.alter(this._type);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Position3DLabel.prototype, "up", {
        get: function () {
            return this._up;
        },
        set: function (up) {
            this._up = gl_matrix_1.vec3.normalize(this._up, up);
            this._altered.alter(this._type);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Position3DLabel.prototype, "fontSizeUnit", {
        get: function () {
            return this._fontSizeUnit;
        },
        set: function (unit) {
            auxiliaries_1.logIf(unit !== label_1.Label.Unit.World, auxiliaries_1.LogLevel.Warning, "font size unit other than 'world' are not supported in position-3d-label, given " + unit);
        },
        enumerable: true,
        configurable: true
    });
    Position3DLabel.DEFAULT_FONTSIZE_WORLD = 0.05;
    return Position3DLabel;
}(label_1.Label));
exports.Position3DLabel = Position3DLabel;


/***/ }),

/***/ "./text/projected3dlabel.ts":
/*!**********************************!*\
  !*** ./text/projected3dlabel.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "../node_modules/gl-matrix/esm/index.js");
var auxiliaries_1 = __webpack_require__(/*! ../auxiliaries */ "./auxiliaries.ts");
var gl_matrix_extensions_1 = __webpack_require__(/*! ../gl-matrix-extensions */ "./gl-matrix-extensions.ts");
var glyphvertices_1 = __webpack_require__(/*! ./glyphvertices */ "./text/glyphvertices.ts");
var label_1 = __webpack_require__(/*! ./label */ "./text/label.ts");
var typesetter_1 = __webpack_require__(/*! ./typesetter */ "./text/typesetter.ts");
var Projected3DLabel = (function (_super) {
    __extends(Projected3DLabel, _super);
    function Projected3DLabel(text, type, fontFace) {
        var _this = _super.call(this, text, type, fontFace) || this;
        _this._position = gl_matrix_1.vec3.fromValues(0.0, 0.0, 0.0);
        _this._direction = gl_matrix_1.vec2.fromValues(1.0, 0.0);
        _this._fontSize = Projected3DLabel.DEFAULT_FONTSIZE_PX;
        _this._fontSizeUnit = label_1.Label.Unit.Mixed;
        return _this;
    }
    Projected3DLabel.prototype.typeset = function (force) {
        if (force === void 0) { force = false; }
        var typeset = force || this._altered.typesetting || this._altered.static || this._altered.text
            || this.text.altered;
        if (!typeset && !this._altered.dynamic && !force) {
            return undefined;
        }
        if (!this.valid || this._camera === undefined) {
            return new glyphvertices_1.GlyphVertices(0);
        }
        var margins = gl_matrix_1.vec4.create();
        var ppiScale = 1;
        var transform = gl_matrix_1.mat4.create();
        gl_matrix_1.mat4.translate(transform, transform, gl_matrix_1.vec3.fromValues(-1.0, -1.0, 0.0));
        gl_matrix_1.mat4.scale(transform, transform, gl_matrix_1.vec3.fromValues(2.0 / this._camera.viewport[0], 2.0 / this._camera.viewport[1], 1.0));
        gl_matrix_1.mat4.scale(transform, transform, gl_matrix_1.vec3.fromValues(ppiScale, ppiScale, ppiScale));
        var marginedExtent = gl_matrix_1.vec2.create();
        gl_matrix_1.vec2.sub(marginedExtent, gl_matrix_1.vec2.fromValues(this._camera.viewport[0] / ppiScale, this._camera.viewport[1] / ppiScale), gl_matrix_1.vec2.fromValues(margins[3] + margins[1], margins[2] + margins[0]));
        var v3 = gl_matrix_1.vec3.fromValues(0.5 * marginedExtent[0], 0.5 * marginedExtent[1], 0);
        gl_matrix_1.vec3.add(v3, v3, gl_matrix_1.vec3.fromValues(margins[3], margins[2], 0.0));
        gl_matrix_1.mat4.translate(transform, transform, v3);
        var anchor = gl_matrix_1.vec4.fromValues(this._position[0], this._position[1], this._position[2], 1);
        gl_matrix_1.vec4.transformMat4(anchor, anchor, this._camera.viewProjection);
        var translation = gl_matrix_1.mat4.create();
        var w = anchor[3];
        gl_matrix_1.mat4.translate(translation, translation, gl_matrix_1.vec3.fromValues(anchor[0] / w, anchor[1] / w, anchor[2] / w));
        gl_matrix_1.mat4.mul(transform, translation, transform);
        var n = gl_matrix_1.vec2.fromValues(1.0, 0.0);
        var angle = gl_matrix_1.vec2.angle(n, this._direction);
        if (n[0] * this._direction[1] - n[1] * this._direction[0] < 0.0) {
            angle = -angle;
        }
        gl_matrix_1.mat4.rotateZ(transform, transform, angle);
        if (this._camera.viewProjectionInverse) {
            gl_matrix_1.mat4.mul(transform, this._camera.viewProjectionInverse, transform);
        }
        else {
            auxiliaries_1.log(auxiliaries_1.LogLevel.Warning, "camera.viewProjectionInverse is null");
        }
        switch (this._type) {
            case label_1.Label.Type.Static:
                this.staticTransform = gl_matrix_1.mat4.clone(transform);
                this.dynamicTransform = gl_matrix_extensions_1.m4();
                break;
            case label_1.Label.Type.Dynamic:
                this.staticTransform = gl_matrix_extensions_1.m4();
                this.dynamicTransform = gl_matrix_1.mat4.clone(transform);
                break;
            default:
        }
        this._altered.reset();
        this._text.altered = false;
        this._color.altered = false;
        if (!typeset) {
            return undefined;
        }
        var vertices = this.vertices();
        typesetter_1.Typesetter.typeset(this, vertices);
        return vertices;
    };
    Object.defineProperty(Projected3DLabel.prototype, "camera", {
        get: function () {
            return this._camera;
        },
        set: function (camera) {
            this._camera = camera;
            this._altered.alter(this._type);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Projected3DLabel.prototype, "position", {
        get: function () {
            return this._position;
        },
        set: function (position) {
            this._position = gl_matrix_1.vec3.clone(position);
            this._altered.alter(this._type);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Projected3DLabel.prototype, "direction", {
        get: function () {
            return this._direction;
        },
        set: function (direction) {
            gl_matrix_1.vec2.normalize(this._direction, direction);
            this._altered.alter(this._type);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Projected3DLabel.prototype, "fontSizeUnit", {
        get: function () {
            return this._fontSizeUnit;
        },
        set: function (unit) {
            auxiliaries_1.logIf(unit !== label_1.Label.Unit.Mixed, auxiliaries_1.LogLevel.Warning, "font size unit other than 'px' are not supported in projected-3d-label, given " + unit);
        },
        enumerable: true,
        configurable: true
    });
    Projected3DLabel.DEFAULT_FONTSIZE_PX = 20;
    return Projected3DLabel;
}(label_1.Label));
exports.Projected3DLabel = Projected3DLabel;


/***/ }),

/***/ "./text/text.ts":
/*!**********************!*\
  !*** ./text/text.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Text = (function () {
    function Text(text, lineFeed) {
        this._lineFeed = Text.DEFAULT_LINE_FEED;
        this._altered = false;
        this._text = text ? text : '';
        this._lineFeed = lineFeed !== undefined ? lineFeed : this._lineFeed;
    }
    Object.defineProperty(Text.prototype, "length", {
        get: function () {
            return this._text.length;
        },
        enumerable: true,
        configurable: true
    });
    Text.prototype.charAt = function (index) {
        return this._text.charAt(index);
    };
    Text.prototype.charCodeAt = function (index) {
        return this._text.charCodeAt(index);
    };
    Object.defineProperty(Text.prototype, "text", {
        get: function () {
            return this._text;
        },
        set: function (text) {
            if (this._text === text) {
                return;
            }
            this._altered = true;
            this._text = text;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Text.prototype, "lineFeed", {
        get: function () {
            return this._lineFeed;
        },
        set: function (lineFeed) {
            if (this._lineFeed === lineFeed) {
                return;
            }
            this._altered = true;
            this._lineFeed = lineFeed;
            return;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Text.prototype, "altered", {
        get: function () {
            return this._altered;
        },
        set: function (altered) {
            this._altered = altered;
        },
        enumerable: true,
        configurable: true
    });
    Text.DEFAULT_LINE_FEED = '\x0A';
    return Text;
}());
exports.Text = Text;


/***/ }),

/***/ "./text/typesetter.ts":
/*!****************************!*\
  !*** ./text/typesetter.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "../node_modules/gl-matrix/esm/index.js");
var auxiliaries_1 = __webpack_require__(/*! ../auxiliaries */ "./auxiliaries.ts");
var gl_matrix_extensions_1 = __webpack_require__(/*! ../gl-matrix-extensions */ "./gl-matrix-extensions.ts");
var label_1 = __webpack_require__(/*! ./label */ "./text/label.ts");
var Typesetter = (function () {
    function Typesetter() {
    }
    Typesetter.writeVertex = function (fontFace, pen, glyph, vertices, index) {
        if (vertices === undefined || glyph.depictable() === false) {
            return;
        }
        var padding = fontFace.glyphTexturePadding;
        var origin = vertices.origin(index);
        gl_matrix_1.vec3.set(origin, pen[0], pen[1], 0.0);
        origin[0] += glyph.bearing[0] - padding[3];
        origin[1] += glyph.bearing[1] - glyph.extent[1];
        gl_matrix_1.vec3.set(vertices.tangent(index), glyph.extent[0], 0.0, 0.0);
        gl_matrix_1.vec3.set(vertices.up(index), 0.0, glyph.extent[1], 0.0);
        var lowerLeft = vertices.uvLowerLeft(index);
        gl_matrix_1.vec2.copy(lowerLeft, glyph.subTextureOrigin);
        var upperRight = vertices.uvUpperRight(index);
        gl_matrix_1.vec2.add(upperRight, glyph.subTextureOrigin, glyph.subTextureExtent);
    };
    Typesetter.lineAnchorOffset = function (label) {
        var offset = 0.0;
        var padding = label.fontFace.glyphTexturePadding;
        var fontFace = label.fontFace;
        switch (label.lineAnchor) {
            case label_1.Label.LineAnchor.Baseline:
            default:
                offset = -padding[0];
                break;
            case label_1.Label.LineAnchor.Ascent:
                offset = fontFace.ascent - padding[0];
                break;
            case label_1.Label.LineAnchor.Descent:
                offset = fontFace.descent * (1.0 + padding[0] / fontFace.ascent);
                break;
            case label_1.Label.LineAnchor.Center:
                offset = fontFace.ascent - padding[0] - 0.5 * fontFace.size;
                break;
            case label_1.Label.LineAnchor.Top:
                offset = fontFace.ascent - padding[0] + 0.5 * fontFace.lineGap;
                break;
            case label_1.Label.LineAnchor.Bottom:
                offset = fontFace.ascent - padding[0] + 0.5 * fontFace.lineGap - fontFace.lineHeight;
                break;
        }
        return offset;
    };
    Typesetter.advances = function (label, text) {
        auxiliaries_1.assert(label.fontFace !== undefined, "expected a font face for label in order to resolve advances");
        if (text === undefined) {
            text = label.text.text;
        }
        var advances = new Float32Array(text.length);
        for (var i = 0; i < text.length; ++i) {
            var charCode = text.charCodeAt(i);
            advances[i] = label.fontFace.glyph(charCode).advance;
        }
        return advances;
    };
    Typesetter.kernings = function (label, text) {
        auxiliaries_1.assert(label.fontFace !== undefined, "expected a font face for label in order to resolve kernings");
        if (text === undefined) {
            var kernings_1 = new Float32Array(label.length);
            for (var i = 0; i < label.length; ++i) {
                var kerning = label.kerningAfter(i);
                kernings_1[i] = isNaN(kerning) ? 0.0 : kerning;
            }
            return kernings_1;
        }
        var kerningAfter = function (index) {
            if (index < 0 || index > text.length - 1) {
                return NaN;
            }
            return label.fontFace.kerning(text.charCodeAt(index), text.charCodeAt(index + 1));
        };
        var kernings = new Float32Array(text.length);
        for (var i = 0; i < text.length; ++i) {
            var kerning = kerningAfter(i);
            kernings[i] = isNaN(kerning) ? 0.0 : kerning;
        }
        return kernings;
    };
    Typesetter.fragments = function (label) {
        var fragments = new Array();
        var isDelimiter;
        var currentWordIndex = 0;
        for (var i = 0; i < label.length; ++i) {
            isDelimiter = Typesetter.DELIMITERS.indexOf(label.charAt(i)) > -1;
            if (!isDelimiter) {
                continue;
            }
            if (currentWordIndex < i) {
                fragments.push([currentWordIndex, i, Typesetter.FragmentType.Word]);
            }
            var type = label.lineFeedAt(i) ? Typesetter.FragmentType.LineFeed : Typesetter.FragmentType.Delimiter;
            fragments.push([i, i + 1, type]);
            currentWordIndex = i + 1;
        }
        if (!isDelimiter) {
            fragments.push([currentWordIndex, label.length, Typesetter.FragmentType.Word]);
        }
        return fragments;
    };
    Typesetter.fragmentWidths = function (fragments, advances, kernings) {
        var widths = new Float32Array(fragments.length);
        var _loop_1 = function (i) {
            var fragment = fragments[i];
            widths[i] = advances.subarray(fragment[0], fragment[1]).reduce(function (width, advance, index) {
                return width + advance + (index < fragment[1] ? kernings[index + fragment[0]] : 0.0);
            }, 0.0);
        };
        for (var i = 0; i < fragments.length; ++i) {
            _loop_1(i);
        }
        return widths;
    };
    Typesetter.elideThresholds = function (label, ellipsisWidth) {
        switch (label.elide) {
            case label_1.Label.Elide.Right:
                return [label.lineWidth - ellipsisWidth, 0.0];
            case label_1.Label.Elide.Middle:
                var threshold = label.lineWidth / 2 - ellipsisWidth / 2;
                return [threshold, threshold];
            case label_1.Label.Elide.Left:
                return [0.0, label.lineWidth - ellipsisWidth];
            default:
                return [0.0, 0.0];
        }
    };
    Typesetter.elideFragments = function (threshold, labelFragments, labelFragmentWidths, labelAdvances, labelKernings, reverse) {
        var fragments = new Array();
        var fragmentWidths = new Array();
        var width = 0.0;
        var lastLabelFragmentWidth = 0.0;
        for (var i0 = reverse ? labelFragments.length - 1 : 0; reverse ? i0 > -1 : i0 < labelFragments.length; reverse ? --i0 : ++i0) {
            var fragment = labelFragments[i0];
            if (fragment[2] === Typesetter.FragmentType.LineFeed) {
                continue;
            }
            if (width + labelFragmentWidths[i0] < threshold) {
                width += labelFragmentWidths[i0];
                fragments.push(fragment);
                fragmentWidths.push(labelFragmentWidths[i0]);
                continue;
            }
            if (fragment[2] === Typesetter.FragmentType.Delimiter ||
                width + labelAdvances[reverse ? fragment[1] - 1 : fragment[0]] > threshold) {
                break;
            }
            for (var i1 = reverse ? fragment[1] - 1 : fragment[0]; reverse ? i1 >= fragment[0] : i1 < fragment[1]; reverse ? --i1 : ++i1) {
                if (width + lastLabelFragmentWidth + labelAdvances[i1] + labelKernings[i1] < threshold) {
                    lastLabelFragmentWidth += labelAdvances[i1] + labelKernings[i1];
                    continue;
                }
                fragments.push([reverse ? i1 + 1 : fragment[0], reverse ? fragment[1] : i1, fragment[2]]);
                fragmentWidths.push(lastLabelFragmentWidth);
                break;
            }
            break;
        }
        return [fragments, fragmentWidths, width + lastLabelFragmentWidth];
    };
    Typesetter.transformVertices = function (transform, vertices, begin, end) {
        if (vertices === undefined || gl_matrix_1.mat4.equals(transform, gl_matrix_1.mat4.create())) {
            return;
        }
        for (var index = begin; index < end; ++index) {
            var origin_1 = vertices.origin(index);
            var ll = gl_matrix_extensions_1.v3();
            gl_matrix_1.vec3.transformMat4(ll, origin_1, transform);
            var lr = gl_matrix_extensions_1.v3();
            gl_matrix_1.vec3.transformMat4(lr, gl_matrix_1.vec3.add(lr, origin_1, vertices.tangent(index)), transform);
            var ul = gl_matrix_extensions_1.v3();
            gl_matrix_1.vec3.transformMat4(ul, gl_matrix_1.vec3.add(ul, origin_1, vertices.up(index)), transform);
            gl_matrix_1.vec3.copy(vertices.origin(index), ll);
            gl_matrix_1.vec3.sub(vertices.tangent(index), lr, ll);
            gl_matrix_1.vec3.sub(vertices.up(index), ul, ll);
        }
    };
    Typesetter.updateRectangleMinMax = function (currentRectangle, newRectangle) {
        auxiliaries_1.assert(currentRectangle.length === 6 && newRectangle.length === 6, "expected the rectangles to have 6 values!");
        var i = 0;
        for (; i < 3; i++) {
            currentRectangle[i] = Math.min(currentRectangle[i], newRectangle[i]);
        }
        for (; i < 6; i++) {
            currentRectangle[i] = Math.max(currentRectangle[i], newRectangle[i]);
        }
    };
    Typesetter.minMax = function (currentMin, currentMax, values) {
        var min = Math.min.apply(Math, __spreadArrays([currentMin], values));
        var max = Math.max.apply(Math, __spreadArrays([currentMax], values));
        return gl_matrix_1.vec2.fromValues(min, max);
    };
    Typesetter.getMinMaxVertices = function (vertices, begin, end) {
        var minX = Number.POSITIVE_INFINITY;
        var maxX = Number.NEGATIVE_INFINITY;
        var minY = Number.POSITIVE_INFINITY;
        var maxY = Number.NEGATIVE_INFINITY;
        var minZ = Number.POSITIVE_INFINITY;
        var maxZ = Number.NEGATIVE_INFINITY;
        for (var i = begin; i < end; ++i) {
            var x = Typesetter.minMax(minX, maxX, [vertices.origin(i)[0], vertices.origin(i)[0] + vertices.up(i)[0],
                vertices.origin(i)[0] + vertices.tangent(i)[0]]);
            minX = x[0];
            maxX = x[1];
            var y = Typesetter.minMax(minY, maxY, [vertices.origin(i)[1], vertices.origin(i)[1] + vertices.up(i)[1],
                vertices.origin(i)[1] + vertices.tangent(i)[1]]);
            minY = y[0];
            maxY = y[1];
            var z = Typesetter.minMax(minZ, maxZ, [vertices.origin(i)[2], vertices.origin(i)[2] + vertices.up(i)[2],
                vertices.origin(i)[2] + vertices.tangent(i)[2]]);
            minZ = z[0];
            maxZ = z[1];
        }
        return [minX, minY, minZ, maxX, maxY, maxZ];
    };
    Typesetter.transformAlignment = function (width, alignment, vertices, begin, end) {
        if (vertices === undefined || alignment === label_1.Label.Alignment.Left) {
            return;
        }
        var offset = -width;
        if (alignment === label_1.Label.Alignment.Center) {
            offset *= 0.5;
        }
        for (var index = begin; index < end; ++index) {
            vertices.origin(index)[0] += offset;
        }
    };
    Typesetter.transform = function (label, vertices, lines) {
        var boundingRectangle = [
            Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY,
            Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY
        ];
        for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {
            var line = lines_1[_i];
            Typesetter.transformAlignment(line[2], label.alignment, vertices, line[0], line[1]);
            Typesetter.updateRectangleMinMax(boundingRectangle, Typesetter.getMinMaxVertices(vertices, line[0], line[1]));
            Typesetter.transformVertices(label.staticTransform, vertices, line[0], line[1]);
        }
        var width = boundingRectangle[3] - boundingRectangle[0];
        var height = boundingRectangle[4] - boundingRectangle[1];
        var ll = gl_matrix_1.vec4.transformMat4(gl_matrix_1.vec4.create(), gl_matrix_1.vec4.fromValues(0, 0, 0, 1), label.staticTransform);
        var lr = gl_matrix_1.vec4.transformMat4(gl_matrix_1.vec4.create(), gl_matrix_1.vec4.fromValues(width, 0, 0, 1), label.staticTransform);
        var ul = gl_matrix_1.vec4.transformMat4(gl_matrix_1.vec4.create(), gl_matrix_1.vec4.fromValues(0, height, 0, 1), label.staticTransform);
        var extent = gl_matrix_1.vec2.fromValues(gl_matrix_1.vec4.distance(lr, ll), gl_matrix_1.vec4.distance(ul, ll));
        label.extent = [extent[0], extent[1]];
    };
    Typesetter.typeset = function (label, vertices) {
        if (label.length === 0) {
            return 0;
        }
        auxiliaries_1.assert(label.fontFace !== undefined, "expected a font face for label before typesetting");
        var fontFace = label.fontFace;
        var glyphs = function (index) { return index < label.length ? fontFace.glyph(label.charCodeAt(index)) :
            fontFace.glyph(label.ellipsis.charCodeAt(index - label.length)); };
        var labelAdvances = Typesetter.advances(label);
        var labelKernings = Typesetter.kernings(label);
        var labelFragments = Typesetter.fragments(label);
        var labelFragmentWidths = Typesetter.fragmentWidths(labelFragments, labelAdvances, labelKernings);
        var pen = gl_matrix_1.vec2.fromValues(0.0, -Typesetter.lineAnchorOffset(label));
        var lines = new Array();
        var vertexIndex = 0;
        var elide = label.elide !== label_1.Label.Elide.None;
        var advance = function (fragments, fragmentWidths, threshold, advances, kernings, offset) {
            if (threshold === void 0) { threshold = NaN; }
            if (advances === void 0) { advances = labelAdvances; }
            if (kernings === void 0) { kernings = labelKernings; }
            if (offset === void 0) { offset = 0; }
            var firstIndexOfLine = vertexIndex;
            for (var i = 0; i < fragments.length; ++i) {
                var fragment = fragments[i];
                if (fragment[0] >= fragment[1]) {
                    continue;
                }
                var lineFeed = !elide && fragment[2] === Typesetter.FragmentType.LineFeed;
                var wordWrap = false;
                if (!elide && !lineFeed && label.wrap) {
                    var depictable = fragment[2] !== Typesetter.FragmentType.Delimiter ||
                        glyphs(fragment[0]).depictable();
                    var lookAhead = fragment[2] === Typesetter.FragmentType.Word &&
                        i < fragments.length - 1 && fragments[i + 1][2] === Typesetter.FragmentType.Delimiter;
                    var depictableAhead = lookAhead && glyphs(fragments[i + 1][0]).depictable();
                    wordWrap = pen[0] + (depictable ? fragmentWidths[i] : 0.0)
                        + (depictableAhead ? fragmentWidths[i + 1] : 0.0) > label.lineWidth;
                }
                if (lineFeed || wordWrap) {
                    lines.push([firstIndexOfLine, vertexIndex, pen[0]]);
                    firstIndexOfLine = vertexIndex;
                    pen[0] = 0.0;
                    pen[1] -= fontFace.lineHeight;
                    if (lineFeed) {
                        continue;
                    }
                }
                for (var i_1 = fragment[0]; i_1 < fragment[1]; ++i_1) {
                    if (glyphs(i_1).depictable()) {
                        Typesetter.writeVertex(fontFace, pen, glyphs(i_1), vertices, vertexIndex);
                        ++vertexIndex;
                    }
                    pen[0] += advances[i_1 - offset] + kernings[i_1 - offset];
                }
            }
            if (firstIndexOfLine < vertexIndex) {
                lines.push([firstIndexOfLine, vertexIndex, pen[0]]);
            }
        };
        var fullApproximatedWidth = labelFragmentWidths.reduce(function (accumulate, width) { return accumulate + width; }, 0.0);
        if (elide && fullApproximatedWidth > label.lineWidth) {
            var ellipsisFragments = [[label.length, label.length + label.ellipsis.length, Typesetter.FragmentType.Word]];
            var ellipsisAdvances = Typesetter.advances(label, label.ellipsis);
            var ellipsisKernings = Typesetter.kernings(label, label.ellipsis);
            var ellipsisFragmentWidths = Typesetter.fragmentWidths([[0, label.ellipsis.length, Typesetter.FragmentType.Word]], ellipsisAdvances, ellipsisKernings);
            var ellipsisWidth = ellipsisFragmentWidths[0];
            if (label.lineWidth < ellipsisWidth) {
                return 0;
            }
            var thresholds = Typesetter.elideThresholds(label, ellipsisWidth);
            var _a = Typesetter.elideFragments(thresholds[0], labelFragments, labelFragmentWidths, labelAdvances, labelKernings, false), leftFragments = _a[0], leftFragmentWidths = _a[1], leftWidth = _a[2];
            if (label.elide === label_1.Label.Elide.Middle) {
                thresholds[1] += thresholds[0] - leftWidth;
            }
            var _b = Typesetter.elideFragments(thresholds[1], labelFragments, labelFragmentWidths, labelAdvances, labelKernings, true), rightFragments = _b[0], rightFragmentWidths = _b[1];
            advance(leftFragments, new Float32Array(leftFragmentWidths));
            advance(ellipsisFragments, ellipsisFragmentWidths, NaN, ellipsisAdvances, ellipsisKernings, label.length);
            advance(rightFragments.reverse(), new Float32Array(rightFragmentWidths.reverse()));
            auxiliaries_1.assert(lines.length < 4, "expected at most 3-line-yield from advance, given " + lines);
            lines[0][1] = lines[lines.length - 1][1];
            lines[0][2] = pen[0];
            lines.length = 1;
        }
        else {
            advance(labelFragments, labelFragmentWidths, label.lineWidth);
        }
        Typesetter.transform(label, vertices, lines);
        vertices.shrink(vertexIndex);
        return vertexIndex;
    };
    Typesetter.DELIMITERS = '\x0A ,.-/()[]<>';
    return Typesetter;
}());
exports.Typesetter = Typesetter;
(function (Typesetter) {
    var FragmentType;
    (function (FragmentType) {
        FragmentType[FragmentType["Word"] = 0] = "Word";
        FragmentType[FragmentType["Delimiter"] = 1] = "Delimiter";
        FragmentType[FragmentType["LineFeed"] = 2] = "LineFeed";
    })(FragmentType = Typesetter.FragmentType || (Typesetter.FragmentType = {}));
})(Typesetter = exports.Typesetter || (exports.Typesetter = {}));
exports.Typesetter = Typesetter;


/***/ }),

/***/ "./texture2d.ts":
/*!**********************!*\
  !*** ./texture2d.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var formatbytesizes_1 = __webpack_require__(/*! ./formatbytesizes */ "./formatbytesizes.ts");
var initializable_1 = __webpack_require__(/*! ./initializable */ "./initializable.ts");
var object_1 = __webpack_require__(/*! ./object */ "./object.ts");
var Texture2D = (function (_super) {
    __extends(Texture2D, _super);
    function Texture2D() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._width = 0;
        _this._height = 0;
        _this._internalFormat = 0;
        _this._format = 0;
        _this._type = 0;
        _this._mipmap = false;
        _this._anisotropy = undefined;
        return _this;
    }
    Texture2D.prototype.create = function (width, height, internalFormat, format, type) {
        auxiliaries_1.assert(width > 0 && height > 0, "texture requires valid width and height of greater than zero");
        var gl = this._context.gl;
        var gl2facade = this._context.gl2facade;
        this._object = gl.createTexture();
        this._width = width;
        this._height = height;
        this._internalFormat = internalFormat;
        this._format = format;
        this._type = type;
        gl.bindTexture(gl.TEXTURE_2D, this._object);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        if (Texture2D.MAX_ANISOTROPY === undefined) {
            if (this._context.supportsTextureFilterAnisotropic) {
                var ext = this._context.textureFilterAnisotropic;
                Texture2D.MAX_ANISOTROPY = gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
            }
            else {
                Texture2D.MAX_ANISOTROPY = 0.0;
            }
        }
        gl2facade.texImage2D(gl.TEXTURE_2D, 0, this._internalFormat, this._width, this._height, 0, this._format, this._type);
        gl.bindTexture(gl.TEXTURE_2D, Texture2D.DEFAULT_TEXTURE);
        this._valid = gl.isTexture(this._object);
        this.reallocate();
        return this._object;
    };
    Texture2D.prototype.delete = function () {
        auxiliaries_1.assert(this._object instanceof WebGLTexture, "expected WebGLTexture object");
        this._context.gl.deleteTexture(this._object);
        this._object = undefined;
        this._valid = false;
        this._internalFormat = 0;
        this._format = 0;
        this._type = 0;
        this._width = 0;
        this._height = 0;
    };
    Texture2D.prototype.reallocate = function () {
        var gl = this.context.gl;
        var gl2facade = this._context.gl2facade;
        var bytes = this._width * this._height * formatbytesizes_1.byteSizeOfFormat(this.context, this._internalFormat);
        if (this._type === gl2facade.HALF_FLOAT && this._internalFormat !== gl.RGBA16F) {
            bytes *= 2;
        }
        else if (this._type === gl.FLOAT && this._internalFormat !== gl.RGBA16F) {
            bytes *= 4;
        }
        this.context.allocationRegister.reallocate(this._identifier, bytes);
    };
    Texture2D.prototype.bind = function (unit) {
        var gl = this.context.gl;
        if (unit) {
            gl.activeTexture(unit);
        }
        gl.bindTexture(gl.TEXTURE_2D, this._object);
    };
    Texture2D.prototype.unbind = function (unit) {
        var gl = this.context.gl;
        if (unit) {
            gl.activeTexture(unit);
        }
        gl.bindTexture(gl.TEXTURE_2D, Texture2D.DEFAULT_TEXTURE);
    };
    Texture2D.prototype.fetch = function (url, crossOrigin, flipY) {
        var _this = this;
        if (crossOrigin === void 0) { crossOrigin = false; }
        if (flipY === void 0) { flipY = false; }
        var gl = this.context.gl;
        return new Promise(function (resolve, reject) {
            var image = new Image();
            image.onerror = function () {
                auxiliaries_1.log(auxiliaries_1.LogLevel.Error, "loading image from '" + image.src + "' failed");
                reject();
            };
            image.onload = function () {
                _this.resize(image.width, image.height);
                if (!flipY) {
                    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                }
                _this.data(image);
                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
                resolve();
            };
            if (crossOrigin) {
                image.crossOrigin = 'anonymous';
            }
            image.src = url;
        });
    };
    Texture2D.prototype.data = function (data, bind, unbind) {
        if (bind === void 0) { bind = true; }
        if (unbind === void 0) { unbind = true; }
        var gl = this.context.gl;
        var gl2facade = this._context.gl2facade;
        if (bind) {
            this.bind();
        }
        gl2facade.texImage2D(gl.TEXTURE_2D, 0, this._internalFormat, this._width, this._height, 0, this._format, this._type, data);
        if (this._anisotropy !== undefined && this._anisotropy > 0.0) {
            this.maxAnisotropy(this._anisotropy, false, false);
        }
        else if (this._mipmap) {
            this.generateMipMap(false, false);
        }
        if (unbind) {
            this.unbind();
        }
        this.reallocate();
    };
    Texture2D.prototype.filter = function (mag, min, bind, unbind) {
        if (bind === void 0) { bind = true; }
        if (unbind === void 0) { unbind = true; }
        var gl = this.context.gl;
        if (bind) {
            this.bind();
        }
        auxiliaries_1.logIf(mag === gl.LINEAR_MIPMAP_LINEAR || mag === gl.LINEAR_MIPMAP_NEAREST, auxiliaries_1.LogLevel.Debug, "magnification does not utilize a MipMap (refer to LINEAR and NEAREST only)");
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, mag);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, min);
        this._mipmap = min === gl.LINEAR_MIPMAP_LINEAR || min === gl.LINEAR_MIPMAP_NEAREST;
        if (this._mipmap) {
            gl.generateMipmap(gl.TEXTURE_2D);
        }
        if (unbind) {
            this.unbind();
        }
    };
    Texture2D.prototype.wrap = function (wrap_s, wrap_t, bind, unbind) {
        if (bind === void 0) { bind = true; }
        if (unbind === void 0) { unbind = true; }
        var gl = this.context.gl;
        if (bind) {
            this.bind();
        }
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrap_s);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrap_t);
        if (unbind) {
            this.unbind();
        }
    };
    Texture2D.prototype.reformat = function (internalFormat, format, type, bind, unbind) {
        if (bind === void 0) { bind = true; }
        if (unbind === void 0) { unbind = true; }
        if (internalFormat === this._internalFormat
            && (format === undefined || format === this._format)
            && (type === undefined || type === this._type)) {
            return;
        }
        auxiliaries_1.assert(internalFormat !== undefined, "valid internal format expected");
        this._internalFormat = internalFormat;
        if (format) {
            this._format = format;
        }
        if (type) {
            this._type = type;
        }
        this.data(undefined, bind, unbind);
    };
    Texture2D.prototype.resize = function (width, height, bind, unbind) {
        if (bind === void 0) { bind = true; }
        if (unbind === void 0) { unbind = true; }
        if (width === this._width && height === this._height) {
            return;
        }
        this._width = width;
        this._height = height;
        this.data(undefined, bind, unbind);
    };
    Texture2D.prototype.generateMipMap = function (bind, unbind) {
        if (bind === void 0) { bind = true; }
        if (unbind === void 0) { unbind = true; }
        var gl = this.context.gl;
        if (bind) {
            this.bind();
        }
        gl.generateMipmap(gl.TEXTURE_2D);
        if (unbind) {
            this.unbind();
        }
        this._mipmap = true;
    };
    Texture2D.prototype.maxAnisotropy = function (max, bind, unbind) {
        if (bind === void 0) { bind = true; }
        if (unbind === void 0) { unbind = true; }
        if (this._context.supportsTextureFilterAnisotropic === false) {
            auxiliaries_1.log(auxiliaries_1.LogLevel.Debug, "setting anisotropy not supported (EXT_texture_filter_anisotropic missing)");
            return undefined;
        }
        var gl = this.context.gl;
        var ext = this._context.textureFilterAnisotropic;
        this._anisotropy = max === undefined ? undefined : Math.max(0.0, Math.min(Texture2D.MAX_ANISOTROPY, max));
        auxiliaries_1.logIf(max !== this._anisotropy, auxiliaries_1.LogLevel.Debug, "value clamped to max supported anisotropy of " + Texture2D.MAX_ANISOTROPY + ", given " + max);
        if (bind) {
            this.bind();
        }
        gl.texParameterf(gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, this._anisotropy === undefined ? 0.0 : this._anisotropy);
        this.generateMipMap(false, unbind);
        return this._anisotropy;
    };
    Object.defineProperty(Texture2D.prototype, "bytes", {
        get: function () {
            this.assertInitialized();
            return this.context.allocationRegister.allocated(this._identifier);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Texture2D.prototype, "internalFormat", {
        get: function () {
            this.assertInitialized();
            return this._internalFormat;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Texture2D.prototype, "format", {
        get: function () {
            this.assertInitialized();
            return this._format;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Texture2D.prototype, "type", {
        get: function () {
            this.assertInitialized();
            return this._type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Texture2D.prototype, "width", {
        get: function () {
            this.assertInitialized();
            return this._width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Texture2D.prototype, "height", {
        get: function () {
            this.assertInitialized();
            return this._height;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Texture2D.prototype, "size", {
        get: function () {
            this.assertInitialized();
            return [this._width, this._height];
        },
        enumerable: true,
        configurable: true
    });
    Texture2D.DEFAULT_TEXTURE = undefined;
    Texture2D.MAX_ANISOTROPY = undefined;
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Texture2D.prototype, "bind", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Texture2D.prototype, "unbind", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Texture2D.prototype, "fetch", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Texture2D.prototype, "data", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Texture2D.prototype, "filter", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Texture2D.prototype, "wrap", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Texture2D.prototype, "reformat", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Texture2D.prototype, "resize", null);
    return Texture2D;
}(object_1.AbstractObject));
exports.Texture2D = Texture2D;


/***/ }),

/***/ "./texture3d.ts":
/*!**********************!*\
  !*** ./texture3d.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var formatbytesizes_1 = __webpack_require__(/*! ./formatbytesizes */ "./formatbytesizes.ts");
var initializable_1 = __webpack_require__(/*! ./initializable */ "./initializable.ts");
var object_1 = __webpack_require__(/*! ./object */ "./object.ts");
var Texture3D = (function (_super) {
    __extends(Texture3D, _super);
    function Texture3D() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._width = 0;
        _this._height = 0;
        _this._depth = 0;
        _this._internalFormat = 0;
        _this._format = 0;
        _this._type = 0;
        return _this;
    }
    Texture3D.prototype.create = function (width, height, depth, internalFormat, format, type) {
        auxiliaries_1.assert(this._context.supportsTexImage3D, "expected texImage3D to be supported");
        auxiliaries_1.assert(width > 0 && height > 0 && depth > 0, "texture requires valid width, height, and depth of greater than zero");
        var gl = this._context.gl;
        var gl2facade = this._context.gl2facade;
        this._object = gl.createTexture();
        this._width = width;
        this._height = height;
        this._depth = depth;
        this._internalFormat = internalFormat;
        this._format = format;
        this._type = type;
        gl.bindTexture(gl.TEXTURE_3D, this._object);
        gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_R, gl.CLAMP_TO_EDGE);
        gl2facade.texImage3D(gl.TEXTURE_3D, 0, this._internalFormat, this._width, this._height, this._depth, 0, this._format, this._type);
        gl.bindTexture(gl.TEXTURE_3D, Texture3D.DEFAULT_TEXTURE);
        this._valid = gl.isTexture(this._object);
        this.reallocate();
        return this._object;
    };
    Texture3D.prototype.delete = function () {
        auxiliaries_1.assert(this._object instanceof WebGLTexture, "expected WebGLTexture object");
        this._context.gl.deleteTexture(this._object);
        this._object = undefined;
        this._valid = false;
        this._internalFormat = 0;
        this._format = 0;
        this._type = 0;
        this._width = 0;
        this._height = 0;
        this._depth = 0;
    };
    Texture3D.prototype.reallocate = function () {
        var gl = this.context.gl;
        var gl2facade = this._context.gl2facade;
        var bytes = this._width * this._height * this._depth
            * formatbytesizes_1.byteSizeOfFormat(this.context, this._internalFormat);
        if (this._type === gl2facade.HALF_FLOAT && this._internalFormat !== gl.RGBA16F) {
            bytes *= 2;
        }
        else if (this._type === gl.FLOAT && this._internalFormat !== gl.RGBA16F) {
            bytes *= 4;
        }
        this.context.allocationRegister.reallocate(this._identifier, bytes);
    };
    Texture3D.prototype.bind = function (unit) {
        var gl = this.context.gl;
        if (unit) {
            gl.activeTexture(unit);
        }
        gl.bindTexture(gl.TEXTURE_3D, this._object);
    };
    Texture3D.prototype.unbind = function (unit) {
        var gl = this.context.gl;
        if (unit) {
            gl.activeTexture(unit);
        }
        gl.bindTexture(gl.TEXTURE_3D, Texture3D.DEFAULT_TEXTURE);
    };
    Texture3D.prototype.load = function (url, slices, crossOrigin) {
        if (crossOrigin === void 0) { crossOrigin = false; }
        auxiliaries_1.assert(false, "not implemented");
        return new Promise(function () { return true; });
    };
    Texture3D.prototype.data = function (data, bind, unbind) {
        if (bind === void 0) { bind = true; }
        if (unbind === void 0) { unbind = true; }
        var gl = this.context.gl;
        var gl2facade = this._context.gl2facade;
        if (bind) {
            this.bind();
        }
        gl2facade.texImage3D(gl.TEXTURE_3D, 0, this._internalFormat, this._width, this._height, this._depth, 0, this._format, this._type, data);
        if (unbind) {
            this.unbind();
        }
        this.reallocate();
    };
    Texture3D.prototype.filter = function (mag, min, bind, unbind) {
        if (bind === void 0) { bind = true; }
        if (unbind === void 0) { unbind = true; }
        var gl = this.context.gl;
        if (bind) {
            this.bind();
        }
        gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MAG_FILTER, mag);
        gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MIN_FILTER, min);
        if (unbind) {
            this.unbind();
        }
    };
    Texture3D.prototype.wrap = function (wrap_s, wrap_t, wrap_r, bind, unbind) {
        if (bind === void 0) { bind = true; }
        if (unbind === void 0) { unbind = true; }
        var gl = this.context.gl;
        if (bind) {
            this.bind();
        }
        gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_S, wrap_s);
        gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_T, wrap_t);
        gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_T, wrap_r);
        if (unbind) {
            this.unbind();
        }
    };
    Texture3D.prototype.reformat = function (internalFormat, format, type, bind, unbind) {
        if (bind === void 0) { bind = true; }
        if (unbind === void 0) { unbind = true; }
        if (internalFormat === this._internalFormat
            && (format === undefined || format === this._format)
            && (type === undefined || type === this._type)) {
            return;
        }
        auxiliaries_1.assert(internalFormat !== undefined, "valid internal format expected");
        this._internalFormat = internalFormat;
        if (format) {
            this._format = format;
        }
        if (type) {
            this._type = type;
        }
        this.data(undefined, bind, unbind);
    };
    Texture3D.prototype.resize = function (width, height, depth, bind, unbind) {
        if (bind === void 0) { bind = true; }
        if (unbind === void 0) { unbind = true; }
        if (width === this._width && height === this._height && depth === this._depth) {
            return;
        }
        this._width = width;
        this._height = height;
        this._depth = depth;
        this.data(undefined, bind, unbind);
    };
    Object.defineProperty(Texture3D.prototype, "bytes", {
        get: function () {
            this.assertInitialized();
            return this.context.allocationRegister.allocated(this._identifier);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Texture3D.prototype, "internalFormat", {
        get: function () {
            this.assertInitialized();
            return this._internalFormat;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Texture3D.prototype, "format", {
        get: function () {
            this.assertInitialized();
            return this._format;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Texture3D.prototype, "type", {
        get: function () {
            this.assertInitialized();
            return this._type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Texture3D.prototype, "width", {
        get: function () {
            this.assertInitialized();
            return this._width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Texture3D.prototype, "height", {
        get: function () {
            this.assertInitialized();
            return this._height;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Texture3D.prototype, "depth", {
        get: function () {
            this.assertInitialized();
            return this._depth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Texture3D.prototype, "size", {
        get: function () {
            this.assertInitialized();
            return [this._width, this._height, this._depth];
        },
        enumerable: true,
        configurable: true
    });
    Texture3D.DEFAULT_TEXTURE = undefined;
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Texture3D.prototype, "bind", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Texture3D.prototype, "unbind", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Texture3D.prototype, "load", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Texture3D.prototype, "data", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Texture3D.prototype, "filter", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Texture3D.prototype, "wrap", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Texture3D.prototype, "reformat", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], Texture3D.prototype, "resize", null);
    return Texture3D;
}(object_1.AbstractObject));
exports.Texture3D = Texture3D;


/***/ }),

/***/ "./texturecube.ts":
/*!************************!*\
  !*** ./texturecube.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var formatbytesizes_1 = __webpack_require__(/*! ./formatbytesizes */ "./formatbytesizes.ts");
var initializable_1 = __webpack_require__(/*! ./initializable */ "./initializable.ts");
var object_1 = __webpack_require__(/*! ./object */ "./object.ts");
var TextureCube = (function (_super) {
    __extends(TextureCube, _super);
    function TextureCube() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._size = 0;
        _this._internalFormat = 0;
        _this._format = 0;
        _this._type = 0;
        _this._bytes = [0, 0, 0, 0, 0, 0];
        return _this;
    }
    TextureCube.prototype.faceID = function (face) {
        var gl = this._context.gl;
        switch (face) {
            case gl.TEXTURE_CUBE_MAP_POSITIVE_X:
                return 0;
            case gl.TEXTURE_CUBE_MAP_NEGATIVE_X:
                return 1;
            case gl.TEXTURE_CUBE_MAP_POSITIVE_Y:
                return 2;
            case gl.TEXTURE_CUBE_MAP_NEGATIVE_Y:
                return 3;
            case gl.TEXTURE_CUBE_MAP_POSITIVE_Z:
                return 4;
            case gl.TEXTURE_CUBE_MAP_NEGATIVE_Z:
                return 5;
            default:
                auxiliaries_1.assert(false, "expected texture cube map identifier (" + gl.TEXTURE_CUBE_MAP_POSITIVE_X + ", " +
                    (gl.TEXTURE_CUBE_MAP_NEGATIVE_X + ", " + gl.TEXTURE_CUBE_MAP_POSITIVE_Y + ", ") +
                    (gl.TEXTURE_CUBE_MAP_NEGATIVE_Y + ", " + gl.TEXTURE_CUBE_MAP_POSITIVE_Z + ", or") +
                    (gl.TEXTURE_CUBE_MAP_NEGATIVE_Z + "), given " + face));
                return -1;
        }
    };
    TextureCube.prototype.create = function (size, internalFormat, format, type) {
        auxiliaries_1.assert(size > 0, "texture cube requires valid size (width/height) of greater than zero");
        var gl = this._context.gl;
        var gl2facade = this._context.gl2facade;
        this._object = gl.createTexture();
        this._size = size;
        this._internalFormat = internalFormat;
        this._format = format;
        this._type = type;
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, this._object);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl2facade.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, this._internalFormat, this._size, this._size, 0, this._format, this._type);
        gl2facade.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, this._internalFormat, this._size, this._size, 0, this._format, this._type);
        gl2facade.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, this._internalFormat, this._size, this._size, 0, this._format, this._type);
        gl2facade.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, this._internalFormat, this._size, this._size, 0, this._format, this._type);
        gl2facade.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, this._internalFormat, this._size, this._size, 0, this._format, this._type);
        gl2facade.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, this._internalFormat, this._size, this._size, 0, this._format, this._type);
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, TextureCube.DEFAULT_TEXTURE);
        this._valid = gl.isTexture(this._object);
        this.context.allocationRegister.reallocate(this._identifier, 0);
        return this._object;
    };
    TextureCube.prototype.delete = function () {
        auxiliaries_1.assert(this._object instanceof WebGLTexture, "expected WebGLTexture object");
        this._context.gl.deleteTexture(this._object);
        this._object = undefined;
        this._valid = false;
        this._internalFormat = 0;
        this._format = 0;
        this._type = 0;
        this._size = 0;
    };
    TextureCube.prototype.bind = function (unit) {
        var gl = this.context.gl;
        if (unit) {
            gl.activeTexture(unit);
        }
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, this._object);
    };
    TextureCube.prototype.unbind = function (unit) {
        var gl = this.context.gl;
        if (unit) {
            gl.activeTexture(unit);
        }
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, TextureCube.DEFAULT_TEXTURE);
    };
    TextureCube.prototype.fetch = function (urisByFace, mipLevel, crossOrigin) {
        var _this = this;
        if (mipLevel === void 0) { mipLevel = 0; }
        if (crossOrigin === void 0) { crossOrigin = false; }
        var gl = this.context.gl;
        return new Promise(function (resolve, reject) {
            var images = new Array();
            if (urisByFace.positiveX) {
                images.push([gl.TEXTURE_CUBE_MAP_POSITIVE_X, urisByFace.positiveX]);
            }
            if (urisByFace.negativeX) {
                images.push([gl.TEXTURE_CUBE_MAP_NEGATIVE_X, urisByFace.negativeX]);
            }
            if (urisByFace.positiveY) {
                images.push([gl.TEXTURE_CUBE_MAP_POSITIVE_Y, urisByFace.positiveY]);
            }
            if (urisByFace.negativeY) {
                images.push([gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, urisByFace.negativeY]);
            }
            if (urisByFace.positiveZ) {
                images.push([gl.TEXTURE_CUBE_MAP_POSITIVE_Z, urisByFace.positiveZ]);
            }
            if (urisByFace.negativeZ) {
                images.push([gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, urisByFace.negativeZ]);
            }
            var waiting = images.length;
            var _loop_1 = function (tuple) {
                var image = new Image();
                image.crossOrigin = 'anonymous';
                image.onerror = function () { return reject(); };
                image.onload = function () {
                    var size = _this.calculateMipLevelSize(mipLevel);
                    if (image.width !== image.height) {
                        auxiliaries_1.log(auxiliaries_1.LogLevel.Warning, "image ignored, width and height expected to be equal (square image)");
                        return;
                    }
                    if (image.width !== size) {
                        auxiliaries_1.log(auxiliaries_1.LogLevel.Warning, "image ignored, width and height expected to match " +
                            ("this texture's size " + size + ", given " + image.width));
                        return;
                    }
                    _this.data([tuple[0], image], mipLevel);
                    waiting = waiting - 1;
                    if (waiting === 0) {
                        resolve();
                    }
                };
                if (crossOrigin) {
                    image.crossOrigin = 'anonymous';
                }
                image.src = tuple[1];
            };
            for (var _i = 0, images_1 = images; _i < images_1.length; _i++) {
                var tuple = images_1[_i];
                _loop_1(tuple);
            }
        });
    };
    TextureCube.prototype.calculateMipLevelSize = function (level) {
        return this._size * Math.pow(0.5, level);
    };
    TextureCube.prototype.data = function (data, mipLevel, bind, unbind) {
        if (mipLevel === void 0) { mipLevel = 0; }
        if (bind === void 0) { bind = true; }
        if (unbind === void 0) { unbind = true; }
        var gl = this.context.gl;
        var gl2facade = this.context.gl2facade;
        var size = this.calculateMipLevelSize(mipLevel);
        var bytesPerFace = size * size * formatbytesizes_1.byteSizeOfFormat(this.context, this._internalFormat);
        if (this._type === this.context.gl2facade.HALF_FLOAT && this._internalFormat !== this.context.gl.RGBA16F) {
            bytesPerFace *= 2;
        }
        else if (this._type === this.context.gl.FLOAT && this._internalFormat !== this.context.gl.RGBA16F) {
            bytesPerFace *= 4;
        }
        if (bind) {
            this.bind();
        }
        if (data instanceof Array && data.length === 2) {
            gl2facade.texImage2D(data[0], mipLevel, this._internalFormat, size, size, 0, this._format, this._type, data[1]);
            var id = this.faceID(data[0]);
            this.context.allocationRegister.deallocate(this._identifier, this._bytes[id]);
            this.context.allocationRegister.allocate(this._identifier, bytesPerFace);
            this._bytes[id] = bytesPerFace;
        }
        else {
            var perFaceData = data;
            if (perFaceData.positiveX !== undefined) {
                gl2facade.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X, mipLevel, this._internalFormat, size, size, 0, this._format, this._type, perFaceData.positiveX);
                this.context.allocationRegister.deallocate(this._identifier, this._bytes[0]);
                this.context.allocationRegister.allocate(this._identifier, bytesPerFace);
                this._bytes[0] = bytesPerFace;
            }
            if (perFaceData.negativeX !== undefined) {
                gl2facade.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, mipLevel, this._internalFormat, size, size, 0, this._format, this._type, perFaceData.negativeX);
                this.context.allocationRegister.deallocate(this._identifier, this._bytes[1]);
                this.context.allocationRegister.allocate(this._identifier, bytesPerFace);
                this._bytes[1] = bytesPerFace;
            }
            if (perFaceData.positiveY !== undefined) {
                gl2facade.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, mipLevel, this._internalFormat, size, size, 0, this._format, this._type, perFaceData.positiveY);
                this.context.allocationRegister.deallocate(this._identifier, this._bytes[2]);
                this.context.allocationRegister.allocate(this._identifier, bytesPerFace);
                this._bytes[2] = bytesPerFace;
            }
            if (perFaceData.negativeY !== undefined) {
                gl2facade.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, mipLevel, this._internalFormat, size, size, 0, this._format, this._type, perFaceData.negativeY);
                this.context.allocationRegister.deallocate(this._identifier, this._bytes[3]);
                this.context.allocationRegister.allocate(this._identifier, bytesPerFace);
                this._bytes[3] = bytesPerFace;
            }
            if (perFaceData.positiveZ !== undefined) {
                gl2facade.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, mipLevel, this._internalFormat, size, size, 0, this._format, this._type, perFaceData.positiveZ);
                this.context.allocationRegister.deallocate(this._identifier, this._bytes[4]);
                this.context.allocationRegister.allocate(this._identifier, bytesPerFace);
                this._bytes[4] = bytesPerFace;
            }
            if (perFaceData.negativeZ !== undefined) {
                gl2facade.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, mipLevel, this._internalFormat, size, size, 0, this._format, this._type, perFaceData.negativeZ);
                this.context.allocationRegister.deallocate(this._identifier, this._bytes[5]);
                this.context.allocationRegister.allocate(this._identifier, bytesPerFace);
                this._bytes[5] = bytesPerFace;
            }
        }
        if (unbind) {
            this.unbind();
        }
    };
    TextureCube.prototype.filter = function (mag, min, bind, unbind) {
        if (bind === void 0) { bind = true; }
        if (unbind === void 0) { unbind = true; }
        var gl = this.context.gl;
        if (bind) {
            this.bind();
        }
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, mag);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, min);
        if (unbind) {
            this.unbind();
        }
    };
    TextureCube.prototype.wrap = function (wrap_s, wrap_t, bind, unbind) {
        if (bind === void 0) { bind = true; }
        if (unbind === void 0) { unbind = true; }
        var gl = this.context.gl;
        if (bind) {
            this.bind();
        }
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, wrap_s);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, wrap_t);
        if (unbind) {
            this.unbind();
        }
    };
    TextureCube.prototype.levels = function (baseLevel, maxLevel, bind, unbind) {
        if (bind === void 0) { bind = true; }
        if (unbind === void 0) { unbind = true; }
        var gl = this.context.gl;
        if (bind) {
            this.bind();
        }
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_BASE_LEVEL, baseLevel);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAX_LEVEL, maxLevel);
        if (unbind) {
            this.unbind();
        }
    };
    TextureCube.prototype.reformat = function (internalFormat, format, type, bind, unbind) {
        if (bind === void 0) { bind = true; }
        if (unbind === void 0) { unbind = true; }
        if (internalFormat === this._internalFormat
            && (format === undefined || format === this._format)
            && (type === undefined || type === this._type)) {
            return;
        }
        auxiliaries_1.assert(internalFormat !== undefined, "valid internal format expected");
        this._internalFormat = internalFormat;
        if (format) {
            this._format = format;
        }
        if (type) {
            this._type = type;
        }
        this.data({ clearOnUndefined: true }, 0, bind, unbind);
    };
    TextureCube.prototype.resize = function (size, bind, unbind) {
        if (bind === void 0) { bind = true; }
        if (unbind === void 0) { unbind = true; }
        if (size === this._size) {
            return;
        }
        this._size = size;
        this.data({ clearOnUndefined: true }, 0, bind, unbind);
    };
    Object.defineProperty(TextureCube.prototype, "bytes", {
        get: function () {
            this.assertInitialized();
            return this.context.allocationRegister.allocated(this._identifier);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextureCube.prototype, "internalFormat", {
        get: function () {
            this.assertInitialized();
            return this._internalFormat;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextureCube.prototype, "format", {
        get: function () {
            this.assertInitialized();
            return this._format;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextureCube.prototype, "type", {
        get: function () {
            this.assertInitialized();
            return this._type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextureCube.prototype, "size", {
        get: function () {
            this.assertInitialized();
            return this._size;
        },
        enumerable: true,
        configurable: true
    });
    TextureCube.DEFAULT_TEXTURE = undefined;
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], TextureCube.prototype, "bind", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], TextureCube.prototype, "unbind", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], TextureCube.prototype, "fetch", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], TextureCube.prototype, "data", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], TextureCube.prototype, "filter", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], TextureCube.prototype, "wrap", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], TextureCube.prototype, "levels", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], TextureCube.prototype, "reformat", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], TextureCube.prototype, "resize", null);
    return TextureCube;
}(object_1.AbstractObject));
exports.TextureCube = TextureCube;


/***/ }),

/***/ "./tilecameragenerator.ts":
/*!********************************!*\
  !*** ./tilecameragenerator.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "../node_modules/gl-matrix/esm/index.js");
var gl_matrix_extensions_1 = __webpack_require__(/*! ./gl-matrix-extensions */ "./gl-matrix-extensions.ts");
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var TileCameraGenerator = (function () {
    function TileCameraGenerator() {
        this._tileSize = [0, 0];
        this._padding = gl_matrix_1.vec4.fromValues(0, 0, 0, 0);
        this._tile = -1;
        this._algorithm = TileCameraGenerator.Algorithm.ScanLine;
        this._offset = [0, 0];
    }
    TileCameraGenerator.hilbertIndices = function (indices, numX, numY, x, y, xi, xj, yi, yj, depth, hilbertIndex) {
        if (depth > 0) {
            hilbertIndex = this.hilbertIndices(indices, numX, numY, x, y, yi / 2, yj / 2, xi / 2, xj / 2, depth - 1, hilbertIndex);
            hilbertIndex = this.hilbertIndices(indices, numX, numY, x + xi / 2, y + xj / 2, xi / 2, xj / 2, yi / 2, yj / 2, depth - 1, hilbertIndex);
            hilbertIndex = this.hilbertIndices(indices, numX, numY, x + xi / 2 + yi / 2, y + xj / 2 + yj / 2, xi / 2, xj / 2, yi / 2, yj / 2, depth - 1, hilbertIndex);
            hilbertIndex = this.hilbertIndices(indices, numX, numY, x + xi / 2 + yi, y + xj / 2 + yj, -yi / 2, -yj / 2, -xi / 2, -xj / 2, depth - 1, hilbertIndex);
            return hilbertIndex;
        }
        x = x + (xi + yi - 1) / 2;
        y = y + (xj + yj - 1) / 2;
        if (x < numX && y < numY) {
            var i = hilbertIndex * 2;
            indices[i + 0] = x;
            indices[i + 1] = y;
            ++hilbertIndex;
        }
        return hilbertIndex;
    };
    TileCameraGenerator.generateHilbertIndices = function (indices, numX, numY) {
        auxiliaries_1.assert(indices.length === 2 * numX * numY, "expected interleaved indices-array of length " + 2 * numX * numY + ", given " + indices.length);
        var tableSize = Math.max(numX, numY);
        var recursionDepth = Math.ceil(Math.log2(tableSize));
        var uPow2 = auxiliaries_1.upperPowerOfTwo(tableSize);
        this.hilbertIndices(indices, numX, numY, 0, 0, uPow2, 0, 0, uPow2, recursionDepth, 0);
    };
    TileCameraGenerator.generateScanLineIndices = function (indices, numX, numY) {
        auxiliaries_1.assert(indices.length === 2 * numX * numY, "expected interleaved indices-array of length " + 2 * numX * numY + ", given " + indices.length);
        for (var y = 0; y < numY; ++y) {
            for (var x = 0; x < numX; ++x) {
                var i = (x + y * numX) * 2;
                indices[i + 0] = x;
                indices[i + 1] = y;
            }
        }
    };
    TileCameraGenerator.generateZCurveIndices = function (indices, numX, numY) {
        auxiliaries_1.assert(indices.length === 2 * numX * numY, "expected interleaved indices-array of length " + 2 * numX * numY + ", given " + indices.length);
        var tableSize = Math.max(numX, numY);
        var maxZIndexBitLength = Math.floor(Math.log2(tableSize)) * 2;
        var zIndex = 0;
        for (var numberOfFoundIndices = 0; numberOfFoundIndices < numX * numY; ++zIndex) {
            var x = 0;
            var y = 0;
            for (var currentBit = 0; currentBit < maxZIndexBitLength; ++currentBit) {
                var xBit = zIndex >> (currentBit * 2) & 1;
                x += xBit << currentBit;
                var yBit = zIndex >> (currentBit * 2 + 1) & 1;
                y += yBit << currentBit;
            }
            if (x < numX && y < numY) {
                var i = numberOfFoundIndices * 2;
                indices[i + 0] = x;
                indices[i + 1] = y;
                ++numberOfFoundIndices;
            }
        }
    };
    TileCameraGenerator.prototype.invalidate = function (clearIndices) {
        if (clearIndices) {
            this._indices = new Uint16Array(0);
        }
        this._valid = false;
    };
    TileCameraGenerator.prototype.ensureValidIterationIndices = function () {
        if (this._indices.length > 0) {
            return;
        }
        this._indices = new Uint16Array(this.numTiles * 2);
        switch (this._algorithm) {
            case TileCameraGenerator.Algorithm.ScanLine:
                TileCameraGenerator.generateScanLineIndices(this._indices, this.numXTiles, this.numYTiles);
                break;
            case TileCameraGenerator.Algorithm.HilbertCurve:
                TileCameraGenerator.generateHilbertIndices(this._indices, this.numXTiles, this.numYTiles);
                break;
            case TileCameraGenerator.Algorithm.ZCurve:
                TileCameraGenerator.generateZCurveIndices(this._indices, this.numXTiles, this.numYTiles);
                break;
            default:
                TileCameraGenerator.generateScanLineIndices(this._indices, this.numXTiles, this.numYTiles);
        }
    };
    TileCameraGenerator.prototype.tableIndices = function () {
        this.ensureValidIterationIndices();
        var i = this.tile * 2;
        return [this._indices[i + 0], this._indices[i + 1]];
    };
    TileCameraGenerator.prototype.getPaddedTileSize = function () {
        return [this.padding[1] + this.padding[3] + this.tileSize[0],
            this.padding[0] + this.padding[2] + this.tileSize[1]];
    };
    TileCameraGenerator.prototype.nextTile = function () {
        if (this.tile >= this.numTiles - 1) {
            return false;
        }
        if (this.tile < 0) {
            this.tile = -1;
        }
        ++this.tile;
        this.update();
        return true;
    };
    TileCameraGenerator.prototype.hasNextTile = function () {
        return this.tile < this.numTiles - 1 && this.tile >= 0;
    };
    TileCameraGenerator.prototype.reset = function () {
        this.tile = -1;
        this._offset[0] = 0;
        this._offset[1] = 0;
    };
    TileCameraGenerator.prototype.sourceCameraChanged = function () {
        auxiliaries_1.assert(this._sourceCamera !== undefined, "expected the unput/source camera to be defined");
        this._camera = Object.create(this._sourceCamera);
    };
    TileCameraGenerator.prototype.update = function () {
        if (this._valid) {
            return this._offset;
        }
        if (this.numTiles <= this.tile || 0 > this.tile) {
            auxiliaries_1.log(auxiliaries_1.LogLevel.Warning, "index " + this.tile + " is out of bounds " + this.numTiles + ", returning first tile");
            return this._offset;
        }
        auxiliaries_1.assert(this._sourceViewport !== undefined && this._sourceCamera !== undefined, "expected source camera and source viewport to be defined before updating");
        this._valid = true;
        var tableIndices = this.tableIndices();
        var viewport = this.sourceViewport;
        var paddedTileSize = this.getPaddedTileSize();
        var paddedTileCenter = [0, 0];
        paddedTileCenter[0] = tableIndices[0] * this.tileSize[0] + paddedTileSize[0] / 2;
        paddedTileCenter[1] = tableIndices[1] * this.tileSize[1] + paddedTileSize[1] / 2;
        var offset = [0, 0];
        offset[0] = tableIndices[0] * this.tileSize[0];
        offset[1] = tableIndices[1] * this.tileSize[1];
        var paddedTileCenterNDC = [paddedTileCenter[0] * 2 / viewport[0] - 1,
            paddedTileCenter[1] * 2 / viewport[1] - 1];
        var scaleVec = gl_matrix_1.vec3.fromValues(viewport[0] / paddedTileSize[0], viewport[1] / paddedTileSize[1], 1);
        var translationVec = gl_matrix_1.vec3.fromValues(-paddedTileCenterNDC[0], -paddedTileCenterNDC[1], 0);
        var tileNDCCorrectionMatrix = gl_matrix_1.mat4.scale(gl_matrix_extensions_1.m4(), gl_matrix_1.mat4.identity(gl_matrix_extensions_1.m4()), scaleVec);
        var translateMatrix = gl_matrix_1.mat4.translate(gl_matrix_extensions_1.m4(), tileNDCCorrectionMatrix, translationVec);
        this._camera.postViewProjection = translateMatrix;
        this._offset = offset;
        return offset;
    };
    Object.defineProperty(TileCameraGenerator.prototype, "valid", {
        get: function () {
            return this._camera !== undefined && this._sourceCamera !== undefined && this._valid;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TileCameraGenerator.prototype, "numXTiles", {
        get: function () {
            auxiliaries_1.assert(this._sourceViewport !== undefined, "expected the source viewport to be defined");
            return Math.ceil(this.sourceViewport[0] / this.tileSize[0]);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TileCameraGenerator.prototype, "numYTiles", {
        get: function () {
            auxiliaries_1.assert(this._sourceViewport !== undefined, "expected the source viewport to be defined");
            return Math.ceil(this.sourceViewport[1] / this.tileSize[1]);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TileCameraGenerator.prototype, "numTiles", {
        get: function () {
            return this.numXTiles * this.numYTiles;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TileCameraGenerator.prototype, "offset", {
        get: function () {
            return this._offset;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TileCameraGenerator.prototype, "camera", {
        get: function () {
            return this._camera;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TileCameraGenerator.prototype, "viewport", {
        get: function () {
            return [this.offset[0], this.offset[1], this.tileSize[0], this.tileSize[1]];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TileCameraGenerator.prototype, "sourceCamera", {
        get: function () {
            return this._sourceCamera;
        },
        set: function (camera) {
            if (camera === undefined) {
                this._sourceCamera = this._camera = undefined;
                return;
            }
            this._sourceCamera = camera;
            this._camera = Object.create(camera);
            this.invalidate(false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TileCameraGenerator.prototype, "tile", {
        get: function () {
            return this._tile;
        },
        set: function (index) {
            if (this._tile === index) {
                return;
            }
            this._tile = index;
            this.invalidate(false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TileCameraGenerator.prototype, "sourceViewport", {
        get: function () {
            return this._sourceViewport;
        },
        set: function (viewport) {
            if (this._sourceViewport !== undefined && viewport !== undefined &&
                this._sourceViewport[0] === viewport[0] && this._sourceViewport[1] === viewport[1]) {
                return;
            }
            this._sourceViewport = viewport;
            this.invalidate(true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TileCameraGenerator.prototype, "tileSize", {
        get: function () {
            return this._tileSize;
        },
        set: function (tileSize) {
            if (this._tileSize[0] === tileSize[0] && this._tileSize[1] === tileSize[1]) {
                return;
            }
            this._tileSize = tileSize;
            this.invalidate(true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TileCameraGenerator.prototype, "padding", {
        get: function () {
            return this._padding;
        },
        set: function (padding) {
            if (gl_matrix_1.vec4.equals(this._padding, padding)) {
                return;
            }
            this._padding = gl_matrix_1.vec4.clone(padding);
            this.invalidate(false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TileCameraGenerator.prototype, "algorithm", {
        get: function () {
            return this._algorithm;
        },
        set: function (algorithm) {
            if (this._algorithm === algorithm) {
                return;
            }
            this._algorithm = algorithm;
            this.invalidate(true);
        },
        enumerable: true,
        configurable: true
    });
    return TileCameraGenerator;
}());
exports.TileCameraGenerator = TileCameraGenerator;
(function (TileCameraGenerator) {
    var Algorithm;
    (function (Algorithm) {
        Algorithm["ScanLine"] = "scanline";
        Algorithm["HilbertCurve"] = "hilbertcurve";
        Algorithm["ZCurve"] = "zcurve";
    })(Algorithm = TileCameraGenerator.Algorithm || (TileCameraGenerator.Algorithm = {}));
})(TileCameraGenerator = exports.TileCameraGenerator || (exports.TileCameraGenerator = {}));
exports.TileCameraGenerator = TileCameraGenerator;


/***/ }),

/***/ "./toucheventprovider.ts":
/*!*******************************!*\
  !*** ./toucheventprovider.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var rxjs_1 = __webpack_require__(/*! rxjs */ "rxjs");
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var TouchEventProvider = (function () {
    function TouchEventProvider(element, timeframe) {
        auxiliaries_1.assert(element !== undefined, "expected valid canvas element on initialization, given " + element);
        this._element = element;
        this._timeframe = timeframe;
    }
    TouchEventProvider.prototype.preventDefaultOnEvent = function (type, event) {
        if (auxiliaries_1.bitInBitfield(this._preventDefaultMask, type)) {
            event.preventDefault();
        }
    };
    TouchEventProvider.prototype.preventDefault = function () {
        var types = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            types[_i] = arguments[_i];
        }
        for (var _a = 0, types_1 = types; _a < types_1.length; _a++) {
            var type = types_1[_a];
            if (!auxiliaries_1.bitInBitfield(this._preventDefaultMask, type)) {
                this._preventDefaultMask |= type;
            }
        }
    };
    TouchEventProvider.prototype.allowDefault = function () {
        var types = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            types[_i] = arguments[_i];
        }
        for (var _a = 0, types_2 = types; _a < types_2.length; _a++) {
            var type = types_2[_a];
            if (auxiliaries_1.bitInBitfield(this._preventDefaultMask, type)) {
                this._preventDefaultMask &= ~type;
            }
        }
    };
    TouchEventProvider.prototype.observable = function (type) {
        switch (type) {
            case TouchEventProvider.Type.Start:
                return this.start$;
            case TouchEventProvider.Type.End:
                return this.end$;
            case TouchEventProvider.Type.Move:
                return this.move$;
            case TouchEventProvider.Type.Cancel:
                return this.cancel$;
        }
        auxiliaries_1.assert(false, 'Encountered unknown touch event.');
        return new rxjs_1.Observable();
    };
    Object.defineProperty(TouchEventProvider.prototype, "start$", {
        get: function () {
            var _this = this;
            if (this._startSubject === undefined) {
                this._startSubject = new rxjs_1.ReplaySubject(undefined, this._timeframe);
                this._startListener = function (event) {
                    _this.preventDefaultOnEvent(TouchEventProvider.Type.Start, event);
                    _this._startSubject.next(event);
                };
                this._element.addEventListener('touchstart', this._startListener);
            }
            return this._startSubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TouchEventProvider.prototype, "end$", {
        get: function () {
            var _this = this;
            if (this._endSubject === undefined) {
                this._endSubject = new rxjs_1.ReplaySubject(undefined, this._timeframe);
                this._endListener = function (event) {
                    _this.preventDefaultOnEvent(TouchEventProvider.Type.End, event);
                    _this._endSubject.next(event);
                };
                this._element.addEventListener('touchend', this._endListener);
            }
            return this._endSubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TouchEventProvider.prototype, "move$", {
        get: function () {
            var _this = this;
            if (this._moveSubject === undefined) {
                this._moveSubject = new rxjs_1.ReplaySubject(undefined, this._timeframe);
                this._moveListener = function (event) {
                    _this.preventDefaultOnEvent(TouchEventProvider.Type.Move, event);
                    _this._moveSubject.next(event);
                };
                this._element.addEventListener('touchmove', this._moveListener);
            }
            return this._moveSubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TouchEventProvider.prototype, "cancel$", {
        get: function () {
            var _this = this;
            if (this._cancelSubject === undefined) {
                this._cancelSubject = new rxjs_1.ReplaySubject(undefined, this._timeframe);
                this._cancelListener = function (event) {
                    _this.preventDefaultOnEvent(TouchEventProvider.Type.Cancel, event);
                    _this._cancelSubject.next(event);
                };
                this._element.addEventListener('touchcancel', this._cancelListener);
            }
            return this._cancelSubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    return TouchEventProvider;
}());
exports.TouchEventProvider = TouchEventProvider;
(function (TouchEventProvider) {
    var Type;
    (function (Type) {
        Type[Type["Start"] = 1] = "Start";
        Type[Type["End"] = 2] = "End";
        Type[Type["Move"] = 4] = "Move";
        Type[Type["Cancel"] = 8] = "Cancel";
    })(Type = TouchEventProvider.Type || (TouchEventProvider.Type = {}));
})(TouchEventProvider = exports.TouchEventProvider || (exports.TouchEventProvider = {}));
exports.TouchEventProvider = TouchEventProvider;


/***/ }),

/***/ "./trackballmodifier.ts":
/*!******************************!*\
  !*** ./trackballmodifier.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "../node_modules/gl-matrix/esm/index.js");
var gl_matrix_extensions_1 = __webpack_require__(/*! ./gl-matrix-extensions */ "./gl-matrix-extensions.ts");
var cameramodifier_1 = __webpack_require__(/*! ./cameramodifier */ "./cameramodifier.ts");
var TrackballModifier = (function (_super) {
    __extends(TrackballModifier, _super);
    function TrackballModifier() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._rotation = gl_matrix_1.mat4.create();
        _this._sensitivity = TrackballModifier.DEFAULT_SENSITIVITY;
        return _this;
    }
    TrackballModifier.prototype.initiate = function (point) {
        this._initialPoint = point;
    };
    TrackballModifier.prototype.process = function (point) {
        this._currentPoint = point;
        var magnitudes = gl_matrix_1.vec2.subtract(gl_matrix_extensions_1.v2(), this._initialPoint, this._currentPoint);
        gl_matrix_1.vec2.scale(magnitudes, magnitudes, window.devicePixelRatio * this._sensitivity);
        gl_matrix_1.vec2.copy(this._initialPoint, this._currentPoint);
        var centerToEye = gl_matrix_1.vec3.sub(gl_matrix_extensions_1.v3(), this._reference.eye, this._reference.center);
        gl_matrix_1.vec3.normalize(centerToEye, centerToEye);
        var up = gl_matrix_1.vec3.normalize(gl_matrix_extensions_1.v3(), this._reference.up);
        var ortho = gl_matrix_1.vec3.cross(gl_matrix_extensions_1.v3(), centerToEye, up);
        gl_matrix_1.vec3.scale(up, up, magnitudes[1]);
        gl_matrix_1.vec3.scale(ortho, ortho, magnitudes[0]);
        var axis = gl_matrix_1.vec3.cross(gl_matrix_extensions_1.v3(), gl_matrix_1.vec3.add(gl_matrix_extensions_1.v3(), up, ortho), centerToEye);
        gl_matrix_1.vec3.normalize(axis, axis);
        var q = gl_matrix_1.quat.setAxisAngle(gl_matrix_1.quat.create(), axis, gl_matrix_1.vec2.len(magnitudes));
        gl_matrix_1.mat4.multiply(this._rotation, this._rotation, gl_matrix_1.mat4.fromQuat(gl_matrix_extensions_1.m4(), q));
        this.update();
    };
    TrackballModifier.prototype.update = function () {
        if (this._camera === undefined) {
            return;
        }
        var T = gl_matrix_1.mat4.fromTranslation(gl_matrix_extensions_1.m4(), this._reference.center);
        gl_matrix_1.mat4.multiply(T, T, this._rotation);
        gl_matrix_1.mat4.translate(T, T, gl_matrix_1.vec3.negate(gl_matrix_extensions_1.v3(), this._reference.center));
        var up = gl_matrix_1.vec3.transformMat4(gl_matrix_extensions_1.v3(), [0.0, 1.0, 0.0], this._rotation);
        var eye = gl_matrix_1.vec3.transformMat4(gl_matrix_extensions_1.v3(), this._reference.eye, T);
        this._camera.up = up;
        this._camera.eye = eye;
    };
    Object.defineProperty(TrackballModifier.prototype, "sensitivity", {
        get: function () {
            return this._sensitivity;
        },
        set: function (sensitivity) {
            this._sensitivity = sensitivity;
        },
        enumerable: true,
        configurable: true
    });
    TrackballModifier.DEFAULT_SENSITIVITY = 0.002;
    return TrackballModifier;
}(cameramodifier_1.CameraModifier));
exports.TrackballModifier = TrackballModifier;


/***/ }),

/***/ "./tuples.ts":
/*!*******************!*\
  !*** ./tuples.ts ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "../node_modules/gl-matrix/esm/index.js");
var gl_matrix_extensions_1 = __webpack_require__(/*! ./gl-matrix-extensions */ "./gl-matrix-extensions.ts");
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var tuples;
(function (tuples) {
    function tuple2(buffer) {
        auxiliaries_1.assert(buffer.length === 2, "expected length of buffer to be 2, given " + buffer.length);
        return [buffer[0], buffer[1]];
    }
    tuples.tuple2 = tuple2;
    function tuple3(buffer) {
        auxiliaries_1.assert(buffer.length === 3, "expected length of buffer to be 3, given " + buffer.length);
        return [buffer[0], buffer[1], buffer[2]];
    }
    tuples.tuple3 = tuple3;
    function tuple4(buffer) {
        auxiliaries_1.assert(buffer.length === 4, "expected length of buffer to be 4, given " + buffer.length);
        return [buffer[0], buffer[1], buffer[2], buffer[3]];
    }
    tuples.tuple4 = tuple4;
    function clampf(value, semantic) {
        var valueV1 = gl_matrix_extensions_1.clamp(value, 0.0, 1.0);
        auxiliaries_1.logIf(semantic !== undefined && value < 0.0 || value > 1.0, auxiliaries_1.LogLevel.Info, semantic + " clamped to [" + valueV1 + "], given [" + value + "]");
        return valueV1;
    }
    tuples.clampf = clampf;
    function clampf2(tuple, semantic) {
        var tupleV2 = gl_matrix_1.vec2.fromValues(tuple[0], tuple[1]);
        if (tuple[0] < 0.0 || tuple[0] > 1.0 || tuple[1] < 0.0 || tuple[1] > 1.0) {
            gl_matrix_extensions_1.clamp2(tupleV2, tupleV2, gl_matrix_1.vec2.fromValues(0.0, 0.0), gl_matrix_1.vec2.fromValues(1.0, 1.0));
            auxiliaries_1.logIf(semantic !== undefined, auxiliaries_1.LogLevel.Info, semantic + " clamped to [" + tupleV2 + "], given [" + tuple + "]");
        }
        return tuple2(tupleV2);
    }
    tuples.clampf2 = clampf2;
    function clampf3(tuple, semantic) {
        var tupleV3 = gl_matrix_1.vec3.fromValues(tuple[0], tuple[1], tuple[2]);
        if (tuple[0] < 0.0 || tuple[0] > 1.0 || tuple[1] < 0.0 || tuple[1] > 1.0 || tuple[2] < 0.0 || tuple[2] > 1.0) {
            gl_matrix_extensions_1.clamp3(tupleV3, tupleV3, gl_matrix_1.vec3.fromValues(0.0, 0.0, 0.0), gl_matrix_1.vec3.fromValues(1.0, 1.0, 1.0));
            auxiliaries_1.logIf(semantic !== undefined, auxiliaries_1.LogLevel.Info, semantic + " clamped to [" + tupleV3 + "], given [" + tuple + "]");
        }
        return tuple3(tupleV3);
    }
    tuples.clampf3 = clampf3;
    function clampf4(tuple, semantic) {
        var tupleV4 = gl_matrix_1.vec4.fromValues(tuple[0], tuple[1], tuple[2], tuple[3]);
        if (tuple[0] < 0.0 || tuple[0] > 1.0 || tuple[1] < 0.0 || tuple[1] > 1.0 ||
            tuple[2] < 0.0 || tuple[2] > 1.0 || tuple[3] < 0.0 || tuple[3] > 1.0) {
            gl_matrix_extensions_1.clamp4(tupleV4, tupleV4, gl_matrix_1.vec4.fromValues(0.0, 0.0, 0.0, 0.0), gl_matrix_1.vec4.fromValues(1.0, 1.0, 1.0, 1.0));
            auxiliaries_1.logIf(semantic !== undefined, auxiliaries_1.LogLevel.Info, semantic + " clamped to [" + tupleV4 + "], given [" + tuple + "]");
        }
        return tuple4(tupleV4);
    }
    tuples.clampf4 = clampf4;
    function duplicate2(tuple) {
        return [tuple[0], tuple[1]];
    }
    tuples.duplicate2 = duplicate2;
    function duplicate3(tuple) {
        return [tuple[0], tuple[1], tuple[2]];
    }
    tuples.duplicate3 = duplicate3;
    function duplicate4(tuple) {
        return [tuple[0], tuple[1], tuple[2], tuple[3]];
    }
    tuples.duplicate4 = duplicate4;
    function equals2(t0, t1) {
        return t0[0] === t1[0] && t0[1] === t1[1];
    }
    tuples.equals2 = equals2;
    function equals3(t0, t1) {
        return t0[0] === t1[0] && t0[1] === t1[1] && t0[2] === t1[2];
    }
    tuples.equals3 = equals3;
    function equals4(t0, t1) {
        return t0[0] === t1[0] && t0[1] === t1[1] && t0[2] === t1[2] && t0[3] === t1[3];
    }
    tuples.equals4 = equals4;
})(tuples || (tuples = {}));
module.exports = tuples;


/***/ }),

/***/ "./turntablemodifier.ts":
/*!******************************!*\
  !*** ./turntablemodifier.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "../node_modules/gl-matrix/esm/index.js");
var gl_matrix_extensions_1 = __webpack_require__(/*! ./gl-matrix-extensions */ "./gl-matrix-extensions.ts");
var cameramodifier_1 = __webpack_require__(/*! ./cameramodifier */ "./cameramodifier.ts");
var TurntableModifier = (function (_super) {
    __extends(TurntableModifier, _super);
    function TurntableModifier() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._rotation = gl_matrix_extensions_1.m4();
        _this._maxAzimuth = +Math.PI * 0.5 - 1e-4;
        _this._minAzimuth = -Math.PI * 0.5 + 1e-4;
        _this._xAxisScreenSpace = gl_matrix_extensions_1.v3();
        _this._sensitivity = TurntableModifier.DEFAULT_SENSITIVITY;
        return _this;
    }
    TurntableModifier.prototype.initiate = function (point) {
        Object.assign(this._reference, this._camera);
        this._initialPoint = point;
        var centerToEye = gl_matrix_1.vec3.sub(gl_matrix_extensions_1.v3(), this._reference.eye, this._reference.center);
        gl_matrix_1.vec3.normalize(centerToEye, centerToEye);
        this._xAxisScreenSpace = gl_matrix_1.vec3.cross(gl_matrix_extensions_1.v3(), [0.0, 1.0, 0.0], centerToEye);
        this._azimuth = Math.acos(gl_matrix_1.vec3.dot(centerToEye, [0.0, 1.0, 0.0]));
        this._azimuth = Math.PI * 0.5 - this._azimuth;
    };
    TurntableModifier.prototype.process = function (point) {
        this._currentPoint = point;
        var magnitudes = gl_matrix_1.vec2.subtract(gl_matrix_extensions_1.v2(), this._initialPoint, this._currentPoint);
        gl_matrix_1.vec2.scale(magnitudes, magnitudes, window.devicePixelRatio * this._sensitivity);
        if (this._minAzimuth) {
            magnitudes[1] = Math.min(this._azimuth - this._minAzimuth, magnitudes[1]);
        }
        if (this._maxAzimuth) {
            magnitudes[1] = Math.max(this._azimuth - this._maxAzimuth, magnitudes[1]);
        }
        gl_matrix_1.mat4.rotateY(this._rotation, gl_matrix_extensions_1.m4(), magnitudes[0]);
        gl_matrix_1.mat4.rotate(this._rotation, this._rotation, magnitudes[1], this._xAxisScreenSpace);
        this.update();
    };
    TurntableModifier.prototype.update = function () {
        if (this._camera === undefined) {
            return;
        }
        var T = gl_matrix_1.mat4.fromTranslation(gl_matrix_extensions_1.m4(), this._reference.center);
        gl_matrix_1.mat4.multiply(T, T, this._rotation);
        gl_matrix_1.mat4.translate(T, T, gl_matrix_1.vec3.negate(gl_matrix_extensions_1.v3(), this._reference.center));
        var up = gl_matrix_1.vec3.transformMat4(gl_matrix_extensions_1.v3(), [0.0, 1.0, 0.0], this._rotation);
        var eye = gl_matrix_1.vec3.transformMat4(gl_matrix_extensions_1.v3(), this._reference.eye, T);
        this._camera.up = up;
        this._camera.eye = eye;
    };
    Object.defineProperty(TurntableModifier.prototype, "sensitivity", {
        get: function () {
            return this._sensitivity;
        },
        set: function (sensitivity) {
            this._sensitivity = sensitivity;
        },
        enumerable: true,
        configurable: true
    });
    TurntableModifier.DEFAULT_SENSITIVITY = 0.002;
    return TurntableModifier;
}(cameramodifier_1.CameraModifier));
exports.TurntableModifier = TurntableModifier;


/***/ }),

/***/ "./unifiedbuffer.ts":
/*!**************************!*\
  !*** ./unifiedbuffer.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var buffer_1 = __webpack_require__(/*! ./buffer */ "./buffer.ts");
var initializable_1 = __webpack_require__(/*! ./initializable */ "./initializable.ts");
var UnifiedBuffer = (function (_super) {
    __extends(UnifiedBuffer, _super);
    function UnifiedBuffer(context, sizeInBytes, usage, mergeThreshold, identifier) {
        if (mergeThreshold === void 0) { mergeThreshold = 0; }
        var _this = _super.call(this) || this;
        _this._updates = new Array();
        _this._cpuBuffer = new ArrayBuffer(sizeInBytes);
        _this._gpuBuffer = new buffer_1.Buffer(context, identifier);
        _this._usage = usage;
        _this._mergeThreshold = mergeThreshold;
        return _this;
    }
    UnifiedBuffer.updatesNeedMerge = function (lhsUpdate, rhsUpdate, mergeThreshold) {
        return rhsUpdate.begin - lhsUpdate.end < mergeThreshold || mergeThreshold === -1;
    };
    UnifiedBuffer.prototype.mergeUpdatesLeft = function (index) {
        var removeCount = 0;
        var rhs = this._updates[index];
        for (var i = index - 1; i >= 0; i--) {
            var lhs = this._updates[i];
            if (UnifiedBuffer.updatesNeedMerge(lhs, rhs, this._mergeThreshold)) {
                rhs.begin = Math.min(rhs.begin, lhs.begin);
                rhs.end = Math.max(rhs.end, lhs.end);
                removeCount++;
            }
            else {
                break;
            }
        }
        this._updates.splice(index - removeCount, removeCount);
        return removeCount + 1;
    };
    UnifiedBuffer.prototype.mergeUpdatesRight = function (index) {
        var removeCount = 0;
        var lhs = this._updates[index];
        for (var i = index + 1; i < this._updates.length; i++) {
            var rhs = this._updates[i];
            if (UnifiedBuffer.updatesNeedMerge(lhs, rhs, this._mergeThreshold)) {
                lhs.begin = Math.min(lhs.begin, rhs.begin);
                lhs.end = Math.max(lhs.end, rhs.end);
                removeCount++;
            }
            else {
                break;
            }
        }
        this._updates.splice(index + 1, removeCount);
        return removeCount + 1;
    };
    UnifiedBuffer.prototype.addUpdate = function (update) {
        var start = this._updates.findIndex(function (current) {
            return update.begin < current.begin;
        });
        if (start === -1) {
            this._updates.push(update);
            this.mergeUpdatesLeft(this._updates.length - 1);
        }
        else {
            this._updates.splice(start, 0, update);
            this.mergeUpdatesRight(start);
            this.mergeUpdatesLeft(start);
        }
    };
    UnifiedBuffer.prototype.initialize = function (target) {
        return this._gpuBuffer.initialize(target);
    };
    UnifiedBuffer.prototype.uninitialize = function () {
        this._gpuBuffer.uninitialize();
    };
    UnifiedBuffer.prototype.bind = function () {
        this._gpuBuffer.bind();
    };
    UnifiedBuffer.prototype.unbind = function () {
        this._gpuBuffer.unbind();
    };
    UnifiedBuffer.prototype.attribEnable = function (index, size, type, normalized, stride, offset, bind, unbind) {
        if (normalized === void 0) { normalized = false; }
        if (stride === void 0) { stride = 0; }
        if (offset === void 0) { offset = 0; }
        if (bind === void 0) { bind = true; }
        if (unbind === void 0) { unbind = true; }
        this._gpuBuffer.attribEnable(index, size, type, normalized, stride, offset, bind, unbind);
    };
    UnifiedBuffer.prototype.attribDisable = function (index, bind, unbind) {
        if (bind === void 0) { bind = true; }
        if (unbind === void 0) { unbind = true; }
        this._gpuBuffer.attribDisable(index, bind, unbind);
    };
    UnifiedBuffer.prototype.mergeSubDataRanges = function () {
        var index = 0;
        while (index < this._updates.length) {
            index += this.mergeUpdatesRight(index);
        }
    };
    UnifiedBuffer.prototype.subData = function (dstByteOffset, srcData) {
        var src;
        if (srcData instanceof ArrayBuffer) {
            src = new Uint8Array(srcData);
        }
        else {
            src = new Uint8Array(srcData.buffer).subarray(srcData.byteOffset, srcData.byteOffset + srcData.byteLength);
        }
        var dst = new Uint8Array(this._cpuBuffer);
        dst.set(src, dstByteOffset);
        this.addUpdate({ begin: dstByteOffset, end: dstByteOffset + src.byteLength });
    };
    UnifiedBuffer.prototype.update = function (bind, unbind) {
        if (bind === void 0) { bind = false; }
        if (unbind === void 0) { unbind = false; }
        if (bind) {
            this._gpuBuffer.bind();
        }
        if (this._gpuBuffer.bytes !== this._cpuBuffer.byteLength) {
            this._gpuBuffer.data(this._cpuBuffer, this._usage);
        }
        else {
            var bufferView = new Uint8Array(this._cpuBuffer);
            for (var _i = 0, _a = this._updates; _i < _a.length; _i++) {
                var update = _a[_i];
                var subBufferView = bufferView.subarray(update.begin, update.end);
                this._gpuBuffer.subData(update.begin, subBufferView);
            }
        }
        if (unbind) {
            this._gpuBuffer.unbind();
        }
        this._updates.length = 0;
    };
    Object.defineProperty(UnifiedBuffer.prototype, "size", {
        get: function () {
            return this._cpuBuffer.byteLength;
        },
        set: function (sizeInBytes) {
            var oldBuffer = this._cpuBuffer;
            this._cpuBuffer = new ArrayBuffer(sizeInBytes);
            var src = new Uint8Array(oldBuffer).slice(0, sizeInBytes);
            var dst = new Uint8Array(this._cpuBuffer);
            dst.set(src);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UnifiedBuffer.prototype, "target", {
        get: function () {
            this.assertInitialized();
            return this._gpuBuffer.target;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UnifiedBuffer.prototype, "usage", {
        get: function () {
            return this._usage;
        },
        set: function (usage) {
            this._usage = usage;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UnifiedBuffer.prototype, "mergeThreshold", {
        get: function () {
            return this._mergeThreshold;
        },
        set: function (mergeThreshold) {
            this._mergeThreshold = mergeThreshold;
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        initializable_1.Initializable.initialize()
    ], UnifiedBuffer.prototype, "initialize", null);
    __decorate([
        initializable_1.Initializable.uninitialize()
    ], UnifiedBuffer.prototype, "uninitialize", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], UnifiedBuffer.prototype, "bind", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], UnifiedBuffer.prototype, "unbind", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], UnifiedBuffer.prototype, "attribEnable", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], UnifiedBuffer.prototype, "attribDisable", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], UnifiedBuffer.prototype, "update", null);
    return UnifiedBuffer;
}(initializable_1.Initializable));
exports.UnifiedBuffer = UnifiedBuffer;


/***/ }),

/***/ "./version.ts":
/*!********************!*\
  !*** ./version.ts ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.branch =  true ? "" + "thesis-renderer" : undefined;
exports.commit =  true ? "" + "33aa863bf5980cb01bf6f6246f26ec55123cc884" : undefined;
exports.version =  true ? "" + "33aa863" : undefined;


/***/ }),

/***/ "./vertexarray.ts":
/*!************************!*\
  !*** ./vertexarray.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var initializable_1 = __webpack_require__(/*! ./initializable */ "./initializable.ts");
var object_1 = __webpack_require__(/*! ./object */ "./object.ts");
var VertexArray = (function (_super) {
    __extends(VertexArray, _super);
    function VertexArray() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._buffersBound = false;
        return _this;
    }
    VertexArray.prototype.create = function (bindBOs, unbindBOs) {
        var _this = this;
        if (this.context.isWebGL2 || this.context.supportsVertexArrayObject) {
            var gl2facade_1 = this.context.gl2facade;
            this._object = gl2facade_1.createVertexArray();
            this._valid = this._object !== undefined;
            this._bind = function () {
                gl2facade_1.bindVertexArray(_this.object);
                if (_this._buffersBound) {
                    return;
                }
                bindBOs();
                _this._buffersBound = true;
            };
            this._unbind = function () { return gl2facade_1.bindVertexArray(VertexArray.DEFAULT_VERTEX_ARRAY); };
        }
        else {
            this._bind = function () { return bindBOs(); };
            this._unbind = function () { return unbindBOs(); };
            this._valid = true;
        }
        return this._object;
    };
    VertexArray.prototype.delete = function () {
        if (!this.context.isWebGL2 && !this.context.supportsVertexArrayObject) {
            this._valid = false;
            return;
        }
        auxiliaries_1.assert(this._object !== undefined, "expected WebGLVertexArrayObject object");
        this._context.gl2facade.deleteVertexArray(this._object);
        this._object = undefined;
        this._valid = false;
        this._buffersBound = false;
    };
    VertexArray.prototype.bind = function () {
        this._bind();
    };
    VertexArray.prototype.unbind = function () {
        this._unbind();
    };
    VertexArray.prototype.invalidate = function () {
        this._buffersBound = false;
    };
    VertexArray.DEFAULT_VERTEX_ARRAY = undefined;
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], VertexArray.prototype, "bind", null);
    __decorate([
        initializable_1.Initializable.assert_initialized()
    ], VertexArray.prototype, "unbind", null);
    return VertexArray;
}(object_1.AbstractObject));
exports.VertexArray = VertexArray;


/***/ }),

/***/ "./viewer/eventblocker.ts":
/*!********************************!*\
  !*** ./viewer/eventblocker.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var viewer;
(function (viewer) {
    var EventBlocker = (function () {
        function EventBlocker(element, events) {
            this._blockListenerByEvent = new Map();
            this._element = element;
            if (events === undefined) {
                return;
            }
            for (var _i = 0, events_1 = events; _i < events_1.length; _i++) {
                var event_1 = events_1[_i];
                this.block(event_1);
            }
        }
        EventBlocker.prototype.block = function (eventIdentifier) {
            if (this._blockListenerByEvent.has(eventIdentifier)) {
                return;
            }
            this._blockListenerByEvent.set(eventIdentifier, function (event) {
                event.preventDefault();
                event.stopPropagation();
                return false;
            });
            this._element.addEventListener(eventIdentifier, this._blockListenerByEvent.get(eventIdentifier));
        };
        EventBlocker.prototype.unblock = function (eventIdentifier) {
            if (!this._blockListenerByEvent.has(eventIdentifier)) {
                return;
            }
            this._element.removeEventListener(eventIdentifier, this._blockListenerByEvent.get(eventIdentifier));
            this._blockListenerByEvent.delete(eventIdentifier);
        };
        return EventBlocker;
    }());
    viewer.EventBlocker = EventBlocker;
})(viewer || (viewer = {}));
module.exports = viewer;


/***/ }),

/***/ "./viewer/fullscreen.ts":
/*!******************************!*\
  !*** ./viewer/fullscreen.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var auxiliaries_1 = __webpack_require__(/*! ../auxiliaries */ "./auxiliaries.ts");
var viewer;
(function (viewer) {
    var Fullscreen = (function () {
        function Fullscreen() {
        }
        Fullscreen.queryAndCacheAPI = function () {
            if (Fullscreen._exit !== undefined) {
                return;
            }
            var document = window.document;
            var exits = [
                document.exitFullScreen,
                document.msExitFullscreen,
                document.mozCancelFullScreen,
                document.webkitExitFullscreen,
                undefined
            ];
            var api = 0;
            for (; api < exits.length; ++api) {
                if (exits[api] === undefined) {
                    continue;
                }
                break;
            }
            switch (api) {
                case 0:
                    Fullscreen._exit = function () { return document.exitFullScreen(); };
                    Fullscreen._request = function (element) { return element.requestFullscreen(); };
                    Fullscreen._element = function () { return document.fullscreenElement; };
                    Fullscreen._event = 'fullscreenchange';
                    break;
                case 1:
                    Fullscreen._exit = function () { return document.msExitFullscreen(); };
                    Fullscreen._request = function (element) { return element.msRequestFullscreen(); };
                    Fullscreen._element = function () { return document.msFullscreenElement; };
                    Fullscreen._event = 'msfullscreenchange';
                    break;
                case 2:
                    Fullscreen._exit = function () { return document.mozCancelFullScreen(); };
                    Fullscreen._request = function (element) { return element.mozRequestFullScreen(); };
                    Fullscreen._element = function () { return document.mozFullScreenElement; };
                    Fullscreen._event = 'mozfullscreenchange';
                    break;
                case 3:
                    Fullscreen._exit = function () { return document.webkitExitFullscreen(); };
                    Fullscreen._request = function (element) { return element.webkitRequestFullscreen(); };
                    Fullscreen._element = function () { return document.webkitFullscreenElement; };
                    Fullscreen._event = 'webkitfullscreenchange';
                    break;
                default:
                    auxiliaries_1.assert(false, "none of the following fullscreen apis was found: native, ms, moz, or webkit");
            }
        };
        Fullscreen.active = function () {
            return Fullscreen._element() !== undefined && Fullscreen._element() !== null;
        };
        Fullscreen.toggle = function (element, callback) {
            if (element === undefined) {
                return;
            }
            Fullscreen.queryAndCacheAPI();
            var isFullscreen = Fullscreen.active();
            if (!isFullscreen) {
                var style = getComputedStyle(element);
                Fullscreen._size[0] = style.width;
                Fullscreen._size[1] = style.height;
            }
            if (callback) {
                callback();
            }
            if (!isFullscreen) {
                Fullscreen._callback = callback;
                window.addEventListener(Fullscreen._event, Fullscreen.addEventListener);
            }
            else {
                Fullscreen._callback = undefined;
                window.removeEventListener(Fullscreen._event, Fullscreen.removeEventListener);
                element.style.width = Fullscreen._size[0];
                element.style.height = Fullscreen._size[1];
            }
            isFullscreen ? Fullscreen._exit() : Fullscreen._request(element);
        };
        Fullscreen._size = ['0', '0'];
        Fullscreen.addEventListener = function () {
            window.removeEventListener(Fullscreen._event, Fullscreen.addEventListener);
            window.addEventListener(Fullscreen._event, Fullscreen.removeEventListener);
        };
        Fullscreen.removeEventListener = function () {
            if (Fullscreen._callback) {
                Fullscreen._callback();
                Fullscreen._callback = undefined;
            }
            window.removeEventListener(Fullscreen._event, Fullscreen.removeEventListener);
        };
        return Fullscreen;
    }());
    viewer.Fullscreen = Fullscreen;
})(viewer || (viewer = {}));
module.exports = viewer;


/***/ }),

/***/ "./webgl-operate.slim.ts":
/*!*******************************!*\
  !*** ./webgl-operate.slim.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var version_1 = __webpack_require__(/*! ./version */ "./version.ts");
exports.branch = version_1.branch;
exports.commit = version_1.commit;
exports.version = version_1.version;
var context_1 = __webpack_require__(/*! ./context */ "./context.ts");
exports.Context = context_1.Context;
var canvas_1 = __webpack_require__(/*! ./canvas */ "./canvas.ts");
exports.Canvas = canvas_1.Canvas;
var controller_1 = __webpack_require__(/*! ./controller */ "./controller.ts");
exports.Controller = controller_1.Controller;
var initializable_1 = __webpack_require__(/*! ./initializable */ "./initializable.ts");
exports.Initializable = initializable_1.Initializable;
var contextmasquerade_1 = __webpack_require__(/*! ./contextmasquerade */ "./contextmasquerade.ts");
exports.ContextMasquerade = contextmasquerade_1.ContextMasquerade;
var extensionshash_1 = __webpack_require__(/*! ./extensionshash */ "./extensionshash.ts");
exports.ExtensionsHash = extensionshash_1.ExtensionsHash;
var changelookup_1 = __webpack_require__(/*! ./changelookup */ "./changelookup.ts");
exports.ChangeLookup = changelookup_1.ChangeLookup;
var mouseeventprovider_1 = __webpack_require__(/*! ./mouseeventprovider */ "./mouseeventprovider.ts");
exports.MouseEventProvider = mouseeventprovider_1.MouseEventProvider;
var toucheventprovider_1 = __webpack_require__(/*! ./toucheventprovider */ "./toucheventprovider.ts");
exports.TouchEventProvider = toucheventprovider_1.TouchEventProvider;
var eventhandler_1 = __webpack_require__(/*! ./eventhandler */ "./eventhandler.ts");
exports.EventHandler = eventhandler_1.EventHandler;
var buffer_1 = __webpack_require__(/*! ./buffer */ "./buffer.ts");
exports.Buffer = buffer_1.Buffer;
var color_1 = __webpack_require__(/*! ./color */ "./color.ts");
exports.Color = color_1.Color;
var colorscale_1 = __webpack_require__(/*! ./colorscale */ "./colorscale.ts");
exports.ColorScale = colorscale_1.ColorScale;
var defaultframebuffer_1 = __webpack_require__(/*! ./defaultframebuffer */ "./defaultframebuffer.ts");
exports.DefaultFramebuffer = defaultframebuffer_1.DefaultFramebuffer;
var framebuffer_1 = __webpack_require__(/*! ./framebuffer */ "./framebuffer.ts");
exports.Framebuffer = framebuffer_1.Framebuffer;
var geometry_1 = __webpack_require__(/*! ./geometry */ "./geometry.ts");
exports.Geometry = geometry_1.Geometry;
var program_1 = __webpack_require__(/*! ./program */ "./program.ts");
exports.Program = program_1.Program;
var renderbuffer_1 = __webpack_require__(/*! ./renderbuffer */ "./renderbuffer.ts");
exports.Renderbuffer = renderbuffer_1.Renderbuffer;
var renderer_1 = __webpack_require__(/*! ./renderer */ "./renderer.ts");
exports.Renderer = renderer_1.Renderer;
exports.LoadingStatus = renderer_1.LoadingStatus;
var shader_1 = __webpack_require__(/*! ./shader */ "./shader.ts");
exports.Shader = shader_1.Shader;
var texture2d_1 = __webpack_require__(/*! ./texture2d */ "./texture2d.ts");
exports.Texture2D = texture2d_1.Texture2D;
var texture3d_1 = __webpack_require__(/*! ./texture3d */ "./texture3d.ts");
exports.Texture3D = texture3d_1.Texture3D;
var texturecube_1 = __webpack_require__(/*! ./texturecube */ "./texturecube.ts");
exports.TextureCube = texturecube_1.TextureCube;
var unifiedbuffer_1 = __webpack_require__(/*! ./unifiedbuffer */ "./unifiedbuffer.ts");
exports.UnifiedBuffer = unifiedbuffer_1.UnifiedBuffer;
var vertexarray_1 = __webpack_require__(/*! ./vertexarray */ "./vertexarray.ts");
exports.VertexArray = vertexarray_1.VertexArray;
var wizard_1 = __webpack_require__(/*! ./wizard */ "./wizard.ts");
exports.Wizard = wizard_1.Wizard;
var camera_1 = __webpack_require__(/*! ./camera */ "./camera.ts");
exports.Camera = camera_1.Camera;
var tilecameragenerator_1 = __webpack_require__(/*! ./tilecameragenerator */ "./tilecameragenerator.ts");
exports.TileCameraGenerator = tilecameragenerator_1.TileCameraGenerator;
var cameramodifier_1 = __webpack_require__(/*! ./cameramodifier */ "./cameramodifier.ts");
exports.CameraModifier = cameramodifier_1.CameraModifier;
var navigation_1 = __webpack_require__(/*! ./navigation */ "./navigation.ts");
exports.Navigation = navigation_1.Navigation;
var firstpersonmodifier_1 = __webpack_require__(/*! ./firstpersonmodifier */ "./firstpersonmodifier.ts");
exports.FirstPersonModifier = firstpersonmodifier_1.FirstPersonModifier;
var panmodifier_1 = __webpack_require__(/*! ./panmodifier */ "./panmodifier.ts");
exports.PanModifier = panmodifier_1.PanModifier;
var pointerlock_1 = __webpack_require__(/*! ./pointerlock */ "./pointerlock.ts");
exports.PointerLock = pointerlock_1.PointerLock;
var trackballmodifier_1 = __webpack_require__(/*! ./trackballmodifier */ "./trackballmodifier.ts");
exports.TrackballModifier = trackballmodifier_1.TrackballModifier;
var turntablemodifier_1 = __webpack_require__(/*! ./turntablemodifier */ "./turntablemodifier.ts");
exports.TurntableModifier = turntablemodifier_1.TurntableModifier;
var zoommodifier_1 = __webpack_require__(/*! ./zoommodifier */ "./zoommodifier.ts");
exports.ZoomModifier = zoommodifier_1.ZoomModifier;
var ndcfillingrectangle_1 = __webpack_require__(/*! ./ndcfillingrectangle */ "./ndcfillingrectangle.ts");
exports.NdcFillingRectangle = ndcfillingrectangle_1.NdcFillingRectangle;
var ndcfillingtriangle_1 = __webpack_require__(/*! ./ndcfillingtriangle */ "./ndcfillingtriangle.ts");
exports.NdcFillingTriangle = ndcfillingtriangle_1.NdcFillingTriangle;
var kernel_1 = __webpack_require__(/*! ./kernel */ "./kernel.ts");
exports.AbstractKernel = kernel_1.AbstractKernel;
var antialiasingkernel_1 = __webpack_require__(/*! ./antialiasingkernel */ "./antialiasingkernel.ts");
exports.AntiAliasingKernel = antialiasingkernel_1.AntiAliasingKernel;
var randomsquarekernel_1 = __webpack_require__(/*! ./randomsquarekernel */ "./randomsquarekernel.ts");
exports.RandomSquareKernel = randomsquarekernel_1.RandomSquareKernel;
var kernel_2 = __webpack_require__(/*! ./kernel */ "./kernel.ts");
exports.KernelF32 = kernel_2.KernelF32;
exports.KernelI32 = kernel_2.KernelI32;
exports.KernelI8 = kernel_2.KernelI8;
exports.KernelUI32 = kernel_2.KernelUI32;
exports.KernelUI8 = kernel_2.KernelUI8;
var accumulatepass_1 = __webpack_require__(/*! ./accumulatepass */ "./accumulatepass.ts");
exports.AccumulatePass = accumulatepass_1.AccumulatePass;
var blitpass_1 = __webpack_require__(/*! ./blitpass */ "./blitpass.ts");
exports.BlitPass = blitpass_1.BlitPass;
var debugpass_1 = __webpack_require__(/*! ./debugpass */ "./debugpass.ts");
exports.DebugPass = debugpass_1.DebugPass;
var readbackpass_1 = __webpack_require__(/*! ./readbackpass */ "./readbackpass.ts");
exports.ReadbackPass = readbackpass_1.ReadbackPass;
var gaussfilter_1 = __webpack_require__(/*! ./gaussfilter */ "./gaussfilter.ts");
exports.GaussFilter = gaussfilter_1.GaussFilter;
var shadowpass_1 = __webpack_require__(/*! ./shadowpass */ "./shadowpass.ts");
exports.ShadowPass = shadowpass_1.ShadowPass;
var eyegazedatastream_1 = __webpack_require__(/*! ./eyegazedatastream */ "./eyegazedatastream.ts");
exports.EyeGazeDataStream = eyegazedatastream_1.EyeGazeDataStream;
exports.EyeGazeDataStreams = eyegazedatastream_1.EyeGazeDataStreams;
var eyegazeeventprovider_1 = __webpack_require__(/*! ./eyegazeeventprovider */ "./eyegazeeventprovider.ts");
exports.EyeGazeEventProvider = eyegazeeventprovider_1.EyeGazeEventProvider;
var eyegazeevent_1 = __webpack_require__(/*! ./eyegazeevent */ "./eyegazeevent.ts");
exports.EyeGazeData = eyegazeevent_1.EyeGazeData;
__export(__webpack_require__(/*! ./core/index */ "./core/index.ts"));
__export(__webpack_require__(/*! ./scene/index */ "./scene/index.ts"));
__export(__webpack_require__(/*! ./text/index */ "./text/index.ts"));
var root_auxiliaries = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
exports.auxiliaries = root_auxiliaries;
var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "../node_modules/gl-matrix/esm/index.js");
exports.vec2 = gl_matrix_1.vec2;
exports.vec3 = gl_matrix_1.vec3;
exports.vec4 = gl_matrix_1.vec4;
var gl_matrix_2 = __webpack_require__(/*! gl-matrix */ "../node_modules/gl-matrix/esm/index.js");
exports.mat2 = gl_matrix_2.mat2;
exports.mat2d = gl_matrix_2.mat2d;
exports.mat3 = gl_matrix_2.mat3;
exports.mat4 = gl_matrix_2.mat4;
var gl_matrix_3 = __webpack_require__(/*! gl-matrix */ "../node_modules/gl-matrix/esm/index.js");
exports.quat = gl_matrix_3.quat;
var root_gl_matrix_extensions = __webpack_require__(/*! ./gl-matrix-extensions */ "./gl-matrix-extensions.ts");
exports.gl_matrix_extensions = root_gl_matrix_extensions;
var root_tuples = __webpack_require__(/*! ./tuples */ "./tuples.ts");
exports.tuples = root_tuples;


/***/ }),

/***/ "./webgl-operate.ts":
/*!**************************!*\
  !*** ./webgl-operate.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./webgl-operate.slim */ "./webgl-operate.slim.ts"));
__export(__webpack_require__(/*! ./gltf/index */ "./gltf/index.ts"));
var root_properties = __webpack_require__(/*! ./properties */ "./properties.ts");
exports.properties = root_properties;
var root_fetch = __webpack_require__(/*! ./fetch */ "./fetch.ts");
exports.fetch = root_fetch;
var root_raymath = __webpack_require__(/*! ./raymath */ "./raymath.ts");
exports.ray_math = root_raymath;
__export(__webpack_require__(/*! ./debug/index */ "./debug/index.ts"));
var viewer_EventBlocker = __webpack_require__(/*! ./viewer/eventblocker */ "./viewer/eventblocker.ts");
var viewer_Fullscreen = __webpack_require__(/*! ./viewer/fullscreen */ "./viewer/fullscreen.ts");
var viewer;
(function (viewer) {
    viewer.EventBlocker = viewer_EventBlocker.EventBlocker;
    viewer.Fullscreen = viewer_Fullscreen.Fullscreen;
})(viewer = exports.viewer || (exports.viewer = {}));


/***/ }),

/***/ "./wizard.ts":
/*!*******************!*\
  !*** ./wizard.ts ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var auxiliaries_1 = __webpack_require__(/*! ./auxiliaries */ "./auxiliaries.ts");
var Wizard = (function () {
    function Wizard() {
    }
    Wizard.queryInternalTextureFormat = function (context, target, precision) {
        var gl = context.gl;
        var gl2facade = context.gl2facade;
        var floatWriteSupport = (context.isWebGL1 && context.supportsTextureFloat) ||
            (context.isWebGL2 && context.supportsColorBufferFloat);
        var halfWriteSupport = (context.isWebGL1 && context.supportsTextureHalfFloat) ||
            (context.isWebGL2 && context.supportsColorBufferFloat);
        if (precision === undefined) {
            precision = Wizard.Precision.auto;
        }
        var query = precision === undefined ? Wizard.Precision.auto : precision;
        if (!(precision in Wizard.Precision)) {
            auxiliaries_1.log(auxiliaries_1.LogLevel.Warning, "unknown precision '" + query + "' changed to '" + Wizard.Precision.auto + "'");
            precision = Wizard.Precision.auto;
        }
        if (precision === Wizard.Precision.auto) {
            query = floatWriteSupport ? Wizard.Precision.float : halfWriteSupport ?
                Wizard.Precision.half : Wizard.Precision.byte;
        }
        var type;
        var internalFormatIndex;
        if (query === Wizard.Precision.half && halfWriteSupport) {
            context.isWebGL2 ? context.colorBufferFloat : context.textureHalfFloat;
            type = gl2facade.HALF_FLOAT;
            internalFormatIndex = 1;
        }
        else if ((query === Wizard.Precision.float || query === Wizard.Precision.half)
            && floatWriteSupport) {
            context.isWebGL2 ? context.colorBufferFloat : context.textureFloat;
            type = gl.FLOAT;
            internalFormatIndex = 0;
        }
        else {
            type = gl.UNSIGNED_BYTE;
            internalFormatIndex = 2;
        }
        if (context.isWebGL1) {
            auxiliaries_1.assert([gl.RGB, gl.RGBA].includes(target), 'target must be gl.RGB or gl.RGBA in WebGL 1');
            return [target, type, query];
        }
        switch (target) {
            case gl.RGBA:
                return [[gl.RGBA32F, gl.RGBA16F, gl.RGBA8][internalFormatIndex], type, query];
            case gl.RGB:
                return [[gl.RGB32F, gl.RGB16F, gl.RGB8][internalFormatIndex], type, query];
            case gl.RG:
                return [[gl.RG32F, gl.RG16F, gl.RG8][internalFormatIndex], type, query];
            case gl.RED:
                return [[gl.R32F, gl.R16F, gl.R8][internalFormatIndex], type, query];
            default:
                auxiliaries_1.assert(false, "internal format querying is not yet supported for formats other than RGBA, RGB");
        }
        return [gl.NONE, gl.NONE, query];
    };
    return Wizard;
}());
exports.Wizard = Wizard;
(function (Wizard) {
    var Precision;
    (function (Precision) {
        Precision["float"] = "float";
        Precision["half"] = "half";
        Precision["byte"] = "byte";
        Precision["auto"] = "auto";
    })(Precision = Wizard.Precision || (Wizard.Precision = {}));
})(Wizard = exports.Wizard || (exports.Wizard = {}));
exports.Wizard = Wizard;


/***/ }),

/***/ "./zoommodifier.ts":
/*!*************************!*\
  !*** ./zoommodifier.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var cameramodifier_1 = __webpack_require__(/*! ./cameramodifier */ "./cameramodifier.ts");
var ZoomModifier = (function (_super) {
    __extends(ZoomModifier, _super);
    function ZoomModifier() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ZoomModifier.prototype.update = function () {
    };
    return ZoomModifier;
}(cameramodifier_1.CameraModifier));
exports.ZoomModifier = ZoomModifier;


/***/ }),

/***/ 0:
/*!******************************************!*\
  !*** multi polyfill.ts webgl-operate.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! polyfill.ts */"./polyfill.ts");
module.exports = __webpack_require__(/*! webgl-operate.ts */"./webgl-operate.ts");


/***/ }),

/***/ "rxjs":
/*!************************************************************************************!*\
  !*** external {"root":["rxjs"],"commonjs":"rxjs","commonjs2":"rxjs","amd":"rxjs"} ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_rxjs__;

/***/ })

/******/ });
});
//# sourceMappingURL=webgl-operate.js.map